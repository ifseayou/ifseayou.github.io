<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":"ture"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这是第二次读DDIA，全名叫做《Design Data-Intensive Application》 直译为：设计数据密集型应用或数据密集型应用的设计；更多精彩内容，欢迎关注微信公众号：stackoverflow 🎈为什么分享这本书🎈 我相信各位一定历经过这样的场景：春节档档期一下子上映了很多场电影，一场电影要不要去看呢？对于我来说，通常都是先看一下豆瓣评分，如果高的话，就买票入场，所以为什么">
<meta property="og:type" content="article">
<meta property="og:title" content="设计数据密集型应用">
<meta property="og:url" content="http://example.com/2023/09/21/ddia/index.html">
<meta property="og:site_name" content="iaddu">
<meta property="og:description" content="这是第二次读DDIA，全名叫做《Design Data-Intensive Application》 直译为：设计数据密集型应用或数据密集型应用的设计；更多精彩内容，欢迎关注微信公众号：stackoverflow 🎈为什么分享这本书🎈 我相信各位一定历经过这样的场景：春节档档期一下子上映了很多场电影，一场电影要不要去看呢？对于我来说，通常都是先看一下豆瓣评分，如果高的话，就买票入场，所以为什么">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/01.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/37.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/15.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/57.png">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/16.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/17.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/18.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/19.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/20.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/21.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/22.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/23.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/24.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/25.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/26.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/27.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/28.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/29.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/30.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/31.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/32.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/33.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/58.png">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/59.png">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/61.png">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/34.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/35.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/60.png">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/62.png">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/63.png">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/47.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/48.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/49.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/50.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/51.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/52.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/53.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/56.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/36.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/02.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/03.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/04.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/05.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/06.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/07.png">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/07.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/08.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/02.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/10.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/09.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/11.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/12.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/13.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/03.png">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/14.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/42.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/43.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/44.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/38.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/39.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/40.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/45.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/46.jpg">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/55.jpg">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8">
<meta property="og:image" content="http://example.com/2023/09/21/ddia/43.jpg">
<meta property="og:image" content="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8">
<meta property="article:published_time" content="2023-09-21T02:12:57.000Z">
<meta property="article:modified_time" content="2023-10-01T09:21:15.850Z">
<meta property="article:author" content="i_add_u">
<meta property="article:tag" content="技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/09/21/ddia/01.jpg">

<link rel="canonical" href="http://example.com/2023/09/21/ddia/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>设计数据密集型应用 | iaddu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end -->
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">iaddu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/21/ddia/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="i_add_u">
      <meta itemprop="description" content="小舟从此逝，江海寄余生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iaddu">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计数据密集型应用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-21 10:12:57" itemprop="dateCreated datePublished" datetime="2023-09-21T10:12:57+08:00">2023-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-01 17:21:15" itemprop="dateModified" datetime="2023-10-01T17:21:15+08:00">2023-10-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这是第二次读DDIA，全名叫做《Design Data-Intensive Application》 直译为：设计数据密集型应用或数据密集型应用的设计；更多精彩内容，欢迎关注微信公众号：stackoverflow</p>
<p>🎈<strong>为什么分享这本书</strong>🎈</p>
<p>我相信各位一定历经过这样的场景：春节档档期一下子上映了很多场电影，一场电影要不要去看呢？对于我来说，通常都是先看一下豆瓣评分，如果高的话，就买票入场，所以为什么选择分享这本书，那就不得不说下这本书的溢美之词</p>
<span id="more"></span>
<h3 id="关于ddia的溢美之词">关于ddia的溢美之词</h3>
<p>可以看到，这本书的评价惊人的高，居然达到了 9.7分的高分，有的同学可能觉得9.7分并不是一个很高的分数，来看下面这部是个码农都知道的书《算法导论》，这本书的评分是多少呢？ 9.2分，当然这是一个很高的分数，但是ddia 比这个高度还要高 0.5分；有的同学可能还是不能很直接的get到这本书的魅力，OK，我们来和豆瓣电影评分类比一下，要知道豆瓣中电影评分最高的也就是9.7分，也就是大名鼎鼎的，我相信各位应该都看过《肖申克的救赎》</p>
<p align="center">
  <img src="/2023/09/21/ddia/01.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 设计数据密集型应用的赞美之词 </span>
</p>
<p>甚至ByteDance 这家公司将这本书写进入interview doc。<strong>所以结论来了，DDIA , 你值得拥有</strong></p>
<h3 id="关于作者">关于作者</h3>
<p><a target="_blank" rel="noopener" href="https://martin.kleppmann.com/">Martin Kleppmann</a></p>
<h1>整书大纲</h1>
<p>下面是整书的一个脉络：分为<strong>3</strong>个部分12个章节</p>
<p align="center">
  <img src="/2023/09/21/ddia/37.jpg" width="80%" alt="Your image description">
  <br>
  <span style="color:gray"> 书籍结构目录 </span>
</p>
<h2 id="哪3部分">哪3部分</h2>
<h3 id="1️⃣-数据系统的基石">1️⃣ 数据系统的基石</h3>
<p>主要讲述了数据系统底层的一些概念，无论是单机上的单点数据系统，还是分布在多机器上的分布式数据系统。这个讨论的范围是 <em>单机或者多机器，区别于第二部分仅谈论多机器上的分布式系统</em></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>1：可靠性、可扩展性、可维护性</strong>  在开发一个应用的时候，必须要满足各种功能需求才能称之为有用，除了功能需求（也就是能够实现什么功能）还需要一些非功能需求，也就是通用属性，比如说可靠性<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，可扩展性<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，可维护性<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>
<blockquote></blockquote>
<ul class="lvl-2">
<li class="lvl-4">
<p><strong>2：数据模型与查询语言</strong>  这个是从使用者的角度出发（⚠️<em>注意这个视角很重要</em>） 。描述数据录入数据系统的格式，已及如何将存入的数据取出来。涉及<strong>关系模型，文档模型，图模型</strong>。比如说对于关系型数据库来说，数据模型 = DML(Data Manipulation Language)；查询语言 = DQL(Data Query Language 一种声明式的查询语句) 。阐述了关系模型的各个挑战者挑战关系模型的霸主地位，最终落败的过程，数据模型发展至今关系模型依然王者</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>3：存储与检索</strong>  这个是<strong>从数据系统的角度出发</strong>，描述数据系统如何存储我们录入的数据，以及在我们需要这部分数据，存储系统如何精准、快速的定位到目标数据。这里注意区分<em>2章节和3章节的角度</em></p>
</li>
<li class="lvl-2">
<p><strong>4：编码与演化</strong>  随着时间推移，数据系统由于功能的迭代，需要对初始涉及的数据模型(schema)进行更改，那么如何处理数据模型的前后兼容问题，就是这个章节要讨论的问题</p>
</li>
</ul>
<h3 id="2️⃣-分布式数据">2️⃣ 分布式数据</h3>
<p>本章主要讲述在多机器的分布式数据系统中，将会有多台机器参与数据的存储和检索，数据系统所面临挑战，包括</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>5：复制</strong> ： 同一份数据，多个拷贝/副本。这将为系统的可用性提供支撑</p>
</li>
<li class="lvl-2">
<p><strong>6：分区</strong> ： 同一份数据，分割成多块</p>
</li>
<li class="lvl-2">
<p><strong>7：事务</strong> ： 主要介绍 事务，ACID，隔离级别等内容，这部分内容是重点也是难点</p>
</li>
<li class="lvl-2">
<p><strong>8：分布式系统的麻烦</strong> ： 在极端情况下，分布式系统黑暗的诸多问题，看完这一章节，你会觉得你所处于的环境真的是太幸福了</p>
</li>
<li class="lvl-2">
<p><strong>9：一致性与共识</strong> ：分布式数据系统如何去实现一致性和达成共识，从而避免类似于 brain split  的问题，这一章节会讨论在构建容错分布式系统的时候使用到的 算法和协议(比如Raft、Paxos、ZAB)</p>
</li>
</ul>
<h3 id="3️⃣-派生数据">3️⃣ 派生数据</h3>
<p>第一/二部分系统的考量了分布式数据库的方方面面，真实世界的大型应用程序经常需要以多种方式访问和处理数据，没有一个数据库可以同时满足所有这些不同的需求。因此应用程序通常组合使用多种组件：数据存储，索引，缓存，分析系统，等等，并实现在这些组件中移动数据的机制</p>
<p>该书的最后一部分，研究将多个不同数据系统（可能有着不同数据模型，并针对不同的访问模式进行优化）集成为一个协调一致的应用架构时，会遇到的问题</p>
<p>主要讨论衍生(派生)数据：所谓<em>衍生数据</em> 是以输入数据输出新的数据，输出是衍生数据（derived data）的一种形式 ，流处理和批处理都会产生衍生数据</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>10：批处理</strong>  ： 有界数据的处理</p>
</li>
<li class="lvl-2">
<p><strong>11：流处理</strong>  ： 无界数据的处理</p>
</li>
<li class="lvl-2">
<p><strong>12：数据系统的未来</strong> 🤣</p>
</li>
</ul>
<p>🎈<strong>以上呢</strong>🎈，就是整本书的一个简短的概括，下面的内容就是我基于书中的内容做的一些总结，已及自己的一些启发</p>
<h2 id="计算密集vs数据密集">计算密集vs数据密集</h2>
<p>下图是应用程序的简要分类：</p>
<p align="center">
  <img src="/2023/09/21/ddia/15.jpg" width="80%" alt="Your image description">
  <br>
  <span style="color:gray"> 数据密集型应用和计算密集型应用的区别 </span>
</p>
<p>🅰️ 首先是计算密集型应用，这类应用的瓶颈是算力，比如进行气象预测，对于这类应用我们处理的方式就是不断的提升计算机的算力，比如增加CPU的核数，增加内存等</p>
<p>🅱️ 再有就是数据密集型，这类应用的瓶颈是：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据量，Volume</p>
</li>
<li class="lvl-2">
<p>数据的复杂性，Variety</p>
</li>
<li class="lvl-2">
<p>数据的变更速度，Velocity</p>
</li>
</ul>
<p>对于数据密集型应用，我们通常会使用标准的组件来处理：</p>
<p>1️⃣ 存储数据，以便自己或其他应用程序之后能再次找到(数据库 database)</p>
<p>2️⃣ 记住开销昂贵操作的结果，加快读取速度(缓存 cache)</p>
<p>3️⃣ 允许用户按关键字搜索数据，或以各种方式对数据进行过滤(搜索索引 search indexes)</p>
<p>4️⃣ 向其他进程发送消息，进行异步处理(流处理 stream processing)</p>
<p>5️⃣ 定期处理累积的大批量数据(批处理 batch processing)</p>
<h3 id="如何描述负载？">如何描述负载？</h3>
<p>可以使用<strong>负载参数（load parameters）</strong> 的数字来描述负载。参数可能是</p>
<ol>
<li class="lvl-3">
<p>每秒向Web服务器发出的请求</p>
</li>
<li class="lvl-3">
<p>数据库中的读写比率</p>
</li>
<li class="lvl-3">
<p>聊天室中同时活跃的用户数量</p>
</li>
<li class="lvl-3">
<p>缓存命中率</p>
</li>
</ol>
<p>除此之外，需要关注<strong>平均情况</strong>或者<strong>峰值情况</strong>。有写负载和读负载，如果写负载远远低于读负载，此时我们可以让写入时做更多的工作，便于我们在读取的时候做更少的工作</p>
<p>推特在推文写入和推文读取时，使用了两种不同的策略</p>
<h3 id="如何描述性能？">如何描述性能？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>批处理系统，每秒可以处理的记录数量，即吞吐量（throughput），或者在特定规模数据集上运行作业的总时间</p>
</li>
<li class="lvl-2">
<p>在线系统，通常更重要的是服务的<strong>响应时间（response time）</strong>，即客户端发送请求到接收响应之间的时间</p>
</li>
</ul>
<p>一般而言，将响应时间视为一个可以测量的数值<strong>分布（distribution）</strong>，而不是单个数值，比如<strong>100次请求响应时间的均值与百分位数</strong>。第95、99和99.9百分位点（缩写为p95，p99和p999），如果第95百分位点响应时间是1.5秒，则意味着100个请求中的95个响应时间快于1.5秒，而100个请求中的5个响应时间超过1.5秒</p>
<p>百分位点通常用于<strong>服务级别目标（SLO, service level objectives）<strong>和</strong>服务级别协议（SLA, service level agreements）</strong>，即定义服务预期性能和可用性的合同，如果没达到服务目标，客户可以不付款</p>
<p>什么是头部阻塞？</p>
<blockquote>
<p>由于服务器只能并行处理少量的事务（如受其CPU核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为 <strong>头部阻塞（head-of-line blocking）</strong>，也叫做<strong>排队延迟（queueing delay）</strong>，通常占了高百分位点处响应时间的很大一部分</p>
<p><strong>当一个请求需要多个后端请求时，单个后端慢请求就会拖慢整个终端用户的请求</strong>，效果称为尾部延迟放大</p>
</blockquote>
<p>负载参数和性能参数是讨论可扩展性的前提，可扩展性即为当负载参数增加时，如何保持良好的性能？</p>
<h3 id="什么是弹性的？">什么是弹性的？</h3>
<p>如果说系统是 <strong>弹性（elastic）</strong> 的，这意味着可以在检测到负载增加时自动增加计算资源，而其他系统则是手动扩展（人工分析容量并决定向系统添加更多的机器）</p>
<h1>第2章节-数据模型与查询语言</h1>
<h2 id="文档模型和关系模型的优劣势？">文档模型和关系模型的优劣势？</h2>
<p>文档模型如JSON的优势在于结构灵活，你可以将任意的键和值添加到文档中，而在关系模型中你必须提前预设这样的字段或者进行 <code>alter table</code> 操作，文档模型在连接上的劣势，导致数据如果有多份，必须要存储多次，有较高的数据不一致风险。如果每次读取文档的全部或者大部分内容，查询局部性会有很大优势，而关系模型将数据分割多块的行为，不得不进行连接</p>
<p>关系模型一般是规范化的，能够保证数据的一致性（外键），但是其中的结构变化，是一个较耗时的操作如果表很大的话，执行 <code>alter table  &amp; update </code> 需要很久，此时会有锁表行为</p>
<h2 id="声明式查询vs命令式查询">声明式查询vs命令式查询</h2>
<p>声明式查询告诉存储引擎：我需要<code>Sharks</code>类数据，而命令式查询给出找到A类数据的方法，存储引擎按照这个方法执行即可,而众多编程语言就是命令式的</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">getSharks</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">var</span> <span class="variable">sharks</span> <span class="operator">=</span> [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; animals.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (animals[i].family === <span class="string">"Sharks"</span>) {</span><br><span class="line">            sharks.push(animals[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sharks;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>SQL是一种声明式的查询语句，声明式查询不提供方法，仅指定结果的模式，接收声明的数据库可以自行选择高校的方法</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> animals <span class="keyword">WHERE</span> family <span class="operator">=</span><span class="string">'Sharks'</span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="MapReduce是什么">MapReduce是什么</h2>
<p>MapReduce是一个由Google推广的编程模型，它基于<code>map</code>（也称为<code>collect</code>）和<code>reduce</code>（也称为<code>fold</code>或<code>inject</code>）函数。它既不是一个声明式的查询语言，也不是一个完全命令式的查询API，而是处于两者之间：查询的逻辑用代码片断来表示，这些代码片段会被处理框架重复性调用</p>
<h2 id="图">图</h2>
<p>如果你的应用程序大多数的关系是一对多关系（树状结构化数据），或者大多数记录之间不存在关系，那么使用文档模型是合适的。关系模型可以处理多对多关系的简单情况，但是随着数据之间的连接变得更加复杂，将数据建模为图形显得更加自然</p>
<p>一个图由两种对象组成：<strong>顶点（vertices）</strong> 和 <strong>边（edges）</strong>，典型的例子包括：社交图谱,网络图谱,公路或铁路网络</p>
<h3 id="A-什么是属性图模型？">A-什么是属性图模型？</h3>
<p>在属性图模型中，包含顶点和边，在属性图模型中，顶点和边分别包括</p>
<table>
<thead>
<tr>
<th>顶点（vertex）</th>
<th>边（edge）</th>
</tr>
</thead>
<tbody>
<tr>
<td>唯一的标识符</td>
<td>唯一的标识符</td>
</tr>
<tr>
<td>一组 <strong>出边（outgoing edges）</strong></td>
<td>边的起点（tail vertex）</td>
</tr>
<tr>
<td>一组 <strong>入边（ingoing edges）</strong></td>
<td>边的终点（head vertex）</td>
</tr>
<tr>
<td></td>
<td>描述两个顶点之间关系类型的标签</td>
</tr>
<tr>
<td>一组属性（键值对）</td>
<td>一组属性（键值对）</td>
</tr>
</tbody>
</table>
<p>可以将图存储看作由两个关系表组成：一个存储顶点，另一个存储边</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> vertices (</span><br><span class="line">  vertex_id  <span class="type">INTEGER</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  properties JSON</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> edges (</span><br><span class="line">  edge_id     <span class="type">INTEGER</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  tail_vertex <span class="type">INTEGER</span> <span class="keyword">REFERENCES</span> vertices (vertex_id),</span><br><span class="line">  head_vertex <span class="type">INTEGER</span> <span class="keyword">REFERENCES</span> vertices (vertex_id),</span><br><span class="line">  label       TEXT,</span><br><span class="line">  properties  JSON</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给定任何顶点，可以高效地找到它的入边和出边，从而遍历图，即沿着一系列顶点的路径前后移动，建以下索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX edges_tails <span class="keyword">ON</span> edges (tail_vertex);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX edges_heads <span class="keyword">ON</span> edges (head_vertex);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="B-Cypher-属性图模型声明式查询语句">B-Cypher 属性图模型声明式查询语句</h3>
<p>Cypher是属性图的声明式查询语言，为Neo4j图形数据库而发明</p>
<p align="center">
  <img src="/2023/09/21/ddia/57.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 图模型&amp;图数据写入&amp;图数据查询 </span>
</p>
<h2 id="读时模式vs写时模式">读时模式vs写时模式</h2>
<p><strong>读时模式（schema-on-read）</strong>：数据的结构是隐含的，只有在数据被读取时才被解释，比如文档数据库</p>
<p><strong>写时模式（schema-on-write）</strong>：传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式</p>
<p>读时模式类似于编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查，就像静态和动态类型检查的相对优点具有很大的争议性一样，数据库中模式的强制性是一个具有争议的话题，一般来说没有正确或错误的答案</p>
<h2 id="总结">总结</h2>
<p>在历史上，数据最开始被表示为一棵大树（层次数据模型），由于不适合表示多对多的关系，发明了关系模型来解决这个问题。后来，人们发现一些应用程序也不适合采用关系模型，于是新的非关系型“NoSQL”数据</p>
<ol>
<li class="lvl-3">
<p>文档数据库的应用场景是：数据通常是自我包含的，而且文档之间的关系非常稀少。</p>
</li>
<li class="lvl-3">
<p>图形数据库用于相反的场景：任意事物都可能与任何事物相关联。</p>
</li>
</ol>
<p>这三种模型（文档，关系和图形）在今天都被广泛使用</p>
<h1>第3章节-存储与检索</h1>
<p>存储与检索的内容，即：数据库在最基础的层次上完成的2件事情：</p>
<p>🅰️ 当你把数据交付给它的时候，它如何将数据存储起来</p>
<p>🅱️ 当你向数据库索要数据时，它如何将数据返回给你</p>
<p>由于<strong>事务性负载</strong>和<strong>分析性负载</strong>的存储引擎之间存在着很大的差异，这两类的存储引擎我们分开来描述</p>
<p><strong>在事务处理方面</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>日志结构存储引擎  ；从最简单的数据库实现append-log(无索引日志)到 LSM(日志结构合并树) 树的演化历程</p>
</li>
<li class="lvl-2">
<p>面向页面的存储引擎 ，典型的比如B-Tree</p>
</li>
</ul>
<p>在<strong>分析性存储引擎方面</strong>，我们谈谈</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据仓库</p>
</li>
<li class="lvl-2">
<p>星型模型&amp;雪花模型</p>
</li>
<li class="lvl-2">
<p>列存储</p>
</li>
</ul>
<h2 id="无索引日志">无索引日志</h2>
<p>我们来看下 <strong>世界上最简单的数据库</strong> 是如何实现的</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>插入操作（<code>db_set</code>）</p>
</li>
<li class="lvl-2">
<p>更新操作（<code>db_set</code>）</p>
</li>
<li class="lvl-2">
<p>查询操作（<code>db_get</code>）</p>
</li>
</ul>
<p align="center">
  <img src="/2023/09/21/ddia/16.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 无索引日志 &amp; 最简单的数据库 </span>
</p>
那么这个最简单的数据库底层是如何进行数据的摆放的呢？可以看到`db_set()`就是一个非常简单的追加[^4]，这**简直不是简单，甚至可以说是简陋**但正是由于这种设计使得写入变的非常的高效，代价就查找的开销是 $O(n)$ ， $O(n)$ 的复杂度，这意味着如果数据量增加一倍，查询响应时间将会增加一倍。也就是说查询时间和数据量之间的关系是线性相关的。所以我们需要**更快的得到目标结果**，那么如何去提升数据的查找效率？
<blockquote></blockquote>
<h2 id="如何提升查找效率？">如何提升查找效率？</h2>
<p align="center">
  <img src="/2023/09/21/ddia/17.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 康熙字段VS新华字典 </span>
</p>
<p>当我们还是一个小学生的时候，可能面临过类似的问题，假设说现在有2个小学生，忘记了<strong>囧</strong>字怎么写，想要用新华字典查询一下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>小明同学使用的是一本没有目录的字典(比如说康熙字典)</p>
</li>
<li class="lvl-2">
<p>小红同学 使用的是一本有目录的字典(现代新华字典)</p>
<p>那么谁最后能更快的获知 <code>jiong</code> 字的写法呢？直觉告诉我们小红同学有较大的概率最快获取到 <code>joing</code>字的写法</p>
</li>
</ul>
<p>现代字典的特征就是都会有一个目录，这个目录是在<strong>原始数据之外维护的额外的数据</strong>，正是由于目录的存在，使得小红同学能够更快的获取到目标数据。其实这个目录，其实就相当于英文中的 <code>index</code> , 而 <code>index</code>英译就是索引，至此我们可以得到一个结论：</p>
<blockquote>
<p>索引 是在原始数据之外维护的额外的数据，索引 可以加速数据访问</p>
</blockquote>
<p>🎈<strong>Post Script</strong>🎈</p>
<p>由于需要在原始数据之外额外维护一份数据，这就无形增加了空间复杂度，在计算机领域中，时间和空间就像鱼和熊掌一样，不可兼得，降低时间复杂度的方式就<strong>用空间换取时间</strong>； 可以说这个问题在计算机领域是一个绕不开的话题，如何去提升查找效率这个问题的另外一种问法是：<strong>给我一个更低的时间复杂度</strong>的实现，那么常见的比 $O(n)$  还低的时间复杂度就是 $O(1)$， $O (log_n)$  两个，$O(1)$ 的时间复杂度，我们很容易就会想到哈希表，因为哈希表的时间复杂度默认是 $O(1)$，接下来我们尝试构建哈希索引来提升查询效率</p>
<h2 id="内存中构建hash索引">内存中构建hash索引</h2>
<p align="center">
  <img src="/2023/09/21/ddia/18.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 为日志构建哈希索引 </span>
</p>
<p>那么对于存储于磁盘中的数据，我们在内存中维护一个<code>HashMap</code>，维护<code>key</code>和<code>value</code> 的偏移量，这样一来，我们就能够迅速的定位到目标数据，比如我们想要找到 <code>key = 42</code> 的数据，通过查询内存中的HashMap表，获得偏移量64 ，所以可以直接定位到数据，而不在需要从头开始遍历</p>
<p>随着我们不断的在文件末尾追加文件，磁盘中的单个文件也会越来越大，甚至单个文件可能吃掉整个磁盘的存储。所以，<strong>如何用有限的存储存储更多的数据？</strong> 即，如何避免磁盘的空间的消耗？</p>
<h2 id="分段存储-压缩-分段合并-hash索引的局限性">分段存储&amp;压缩&amp;分段合并 &amp; hash索引的局限性</h2>
<p align="center">
  <img src="/2023/09/21/ddia/19.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 日志分段 &amp; 分段日志压缩 </span>
</p>
<p>我们解决的方案是：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>分段存储：也就是说当追加文件的 <code>size</code>（通常是几兆字节） 达到了一定的阈值之后，我们重新写入新的文件（每个段维护自己的索引）</p>
</li>
<li class="lvl-2">
<p>压缩：丢弃重复的键，保留每个键的最新值</p>
</li>
</ul>
<p>如上图中原本12个键 压缩之后之后3个键，整个文件的<code>size</code>降低。<strong>如何进一步改进？</strong></p>
<p align="center">
  <img src="/2023/09/21/ddia/20.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 日志分段 &amp; 分段日志压缩 &amp; 压缩日志合并 </span>
</p>
<p>在执行压缩的同时，可以将压缩之后的<strong>段合并</strong>。如 Data file segment 1 和 Data file Segment 2 在压缩了之后，进行了一个合并操作，得到了 Merged Segment(比如mew 这个键压缩合并的过程)。压缩和合并对用户是没有感知的，由后台进程完成，在合并的时候由旧的段文件提供读写请求，在合并完成之后，读写请求转化为新的合并后的段</p>
<p>那么由于hash表本身的特性，也会导致我们构建的哈希索引有一定的局限性，比如：</p>
<p>🅰️ 哈希表是存在于内存中的</p>
<p>🅱️ 范围查询是软肋</p>
<p>那么如何突破哈希表的局限性，寻找更好的索引结构？</p>
<h2 id="SSTable-排序字符串表">SSTable 排序字符串表</h2>
<p>这个问题的答案是：排序字符串表，也就是<strong>SSTable<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></strong>, 也就是：在段文件中，对键值对的序列排序</p>
<p align="center">
  <img src="/2023/09/21/ddia/21.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> SStable </span>
</p>
<p>比如上图中，对于已经排好序段文件1，段文件2 ，段文件3 ，进行压缩和合并，而且，在合并之后，仍然需要保证合并之后的段文件有序，所以我们需要一个合适的排序算法：<strong>那么这个排序算法是什么呢？</strong> 是冯诺依曼发明的归并排序算法；merge sort 的优势就在于：内存在小于被排序文件大小的时候，仍然可以将排序完成</p>
<blockquote></blockquote>
<p>使用SSTable可以有效的突破内存限制和解决范围查询的问题。如下图中我们查找，<code>handiwork</code> 的过程，可以发现不是在内存中保存所有键的索引，由于SSTable维护了顺序关系，我们的索引以稀疏索引的方式存在于内存中。同时，可以支持范围查询</p>
<p align="center">
  <img src="/2023/09/21/ddia/22.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 稀疏索引，比如每几千个字节一个键 </span>
</p>
<h2 id="LSM-日志结构合并树">LSM 日志结构合并树</h2>
<p>在前面的讲述中，我们默认了落盘段文件是有序的，在落盘写入段文件之前，<strong>如何按键排序</strong>？考虑到效率问题，最初的的写入一定是在内存中的，到达一定的时间阈值或者是内存阈值的时候，在进行落盘形成 SSTable，那么内存中<strong>选择什么样的数据结构？</strong></p>
<p>1️⃣ 内存表，<strong>为什么是AVL-Tree ？</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>首先平衡二叉树本身就是二叉搜索树，而二叉搜索树中序遍历就是顺序结构，可以直接落盘形成SSTable</p>
</li>
<li class="lvl-2">
<p>由于平衡特性，可以保持树的结构，而不是退化成链表，使得查询的时间复杂度维持在 $O(logN)$, 而且对于新加入的数据，平衡二叉树通过左旋，或者右旋的方式保持平衡性</p>
</li>
</ul>
<p>2️⃣ 落盘，也就是平衡二叉树的中序遍历方式落盘</p>
<p>3️⃣ 读取请求，先请求内存，然后查询磁盘段</p>
<p>4️⃣ 压缩和合并： 后台压缩合并段文件，并丢弃覆盖/删除旧值</p>
<p>5️⃣ 防止数据库崩溃（保存在AVL-Tree，但是未落盘到SStable）：磁盘保留一份单独的日志，每个写入都追加到磁盘上，防止数据库崩溃，内存数据丢失</p>
<p align="center">
  <img src="/2023/09/21/ddia/23.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 那么使用这种LSM结构的组件有哪些 </span>
</p>
<p>Cassandra<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>、Bigtable、HBase、Elasticsearch、Solr<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>、Hologres<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></p>
<blockquote></blockquote>
<p><strong>这种先内存排序，再落盘排序的结构，就是LSM(Log-Structure Merge Tree 日志结构合并树)结构</strong>，<strong>LSM结构和B±Tree相比，减少了随机IO，极大的提高的写性能</strong></p>
<h2 id="面向页存储引擎">面向页存储引擎</h2>
<p>接下来我们介绍另外一种存储引擎：面向页面的存储引擎，比如B 树，B树会将数据库分解为固定大小的块或者是页面<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>，传统大小为4K而且一次只能读取或者写入一个页面，和LSM对比一下</p>
<p align="center">
  <img src="/2023/09/21/ddia/24.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> B树和LSM比对 </span>
</p>
<blockquote></blockquote>
<p>下图展示了面向页面的存储引擎是如何查询数据的</p>
<p align="center">
  <img src="/2023/09/21/ddia/25.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 面向页面的存储引擎是如何查询数据的 </span>
</p>
<p>分支因子：<strong>在B树中一个页面中对子页面的引用数量</strong>。伴随着上世纪70年代关系型数据库的发展至今，面向页面的存储引擎发展至今已经非常成熟了</p>
<h2 id="向页面添加元素">向页面添加元素</h2>
<p>如何向B树中增加一个数据，如下图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/26.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 如何向B树中增加一个数据 </span>
</p>
<blockquote>
<p>WAL即在数据写数据页之前，先记录到"小黑板"<sub>WAL</sub>上，对于一个更新操作来说，如果每次更新都需要立刻写磁盘，存储引擎需要找到被更新的记录，然后更新，这个先定位再更新的机制必然有一定的成本（查找成本+IO成本），如果<strong>引擎会将记录写到 文件 里，并且更新内存</strong>，在适当（系统比较空）的时候，将操作记录刷写到磁盘， 如此便可以提升更新效率。事实上MySQL的InnDB 引擎就是这么做的</p>
</blockquote>
<h2 id="比对LSM树-和-B树">比对LSM树 和 B树</h2>
<p>最后我们来一起对比一下LSM树和B树，也即面向日志的存储引擎和面向B树的存储引擎的优劣势</p>
<p align="center">
  <img src="/2023/09/21/ddia/27.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 比对LSM树 和 B树 </span>
</p>
<h2 id="OLTP-OLAP-和-数据仓库">OLTP&amp;OLAP 和 数据仓库</h2>
<p>数据库在历史中主要为两种系统提供支持</p>
<p>🅰️ 在线事务处理系统，即 OLTP</p>
<p>🅱️ 在线分析系统，即 OLAP</p>
<p>下表中对比了两者之间的区别，</p>
<p align="center">
  <img src="/2023/09/21/ddia/28.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> OLTP 对比 OLAP </span>
</p>
<p>起初的数据库，能够同时应对以上两种查询的情况，无论是OLTP类型的查询，还是OLAP类型的查询，单一的数据库的表现的都很好，也就是说：<strong><u>也就是说两者是一家的</u></strong>。 OLAP通常会要求 <strong>高可用</strong>与<strong>低延迟</strong>，为了保证业务系统的稳定运行，所以DBA会密切关注他们的OLTP数据库，他们通常不愿意让业务分析人员在OLTP数据库上运行临时分析查询，因为这些查询通常开销巨大，会扫描大部分数据集，这会损害同时执行的事务的性能。可以见得，OALP和OLTP 这对亲兄弟发生了矛盾，矛盾会最佳解决方案就是分家</p>
<p>在20世纪80年代末和90年代初期，渐渐地很多公司有停止使用OLTP系统进行分析，而是在单独的数据库上运行分析。这个单独的数据库被称为<strong>数据仓库(data warehouse)</strong>。因为最初的数据仓库是从关系型数据库中独立出来，只存储关系数据，而且是面向数据分析，BI(商业智能)的，只是到了后来随着大数据时代的到来，数据仓库才慢慢变的越来越像<strong>数据湖<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup></strong> (就是各种数据都跑往数据仓库里面塞)</p>
<blockquote>
<p>数据沼泽：<strong>数据沼泽</strong> 是一个劣化的数据湖，用户无法访问，或是没什么价值</p>
</blockquote>
<p>又或者说，<strong>数据湖是下一代数据仓库</strong>，从OLTP数据库中提取数据，转换成适合分析的模式，清理并加载到数据仓库中，因此数据仓库包含公司各种OLTP系统中所有的只读数据副本。下图是一个简要的示意图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/29.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> ETL过程 </span>
</p>
<h2 id="数据仓库系统组件">数据仓库系统组件</h2>
<p>我们来看一些比较出名的商业数据仓库系统，尽管他们是冠以出名的商业数据仓库系统，但是其中"商业"两个字可能是太贵，导致大多数从事数据仓库相关工作的人，其实并不知道：</p>
<img src="/2023/09/21/ddia/30.jpg" width="100%" height="70%" alt="图片名称" align="center">
<ul class="lvl-0">
<li class="lvl-2">
<p>SQL - Server   使用两套不同的存储和查询引擎来应对OALP和OLTP环境</p>
</li>
<li class="lvl-2">
<p>Teradata       天睿</p>
</li>
<li class="lvl-2">
<p>Vertica          维蒂卡</p>
</li>
<li class="lvl-2">
<p>SAP HANA    SAP  汉那</p>
</li>
<li class="lvl-2">
<p>ParAccel        帕加速</p>
</li>
</ul>
<p>相对而言，我们更喜欢免费的开源产品，下面是一些SQL-on-Hadoop 项目：</p>
<p>Hive-SQL、Spark-SQL、Flink-SQL、Presto、Druid、Kylin、Impala</p>
<h2 id="雪花模型">雪花模型</h2>
<p>在OLTP系统中，可用的数据模型很丰富，比如大类上分为</p>
<p>🅰️ 关系模型</p>
<p>🅱️ 新的非关系模型，No-SQL模型</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>文档数据库模型</p>
</li>
<li class="lvl-2">
<p>图形数据库模型</p>
</li>
</ul>
<p>相对于OATP系统来说，OLAP系统的数据模型多样性就少的多，数据仓库大多使用一样的公式化模型：<strong><u>星型模式|星型模型(也叫维度建模)</u></strong> 如下图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/31.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 星型模式示意图 </span>
</p>
<p>1️⃣ 模式的中心是一个所谓的事实表，事实表的每一行代表在特定时间发生的事件(这里，每一行代表客户购买的产品)</p>
<p>2️⃣ 事实表中的一些列是属性，例如产品销售的价格和从供应商那里购买的成本(允许计算利润余额)，通常是数字等可统计指标</p>
<p>3️⃣ 事实表中的其他列是对其他表(称为维表)的外键引用，由于事实表中的每一行都表示一个事件，因此这些维度代表事件的发生地点，时间，方式和原因</p>
<p>4️⃣ 事实表格有100列以上，有时甚至有数百列，快手宽表列长达1000+列</p>
<p>5️⃣ 星型模型进一步的扩展是雪花模型，也就是基于维度表进一步拆分</p>
<p>当表关系可视化时，事实表在中间，由维表包围；与这些表的连接就像星星的光芒，所以这模式被命名为：“星型模式”</p>
<h2 id="列式存储">列式存储</h2>
<p>在前面的存储结构中，我们介绍了</p>
<p>🅰️ 基于日志的存储：日志结构学派</p>
<p>🅱️ 基于页面的存储：就地更新学派</p>
<p>然而，典型的数据仓库查询一次只访问较少的列，如果使用行存储的话，面向行的存储引擎仍然需要将所有这些行(每个包含超过100个属性)从磁盘加载到内存中，解析它们，并过滤掉那些不符合要求的条件。这可能需要很长时间。面向列的存储背后的想法很简单：<strong>不要将所有来自一行的值存储在一起，而是将来自每一列的所有值存储在一起</strong>。如下图</p>
<p align="center">
  <img src="/2023/09/21/ddia/32.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 列式存储示意图 </span>
</p>
<p>可以观察到红色框选出来的值序列，他们是重复数据，而<strong>重复数据是压缩的好兆头</strong>。我们根据列中的数据，可以使用不同的压缩技术来进一步降低对磁盘吞吐量的需求，在数据仓库中特别有效的一种技术是<em>位图编码</em>(类似哈夫曼编码)，如下图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/33.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 位图编码和压缩 </span>
</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> () <span class="comment">--  对应着位图的 或</span></span><br><span class="line"><span class="keyword">and</span>   <span class="comment">--  对应着位图的 与</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>比如hive支持的存储格式包括textfile,parquet, rcfile,orc, 其中orc是rcfile的优化版(Optimize Rcfile，Rcfile基于Lazy Decompression)，相较于rcfile有更好的表现，列存和压缩通常会结合，压缩比ORC(ZLIB压缩) &gt;  Parquet (Uncompress即默认不压缩)&gt;  textFile（textfile不压缩），注意点是压缩在有效降低IO的同时会提升CPU的消耗</p>
</blockquote>
<p>列存储中的排列顺序也非常有意义。需要注意的是：即使按列存储数据，也需要一次对整行进行排序，一般对最常见的查询字段做为第一排序的列，第二列可以确定第一列中具有相同值的任何行的排序顺序，这将加快查询速度。同时，排序顺序可以帮助压缩列，第一个排序键的压缩效果最强，一个简单的运行长度编码（比如位图）可以将该列压缩到几千字节 —— 即使表中有数十亿行（不同的值很少，基数少）</p>
<p>写入列存储的困难</p>
<p>如果你想在列存排序表的中间插入一行，你很可能不得不重写所有的列文件。由于行由列中的位置标识，因此插入必须始终更新所有列（这大概就是Hive仅仅支持 <code>overwrite</code>操作的缘故）</p>
<p>另外的解决方案是，LSM树的这种结构，所有的写操作首先进入一个内存中的存储，在这里它们被添加到一个已排序的结构中，并准备写入磁盘。内存中的存储是面向行还是列的，这并不重要。当已经积累了足够的写入数据时，它们将与磁盘上的列文件合并，并批量写入新文件</p>
<p>什么是物化视图？</p>
<p>据仓库查询通常涉及一个聚合函数，如SQL中的COUNT，SUM，AVG，MIN或MAX。如果相同的聚合被许多不同的查询使用，那么每次都可以通过原始数据来处理。为什么不缓存一些查询使用最频繁的计数或总和？创建这种缓存的一种方式是物化视图。物化视图的常见特例称为数据立方体或OLAP立方</p>
<p>物化视图 和 虚拟视图的区别？</p>
<p>不同的是，物化视图是查询结果的实际副本，写入磁盘，而虚拟视图只是写入查询的捷径。从虚拟视图读取时，SQL引擎会将其展开到视图的底层查询中，然后处理展开的查询</p>
<p align="center">
  <img src="/2023/09/21/ddia/58.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 数据立方的两个维度，通过求和聚合 </span>
</p>
<h1>第四章节-编码和演化</h1>
<h2 id="什么是可演化性？">什么是可演化性？</h2>
<p>能灵活适应变化的系统， 修改数据系统并使其适应不断变化需求的容易程度，是与<strong>简单性</strong>和<strong>抽象性</strong>密切相关的：简单易懂的系统通常比复杂系统更容易修改</p>
<h2 id="向后兼容，向前兼容">向后兼容，向前兼容</h2>
<p>向后兼容(backward compatibility)：新代码可以读旧数据</p>
<p>向前兼容（forward compatibility）：旧代码可以读新数据</p>
<h2 id="编码数据的格式有哪些？">编码数据的格式有哪些？</h2>
<ol>
<li class="lvl-3">
<p>在内存中，数据保存在对象，结构体，列表，数组，哈希表，树等中。 这些数据结构针对CPU的高效访问和操作进行了优化（通常使用指针）</p>
</li>
<li class="lvl-3">
<p>如果要将数据写入文件，或通过网络发送，则必须将其编码为某种自包含的字节序列（例如，JSON文档）</p>
<blockquote>
<p>从内存中表示到字节序列的转换称为编码（也称为序列化（serialization）或编组（marshalling）），反过来称为解码（Decoding）（解析（Parsing），反序列化（deserialization）**，**反编组( unmarshalling））</p>
<p>编码过程也成为序列化Serialization，其中事务的隔离级别中也出现了该词，请区分2者</p>
<p>在一些编程语言中，都内建了将内存对象编码为字节序列的支持，Java有<code>java.io.Serializable</code> ，Python有<code>pickle</code></p>
</blockquote>
</li>
</ol>
<h2 id="文本编码和二进制编码">文本编码和二进制编码</h2>
<table>
<thead>
<tr>
<th>比对方面</th>
<th>文本编码</th>
<th>二进制编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>可读性</td>
<td>人类易读</td>
<td>人类不可读</td>
</tr>
<tr>
<td>数据类型</td>
<td>表示文本字符，如字母、数字、符号</td>
<td>表示各种类型的数据，包括整数、浮点数、图像、音频、程序指令等</td>
</tr>
<tr>
<td>编码方式</td>
<td>采用字符集（如ASCII、UTF-8、ISO-8859-1等）来将字符映射到数字或二进制，每个字符都有一个唯一的编码值</td>
<td>将数据直接表示为由 0 和 1 组成的二进制序列的方式。它不需要字符集</td>
</tr>
<tr>
<td>应用领域</td>
<td>处理文本数据，如文档、网页、电子邮件等</td>
<td>用于计算机内部数据表示、存储和通信，包括整数、浮点数、图像、音频、视频等。它处理的是更底层的数据表示</td>
</tr>
</tbody>
</table>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制编码示例，删除了空格换行后，81个字节</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"Martin"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"favoriteNumber"</span><span class="punctuation">:</span> <span class="number">1337</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"interests"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">"daydreaming"</span><span class="punctuation">,</span> <span class="string">"hacking"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>接下来我们使用不同的二进制编码组件/库对上述的JSON文档进行编码</p>
<p align="center">
  <img src="/2023/09/21/ddia/59.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 使用不同的二进制组件编码同一个JSON文档 </span>
</p>
<p>Avro也使用模式来指定正在编码的数据的结构， 它有两种模式语言：一种（Avro IDL）用于人工编辑，一种（基于JSON），更易于机器读取</p>
<p align="center">
  <img src="/2023/09/21/ddia/61.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> Avro 二进制编码 &amp; Avro Reader 解决读写模式的差异 </span>
</p>
<h2 id="数据流的类型">数据流的类型</h2>
<p>如果要将某些数据发送到不共享内存的另一个进程，例如，通过网络发送数据或将其写入文件，就需要将它编码为一个字节序列</p>
<p>数据在流程之间流动的一些最常见的方式：</p>
<ol>
<li class="lvl-3">
<p>通过数据库：写入编码，读取解码</p>
</li>
<li class="lvl-3">
<p>通过服务调用：REST和RPC</p>
</li>
<li class="lvl-3">
<p>通过异步消息传递：消息队列</p>
</li>
</ol>
<h3 id="A-Web服务">A-Web服务</h3>
<p>有两种流行的Web服务方法：REST和SOAP</p>
<p>将大型应用程序按照功能区域分解为较小的服务，一个服务请求另外一个服务的功能或者数据，这种构建应用程序的方式传统上被称为 <strong>面向服务的体系结构（service-oriented architecture，SOA）</strong> ，也称之为 <strong>微服务架构</strong></p>
<p>REST是一个基于HTTP原则的设计哲学。它强调简单的数据格式，使用URL来标识资源，并使用HTTP功能进行缓存控制，身份验证和内容类型协商。与SOAP相比，REST已经越来越受欢迎，至少在跨组织服务集成的背景下【36】，并经常与微服务相关[31]。根据REST原则设计的API称为RESTful。</p>
<h3 id="B-RPC">B-RPC</h3>
<p>RPC是一种协议无关的通信方式，通常使用二进制协议（如Protobuf、Thrift）或文本协议（如XML-RPC、JSON-RPC）来传输数据。它允许客户端调用远程服务器上的函数，就像本地函数一样。RPC通常是无状态的，通常使用二进制格式以提高效率</p>
<p><strong>RESTful</strong>：RESTful是基于HTTP协议的通信方式，使用HTTP动词（GET、POST、PUT、DELETE等）来执行操作，并使用URL来定位资源。它使用标准的HTTP状态码来表示操作的结果。RESTful通常使用文本格式，如JSON或XML，以便数据可以被轻松解析和理解</p>
<p>RPC框架的主要重点在于同一组织拥有的服务之间的请求，通常在同一数据中心内</p>
<h1>第5章节-复制</h1>
<p>接下来是第5章的内容，这章节的内容主要是复制，所谓复制就是<strong>同一份数据保留多个副本</strong>。 复制数据的原因呢？</p>
<p>1️⃣ 使得数据与用户在地理上接近(减少延迟)</p>
<p>2️⃣ 即使系统的一部分出现故障，系统也能继续工作(提高可用性)</p>
<p>3️⃣ 扩展可以接受读请求的机器数量(提高读取吞吐量)</p>
<p>本章主要讨论三种变更<strong>复制算法</strong>（区别于复制方法/策略）：单主复制、多主复制、无主复制。当存在多个副本时，会不可避免的出现一个问题：如何确保所有数据都落在了所有的副本上？所以，复本机制真正的麻烦在于如何<strong>处理复制数据的变更</strong> 。我们来看一个非常普遍且常用解决方案：<strong>单主复制</strong></p>
<h2 id="单主复制">单主复制</h2>
<p>来具体看一个场景，更换新的用户头像的实例：</p>
<p align="center">
  <img src="/2023/09/21/ddia/34.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 单主复制 </span>
</p>
<p>总结一下单主复制符合以下的特点：</p>
<p>1️⃣ 多个副本中只有一个设置为leader,其他是flower</p>
<p>2️⃣ leader接受读请求和写请求，follower只接受读请求</p>
<p>3️⃣ follower从leader拉取日志，更新本地数据库副本</p>
<p>这种复制模式是很多关系型数据库内置的功能，比如PostgreSQL(9.0之后)，MySQL，SQL Server，文档型数据库 MongoDB。基于领导者的复制不局限于数据库，像一些高可用的分布式MQ也在用，比如Kafka、RabbitMQ</p>
<blockquote>
<p>关于主从和主备，主从中，“从”是向外提供服务的，而主备中的备不是对外提供的，备的作用是待“主”crash的时候成为主</p>
</blockquote>
<p>🎈🎈接下来呢，我们讨论复制系统的一个重要细节（复制策略）：复制是 <strong>同步(synchronously)</strong> 发生还是<strong>异步(asynchronously)</strong> 发生</p>
<h2 id="同步-异步">同步/异步</h2>
<p>如下图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/35.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 同步 &amp; 异步 </span>
</p>
<p>1️⃣ 用户 $id=1234$ 的用户向主库提交数据变更请求</p>
<p>2️⃣ 主库将数据变更同步给从库1（Follower1） ，并且等待从库1（Follower1）的响应，这里从库1（Follower1）复制的方式是同步</p>
<p>3️⃣ 主库将数据变更同步给从库2（Follower），但是不等待从库2（Follower2）的确认，这里从库2（Follower2）的复制方式是异步</p>
<p>整体的配置方式也被称作是半同步。我们来一起看下同步和异步复制的优劣势：</p>
<p>🅰️ 同步复制能够保证数据可靠性，但是如果从库迟迟不能响应主库，主库就不能接收新的读写请求</p>
<p>🅱️ 异步复制的优点是，即便从库落后了，主库也可以继续处理写入请求，劣势是无法保证数据一致性</p>
<p>我们再来看一下设置新从库的步骤：</p>
<p>1️⃣ 获取某个时刻主库的一致性快照</p>
<p>2️⃣ 将快照复制到从库节点</p>
<p>3️⃣ 从库连接主库，拉取快照之后发生的数据变更。拉取快照之后的变更，往往快照和主库复制日志关联，不同的数据库对于<em>这个关联关系</em>实现有着不同的名称：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>PostgreSQL 的叫做<strong>日志序列号(log sequence number, LSN)</strong></p>
</li>
<li class="lvl-2">
<p>MySQL将其称为 <strong>二进制日志坐标(binlog coordinates)</strong></p>
</li>
</ul>
<p>🎈🎈 从库失效的问题很好解决，从库在重新和主库建立连接之后，可以从日志知道最后一个失败的事务。然后开始追赶主库。如果主库失效了，该如何处理呢？</p>
<h2 id="处理故障节点">处理故障节点</h2>
<p><strong>主库失效如何处理？</strong></p>
<p>1️⃣ 确认主库失效</p>
<p>2️⃣ 选择一个新的主库，<strong><u>让所有的副本达成一致意见(共识<sub>consensus</sub>问题)</u></strong></p>
<p>3️⃣ 重新配置新的主库，并且启用新的主库</p>
<p>一些挑战：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果使用异步复制，发生的数据丢失问题，GitHub，MySQL从库切换为主库事故</p>
</li>
<li class="lvl-2">
<p>脑裂的情况，设置新的主库之后，老的主库又一次活过来了，可能会存在两个主库的情况，同时接受写入，可能会导致数据损坏，解决的方案可能是，发送<code>kill</code> comand 去干掉一个主库</p>
</li>
<li class="lvl-2">
<p>宣告主库死亡的阈值，主库在宣告死亡前，超时时间的设置，设置太长意味着恢复时间长，太短就会发生不必要的切换</p>
</li>
</ul>
<p><strong>基于主库的复制底层是如何工作的？</strong></p>
<p>1️⃣ 基于语句的复制，有非确定性函数、自增列的问题</p>
<p>2️⃣ 传输，预写式日志(WAL，Write Ahead Log)，日志包含所有数据库写入的仅追加字节序列，可以将其发给从库，比如说PostgreSQL 、Oracle。<strong>缺点是数据过于底层，WAL包含哪些磁盘块中的哪些字节发生了更改</strong>。这使复制与存储引擎紧密耦合，对数据库版本不友好，会对运维升级数据库造成困难</p>
<blockquote>
<p>MySQL数据库中有2种日志：redo log 和 binlog ，其中的redo log的实现方式即为WAL，先写日志，在罗盘</p>
</blockquote>
<p>3️⃣ 逻辑日志复制(基于行)，也即复制日志和存储引擎存储的日志采用不同的格式，这种复制日志被称为逻辑日志，逻辑日志有一下特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于插入的行，日志包含所有列的新值</p>
</li>
<li class="lvl-2">
<p>对于删除的行，日志包含足够的信息来唯一标识已删除的行。通常是主键，但是如果表上没有主键，则需要记录所有列的旧值</p>
</li>
<li class="lvl-2">
<p>对于更新的行，日志包含足够的信息来唯一标识更新的行，以及所有列的新值(至少所有已更改的列的新值)</p>
</li>
</ul>
<blockquote>
<p>逻辑日志，可使领导者和跟随者能够运行不同版本的数据库软件甚至不同的存储引擎。MySQL的binlog日志有三种格式，分别是statement、row、mixed，现通常使用row模式，即逻辑日志的形式，MySQL binlog 使用row模式就是当前描述的这种方式</p>
<p>模式下数据库的变更流可以应用在MySQL从库，或者Debezium/Cancel解析后推送至三方系统(消息代理Kafka、存储系统)</p>
</blockquote>
<p>4️⃣ 基于触发器的复制，触发器能够实现，在数据库系统中发生数据更改(写入事务)时，自动执行的自定义应用程序代码，不同于数据库系统实现的复制</p>
<h2 id="复制延迟问题">复制延迟问题</h2>
<h3 id="A-什么是最终一致性？">A-什么是最终一致性？</h3>
<p>从库有可能落后于主库，此时同一个查询打到主库和从库，会得到不一样的结果，这种不一致只是一个暂时的状态，如果停止写入数据库并等待一段时间，从库最终会赶上并与主库保持一致。这种效应被称为 <strong>最终一致性（eventually consistency）</strong></p>
<h3 id="B-什么是写后读一致性？">B-什么是写后读一致性？</h3>
<p>在异步复制策略中，用户向主提交了新数据，但是该用户的查询打到了从库，这种情况下，我们需要写后读一致性（read-after-write consistency），即：自己刚刚更新的内容，再去查询的时候，可以获取到更新</p>
<p>具体实现的方式有：</p>
<ol>
<li class="lvl-3">
<p>读用户<strong>可能已经修改过</strong>的内容时，都从主库读。一个简单的规则是：从主库读取用户自己的档案，在从库读取其他用户的档案</p>
</li>
<li class="lvl-3">
<p>客户端记住最近一次写入的时间戳（可以是逻辑时间戳），如果该时间戳已经传播到了从库，从从库读取没问题，否则从主库读</p>
</li>
</ol>
<p align="center">
  <img src="/2023/09/21/ddia/60.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 写后读一致性保证 &amp; 单调读一致性保证 </span>
</p>
<h3 id="C-什么是单调读？">C-什么是单调读？</h3>
<p>用户首先从新副本读取，然后从旧副本读取。时光倒流，我们需要单调读一致性</p>
<p>实现单调读取的一种方式是，确保每个用户总是从同一个副本进行读取（不同的用户可以从不同的副本读取）。例如，可以基于用户ID的散列来选择副本，而不是随机选择副本。但是，如果该副本失败，用户的查询将需要重新路由到另一个副本</p>
<h3 id="D-什么是一致前缀读？">D-什么是一致前缀读？</h3>
<p>如果某些分区的复制速度慢于其他分区，那么观察者在看到问题之前可能会看到答案，我们需要提供某种保证，如果一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现</p>
<p align="center">
  <img src="/2023/09/21/ddia/62.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 一致前缀度保证 </span>
</p>
<p>许多分布式数据库中，不同的分区独立运行，因此不存在<strong>全局写入顺序</strong>：当用户从数据库中读取数据时，可能会看到数据库的某些部分处于较旧的状态，而某些处于较新的状态。</p>
<p>一种解决方案是，确保任何因果相关的写入都写入相同的分区。对于某些无法高效完成这种操作的应用，还有一些显式跟踪因果依赖关系的算法，本书将在“一致性与共识”一节中再次聊聊这个问题</p>
<h2 id="多主复制的问题">多主复制的问题</h2>
<p>多领导者复制的最大问题是可能发生写冲突，这意味着需要 <strong>解决冲突</strong></p>
<p align="center">
  <img src="/2023/09/21/ddia/63.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 两个主库同时更新同一记录引起的写入冲突 </span>
</p>
<h2 id="无主复制">无主复制</h2>
<p>在无主复制，客户端的写入和读取，都请求到所有的副本，副本的写入有可能失败，有可能成功；读取时，选择按照法定人数（5个节点，3个节点返回数据相同）的数据回写到写入失败的节点。同时后台进程追踪节点之间的差异，趋势数据的收敛（因为有一些键没有读请求）</p>
<h3 id="A-什么是并发？">A-什么是并发？</h3>
<p>为了定义并发性，确切的时间并不重要：如果两个操作都意识不到对方的存在，就称这两个操作<strong>并发</strong></p>
<h1>第6章-分区</h1>
<p><strong>分区<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>是一种切分大数据集的方法，即一份数据切成多块</strong>，分区的目的是为了可扩展性，从而提高吞吐量。在实践中，分区通常和复制结合使用，每个分区的副本将处在多个节点上，以此获得容错能力。下图是主从复制模型下，分区和复制相结合的示意图：</p>
<blockquote></blockquote>
<p align="center">
  <img src="/2023/09/21/ddia/47.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 分区和复制的实例 </span>
</p>
<h2 id="键值数据的分区方式">键值数据的分区方式</h2>
<p>分区最核心的问题是</p>
<p>🅰️ 避免倾斜(skew)，即热点数据处理，放的角度</p>
<p>🅱️ 处理访问路由问题，即查询性能的保证，取的角度</p>
<p>下面我们介绍几种常见的分区方式：</p>
<p>1️⃣ 按照key的范围分区，这种方式天生可以解决访问路由的问题，对于热点数据，可根据数据状况进行拆分，Hbase,BigTable使用这种策略。在处理时间范围分区时，为避免一直写当前时间对应分区的 <strong>写入过载</strong> 问题，可引入其他列值+时间做分区</p>
<p align="center">
  <img src="/2023/09/21/ddia/48.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 按照范围分区，可以手动调整分区范围，使得分区尽量均衡</span>
</p>
<p>2️⃣ 散列<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>分区。散列分区可以很好的处理热点问题，弊端是查询能力无法保证，因为曾经相邻的密钥分散在所有分区中，这意味着如果执行范围查询，则该查询将被发送到所有分区中</p>
<p align="center">
  <img src="/2023/09/21/ddia/49.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 哈希的方式处理热点问题 </span>
</p>
改进的办法是多个列组成的复合主键，键中只有第一列会作为散列的依据，而其他列则被用作SSTables中排序数据的索引，此时如果第一列（如`user_id`）已经指定了固定值，则可以对该键的其他列（`timestamp`）执行有效的范围扫描。例如，在社交媒体网站上，一个用户可能会发布很多更新。若更新的主键被选择为`(user_id, update_timestamp)`，那么可以有效地检索，特定用户在某个时间间隔内按时间戳排序的所有更新。Casssandra使用了这种优化方式
<blockquote></blockquote>
<h2 id="分区和二级索引">分区和二级索引</h2>
<p>上文中我们讨论了 &lt;键值数据模型&gt; 的分区方案，次级索引是关系型数据库/文档型数据库的基础，也是<code>Solr</code>和<code>ElasticSearch</code>等搜索服务器的基石，次级索引由于不具备主键唯一的特性，导致我们并不能整齐的映射到各自的分区，有2种用二级索引对数据进行分区的方法：</p>
<p>🅰️ 基于文档的分区(docment-based)，如下图在汽车表/文档上建立颜色和厂商的次级索引，这种索引方法中，<strong>每个分区是完全独立，每个分区维护自己的次级索引</strong>，因此，文档分区索引也叫做本地索引(local index)。在执行特定的颜色的搜索(look for red)的时候，需要将查询发送到所有分区，并合并所有返回的结果。故，这种分区查询数据库的方式有时被称为<strong>分散/聚集(scatter/gather)</strong>，这种基于二级索引上的查询可能会相当昂贵</p>
<p align="center">
  <img src="/2023/09/21/ddia/50.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 基于文档的二级索引分区 </span>
</p>
<p>🅱️ 基于关键词(term-based)的分区，对所有分区的数据构建全局索引的同时，对全局索引进行分区。这种索引称为<strong>关键词分区(term-partitioned)</strong> <sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>，关键词分区的全局索引的优势在于不需要<strong>分散/收集</strong>所有分区，客户端只需要向包含关键词的分区发出请求。全局索引的缺点在于写入速度较慢且较为复杂，因为写入单个文档现在可能会影响索引的多个分区。在实践中，全局二级索引的更新通常是<strong>异步</strong>的</p>
<blockquote>
<p>(在任何时候)使用关键词本身进行分区适用于范围扫描，而对关键词的哈希分区提供更好的负载均衡能力</p>
</blockquote>
<p align="center">
  <img src="/2023/09/21/ddia/51.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 基于关键词的二级索引分区 </span>
</p>
<blockquote></blockquote>
<h2 id="分区再平衡">分区再平衡</h2>
<p>将负载(数据存储和读写请求)从集群中的一个节点，向另一个节点移动的过程称为<strong>再平衡(reblancing)</strong>，再平衡应该满足一下几个要求：</p>
<ol>
<li class="lvl-3">
<p>再平衡之后，负载(数据存储，读取和写入请求)应该，在集群中的节点之间公平地共享</p>
</li>
<li class="lvl-3">
<p>再平衡发生时，数据库应该继续接受读取和写入</p>
</li>
<li class="lvl-3">
<p>节点之间只移动必须的数据<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>，以便快速再平衡，并减少网络和磁盘I/O负载</p>
</li>
</ol>
<blockquote></blockquote>
<p>相应的，我们有三种分区方式，来进行处理</p>
<p>1️⃣ 固定数量的分区，创建比节点更多的分区，并为每个节点分配多个分区，如果一个节点被添加到集群中，新节点可以从当前每个节点中<strong>窃取</strong>一些分区，直到分区再次公平分配，如下图。Riak，Elasticsearch使用了这种再平衡的分区方式</p>
<p align="center">
  <img src="/2023/09/21/ddia/52.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 新节点从旧节点中窃取一些分区 </span>
</p>
<p>2️⃣ 动态分区，当分区增长到超过配置的大小时(在HBase上，默认值是10GB)，会被分成两个分区，每个分区约占一半的数据，反之进行合并，类似B树的页分裂/合并的过程</p>
<p>3️⃣ 分区数与节点数成正比，节点数量不变时，每个分区的大小与数据集大小成比例地增长，节点数增加时，分区数也增加，分区数据变少</p>
<h2 id="请求路由">请求路由</h2>
<p>数据集已经分割到多个机器上运行的多个节点上，那么当客户想要发出请求时，如何知道要连接哪个节点呢？即请求应该路由给谁？这个问题也可以概括为<strong>服务发现(service discovery)</strong>，有目前以下三种方案：</p>
<p>1️⃣ 允许客户联系任何节点(例如，通过<strong>循环策略的负载均衡(Round-Robin Load Balancer)</strong>)。如果该节点恰巧拥有请求的分区，则它可以直接处理该请求，否则，它将请求转发到适当的节点，接收回复并传递给客户端</p>
<p>2️⃣ 首先将所有来自客户端的请求发送到路由层，它决定了应该处理请求的节点，并相应地转发。此路由层本身不处理任何请求，它仅负责分区的负载均衡</p>
<p>3️⃣ 要求客户端知道分区和节点的分配。在这种情况下，客户端可以直接连接到适当的节点，而不需要任何中介</p>
<p align="center">
  <img src="/2023/09/21/ddia/53.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 客户端连接到分区的3种方式 </span>
</p>
<p>以上三种方式都会面临一个问题：作出路由决策的组件(节点之一/路由层/客户端)，如何了解分区-节点之间的分配关系变化？许多分布式数据系统都依赖于一个独立的协调服务(如ZooKeeper)来跟踪集群元数据，每个节点在ZooKeeper中注册自己，ZooKeeper维护分区到节点的可靠映射</p>
<p>其他参与者(如路由层或分区感知客户端)可以在ZooKeeper中订阅此信息。 只要分区分配发生的改变，或者集群中添加或删除了一个节点，ZooKeeper就会通知路由层使路由信息保持最新状态。HBase，SolrCloud和Kafka，使用ZooKeeper来跟踪分区分配</p>
<p>MongoDB具有类似的体系结构，但它依赖于自己的<strong>配置服务器（config server）</strong> 实现和mongos守护进程作为路由层</p>
<p align="center">
  <img src="/2023/09/21/ddia/56.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 路由层如何感知分区和节点之间的关系 </span>
</p>
<h1>第7章节-事务</h1>
<h2 id="事务的起源">事务的起源</h2>
<p>很早就接触事务这个概念，关于事务网上的文章动不动就把转账的的例子拿出来讲，坑的时候有的压根就没有讲明白，事务的概念<strong>事务要不就执行成功，要不执行失败，只有这2种状态</strong>也背的烂熟，也知道事务的4大特性ACID (原子性、一致性、隔离性、持久性)，但是这么些年从来没有思考过：为什么要有事务？他解决了什么样子的问题/痛点？那么我们带着这个问题来回顾一下事务起源：</p>
<p align="center">
  <img src="/2023/09/21/ddia/36.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 事务的起源 </span>
</p>
<p>上图中有一个名为猪小明的程序员，抱着电脑正在疯狂的写代码(开发应用程序)，其中应用程序需要透过网络在数据库中存放数据/获取数据，数据库软件依托于是操作系统，操作系统的底层是一些计算机硬件(存储介质/磁盘/缓存/Cache/RAM /ROM/CPU/主板等)。整个过程中，各个环节都有可能出错，比如：</p>
<p>1️⃣ 网络中断，客户端和应用程序服务之间，服务和数据库之间</p>
<p>2️⃣ 数据库软件本身挂掉了，硬件发生故障<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup></p>
<blockquote></blockquote>
<p>3️⃣ 应用程序在进行写入的时候，写到一半，自己崩溃了</p>
<p>4️⃣ 多个客户端同时操作数据库，覆盖彼此的更新</p>
<p>5️⃣ 客户写到一半的数据，被另外一个客户读取到</p>
<p>6️⃣ 客户之间的竞争导致的令人惊讶的错误</p>
<p>所有的这一些都需要应用程序的开发者，猪小明去解决，但是这个工作量是巨大的，应用开发应该专注于业务，而不是通用问题的处理，这些问题应该留给下层的数据库去处理。所以为了<strong>简化应用编程模型</strong> ，事务诞生了。通过使用事务，应用程序可以自由地忽略某些潜在的错误情况和并发问题，因为数据库会替应用处理好这些问题</p>
<p>1974年的时候，IBM的圣荷西研究中心发布了，第一款提供优秀的事务处理能力的关系型数据库R[seminal-project]。时至今日开发者已经习惯了事务，他们觉得事务是理所当然的，是天然就存在的，然而并不是，了解事务出现的历史，我们可以发现事务是我们的计算机先驱们为了解决一揽子问题，提供的一种解决方案</p>
<h2 id="ACID">ACID</h2>
<p>谈及事务，必谈事务的4大特性ACID；那么ACID 分别指的是什么？</p>
<p><em><strong>A</strong>tomicity</em> ： 原子性。<strong>能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力</strong>，可以理解为<strong>可终止性</strong>。假设没有原子性，如果有多次更改，但是更改发生过程中发生了错误，应用程序很难判断哪些更改生效了，哪些没有生效。如果有了原子性，应用程序可以确定的知道在发生错误时，所有更改没有生效。<strong>没有原子性，错误处理就会变的很复杂</strong></p>
<blockquote>
<p>区别于线程的原子操作：多线程中的原子操作描述的是，如果一个线程执行一个原子操作，意味着另外一个线程无法看到该原子操作的中间结果。而这个特性在ACID中是 <em>I(isolation)</em> 来描述的</p>
</blockquote>
<p><em><strong>C</strong>onsistency</em>：一致性。在事务中，一致性是指：<strong>对数据的一组特定陈述必须始终成立</strong>，即为<em>不变量</em>，如在会计系统中，所有账户整体上必须借贷相抵，转账过程中，加钱和减钱是相等的。原子性，隔离性和持久性是数据库的属性，而一致性(在ACID意义上)是应用程序的属性</p>
<blockquote>
<p>这是一个一词多意的词，用行话来说，这个词被重载了</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>有别于副本一致性，比如在单主复制的模式下，采用异步复制的方式，收敛最终一致</p>
</li>
<li class="lvl-2">
<p>还有大家有可能会听过一致性hash(一致性散列)那是一种为了避免重新分区带来的复杂度提高的一种解决方案</p>
</li>
<li class="lvl-2">
<p>CAP定理中，C指的是线性一致性</p>
</li>
</ul>
</blockquote>
<p><em><strong>I</strong>solation</em>：隔离性。<strong>竞争条件下，同时执行的事务是相互隔离的</strong>，下图是两个客户之间的竞争状态同时递增计数器的图述。<strong>缺乏隔离性，就会导致并发问题</strong></p>
<p align="center">
  <img src="/2023/09/21/ddia/02.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 两个客户之间的竞争状态同时递增计数器 </span>
</p>
<p><em><strong>D</strong>urability</em> ：持久性。持久性是事务的一个承诺，也即事务完成后，即便发生硬件故障或者数据库崩溃，写入的任务数据也不会丢失。持久性过去一般被认为写入了非易失性存储介质</p>
<h2 id="单对象操作和多对象操作">单对象操作和多对象操作</h2>
<p><strong>单一对象操作</strong>，所谓单对象操作中的对象，指的是数据库中被修改的对象，比如你正在向数据库写入一个20KB的Json文档，以下场景可能会发生：</p>
<p>1️⃣ 在发送第一个10KB之后，网络连接中断，数据库是否存储了不可解析的10KBJSON片段？</p>
<p>2️⃣ 在数据库正在覆盖的磁盘上前一个值的过程中电源发生故障，是否最终将新旧值拼接在一起？</p>
<p>3️⃣ 如果另一个客户端在写入过程中读取该文档，是否会看到部分更新？</p>
<p>这里的 JSON对象，就是单一对象，单一对象是相对于多对象而言的，待会我们会谈及到多对象。为了针对以上的问题，存储引擎会在单个对象上提供原子性和隔离性，如此一来：</p>
<p>🅰️ 原子性通过WAL(即redo-log)日志来实现崩溃恢复</p>
<p>🅱️ 使用每个对象的锁来实现隔离(每次仅仅允许一个线程访问对象)</p>
<p>除了单对象操作，还有就是CAS(Compare-and-set)，防止多个客户端同时写入同一个对象时的更新丢失，即当值没有并发被其他人修改的时候，才允许执行写入操作。CAS操作和单对象操作，被称作是轻量级事务。<strong>事务通常更多的强调 ： 将多个对象的多个操作合并为一个执行的单元的机制</strong></p>
<p><strong>何为多对象？</strong> 在操作数据库时，需要协调写入几个不同的对象：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>关系模型中，一个表中的行对另外一个表的外键引用。你得确保外键是最新的，可用的</p>
</li>
<li class="lvl-2">
<p>在字段冗余的场景中，单个字段在多处被存储，你得保证这几处是同步的</p>
</li>
<li class="lvl-2">
<p>二级索引的数据库中，数据更新的时候，二级索引也需要更新</p>
</li>
</ul>
<p>在这种情形下，需要使用事务来进行处理</p>
<p>接下来我们会讲述隔离级别，在讲述隔离级别之前，明确两点：</p>
<p>🅰️ 隔离级别是对事务的4大特性之一隔离性上进行了一个等级划分，数据库标准的事务隔离级别包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>读未提交(read uncommitted)</p>
</li>
<li class="lvl-2">
<p>读已提交(read committed)</p>
</li>
<li class="lvl-2">
<p>可重复读/快照隔离(repeatable read)</p>
</li>
<li class="lvl-2">
<p>串行化(serializable)</p>
</li>
</ul>
<p>🅱️ 隔离级别最高是可序列化，表示同一时间只能有一个事务。隔离级别和性能之间是一个负相关的关系，也就是说隔离级别越高，数据一致性的保证越好，但是性能越差。隔离级别是数据一致性和服务性能的一场博弈。为了实现更优的性能，我们需要较弱的隔离级别</p>
<p>下面介绍这些弱隔离级别</p>
<h2 id="读已提交">读已提交</h2>
<p>最基本的弱隔离级别是，读已提交，它提供了两个保证：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>没有<strong>脏读(dirty reads)</strong>，从数据库读时，只能看到已提交的数据</p>
</li>
<li class="lvl-2">
<p>没有<strong>脏写(dirty writes)</strong>，写入数据库时，只会覆盖已经写入的数据</p>
</li>
</ul>
<p>另外读未提交：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以防止脏写</p>
</li>
<li class="lvl-2">
<p>但是不能够防止脏读</p>
</li>
</ul>
<p>下图是一个没有脏读的例子：可以看到<em>直到用户1提交了之后</em>，用户2才看到提交之后的值x=3,而在这之前用户1只能看到x=2</p>
<p align="center">
  <img src="/2023/09/21/ddia/03.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 用户2只有在用户1的事务已经提交后才能看到x的新值 </span>
</p>
<p>那么为什么要防止脏读呢？主要是下面两个原因：</p>
<p>1️⃣ 如果事务需要更新多个对象，脏读取意味着另一个事务可能会只看到一部分更新。比如说下面这个电子邮件的例子。事务还没有提交，但是用户2看到了未读邮件，可是未读邮件的数量却还是旧值</p>
<p align="center">
  <img src="/2023/09/21/ddia/04.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 一个事务读取另一个事务的未被执行的写入（“脏读”） </span>
</p>
<p>2️⃣ 若数据库允许脏读，意味着一个事务可能会看到稍后需要回滚的数据，即从未实际提交给数据库的数据。比如下面的例子中读到了未提交的数据，但是后面事务回滚了</p>
<p align="center">
  <img src="/2023/09/21/ddia/05.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 原子性确保发生错误时，事务先前的任何写入都会被撤消，以避免状态不一致 </span>
</p>
<p>两个事务同时更新数据库中的对象，先前的写入没有提交，后面的写入覆盖这个尚未提交的值，这就是脏写。没有脏写，意味着在写入数据库时，只会覆盖已经写入的数据。在<strong>读已提交</strong>的隔离级别上运行的事务必须防止脏写，通常是延迟第二次写入，直到第一次写入事务提交或中止为止。下图是脏写发生的示例，发票属于Alice; 销售属于Bob’</p>
<p align="center">
  <img src="/2023/09/21/ddia/06.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 如果存在脏写，来自不同事务的冲突写入可能会混淆在一起 </span>
</p>
<h2 id="实现读已提交">实现读已提交</h2>
<p>读已提交是一种非常Fashion的一个隔离级别，有很多数据库软件将读已提交设置为默认的隔离级别，比如Oracle 11、PostgreSQL、SQLServer 2012 ，那么如何实现</p>
<p>1️⃣ 无脏写保证：数据库通过使用 <strong>行锁(row-level lock)<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup></strong> 来防止脏写；即当事务想要修改特定对象时，必须获取该对象的锁，然后必须持有该锁，直到事务被提交或终止。这种锁定是读已提交模式（或更强的隔离级别）的数据库自动完成的</p>
<blockquote></blockquote>
<p>2️⃣ 无脏读保证：MVCC<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup> ，数据库都会记住旧的已提交值，和当前持有写入锁的事务设置的新值。 当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值</p>
<blockquote>
<p align="center">
  <img src="/2023/09/21/ddia/07.png" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 一个值从1按顺序修改为4的过程。在读已提交的隔离级别下，仅仅保留为提交版本和提交前版本2个版本 </span>
</p>
</blockquote>
<p>读已提交的隔离级别无法避免<em>不可重复读</em>的情况，下面的例子：爱丽丝在银行有1000美元的储蓄，两个账户，每个500美元；现在一个事务从她的一个账户中，转移了100美元到另一个账户</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Alice在转账事务之前查询了账户1的金额为500元</p>
</li>
<li class="lvl-2">
<p>Alice在转账之后完成之后，查询了账户2的金额为400元</p>
</li>
<li class="lvl-2">
<p>此时账户的总额为900元，Alice就很疑惑为什么自己的钱少了？</p>
</li>
</ul>
<p align="center">
  <img src="/2023/09/21/ddia/07.jpg" width="75%" alt="Your image description">
    <br>
  <span style="color:gray">读取偏差：Alice观察数据库处于不一致的状态 </span>
</p> 
<p>这种，这种异常被称为<strong>不可重复读(nonrepeatable read)</strong>，如果Alice在事务结束时再次读取账户1的余额，她将看到与她之前的查询中看到的不同的值(600美元)。在读已提交的隔离条件下，<strong>不可重复读</strong>可能会发生</p>
<h2 id="实现快照隔离">实现快照隔离</h2>
<p>快照隔离的另外一个叫法是可重复读，快照隔离和读已提交一致，使用写锁来防止脏写，也就是正在进行写入的事务会阻止另外一个事务修改同一个对象。读取没有任何的锁定，<strong>写不阻塞读，读不阻塞写</strong>，RC下也是，数据库使用<strong>多版本并发控制(MVCC, multi-version concurrentcy control)</strong> 数据库保留一个对象的几个不同的提交版本。另外使用MVCC实现快照隔离的存储引擎通常也会使用MVCC来实现读已提交(一个对象的两个版本：提交的版本和被覆盖但尚未提交的版本)</p>
<p align="center">
  <img src="/2023/09/21/ddia/08.jpg" width="75%" alt="Your image description">
    <br>
  <span style="color:gray">  使用多版本对象实现快照隔离 </span>
</p>
<p>那么我们再来看一下<em>一致性快照的可见性规则</em>：也就是说当一个事务从数据库中读取时，事务ID用于决定它可以看见哪些对象，看不见哪些对象。规则如下：</p>
<p>1️⃣ 在每次事务开始时，数据库列出当时所有其他(尚未提交或中止)的事务清单，即使之后提交了，这些事务的写入也都会被忽略</p>
<p>2️⃣ 被中止事务所执行的任何写入都将被忽略</p>
<p>3️⃣ 由具有较晚事务ID(即，在当前事务开始之后开始的)的事务所做的任何写入都被忽略，而不管这些事务是否已经提交</p>
<p>4️⃣ 所有其他写入，对应用都是可见的</p>
<p>更简单的讲，对于隔离级别的实现数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准</p>
<p>1️⃣ “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念</p>
<p>2️⃣ 在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的</p>
<p>3️⃣ 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图</p>
<p>4️⃣ “串行化”隔离级别下直接用加锁的方式来避免并行访问</p>
<h2 id="丢失更新">丢失更新</h2>
<p>前面描述的是读-写并发场景下，只读事务在并发写入时候能看到什么，另外一个问题是两个事务并发写入的问题，即写-写冲突。如下图就是<strong>丢失更新</strong>的例子</p>
<p align="center">
  <img src="/2023/09/21/ddia/02.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 丢失更新：两个客户之间的竞争状态同时递增计数器 </span>
</p>
<p>解决写-写冲突有很多方式，比如原子写（数据库提供），显示锁定，比较并设置(CAS)</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据库提供原子更新操作，消除在应用程序代码中执行读取-修改-写入序列的需要</span></span><br><span class="line"><span class="keyword">update</span> counters <span class="keyword">set</span> <span class="keyword">value</span> <span class="operator">=</span> <span class="keyword">value</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">where</span> key <span class="operator">=</span> <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示锁定</span></span><br><span class="line"><span class="keyword">begin</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> figures</span><br><span class="line">    <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">'robot'</span> <span class="keyword">and</span> game_id <span class="operator">=</span> <span class="number">222</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- `for update` 子句告诉数据库应该对该查询返回的所有行加锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查玩家的操作是否有效，然后更新先前select返回棋子的位置</span></span><br><span class="line"><span class="keyword">update</span> figures <span class="keyword">set</span> position <span class="operator">=</span> <span class="string">'c4'</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置(CAS)</span></span><br><span class="line"><span class="keyword">update</span> wiki_pages <span class="keyword">set</span> content <span class="operator">=</span> <span class="string">'新内容'</span></span><br><span class="line">  <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1234</span> <span class="keyword">and</span> content <span class="operator">=</span> <span class="string">'旧内容'</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>在MySQL中，使用当前读<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>的方式来处理写-写冲突，下图为RR隔离级别下，写-写冲突的例子</p>
<blockquote></blockquote>
<p align="center">
  <img src="/2023/09/21/ddia/10.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray">  </span>
</p>
<h2 id="写偏差">写偏差</h2>
<p>如果两个事务读取相同的对象，然后不同的事务可能更新不同的对象，则可能发生写偏差(写偏差包含丢失更新)</p>
<p>下面是写偏差的例子，描述的是一个医生轮班管理程序，医院有以下的要求：至少有一位医生在待命，现在Alice 和 Bob 两位值班医生都感觉到不适，决定请假：</p>
<p align="center">
  <img src="/2023/09/21/ddia/09.jpg" width="75%" alt="Your image description">
    <br>
  <span style="color:gray"> 写入偏差导致应用程序错误的示例 </span>
</p>
<p>在多个事务更新同一个对象的特殊情况下，就会发生脏写或丢失更新(取决于时机) <strong>防止写偏差，需要使用序列化隔离级别</strong></p>
<h2 id="幻读">幻读</h2>
<p><strong>一个事务中的写入改变另一个事务的搜索查询的结果，称为幻读</strong></p>
<p>下图是一个幻读的例子：</p>
<blockquote>
<p>幻读会导致写偏差。快照隔离避免了只读事务中的幻读，但是无法避免读写事务中的幻读。从上面的例子来看，幻读的问题貌似是没有对象可以加锁。人为的引入锁对象的方式被称之为<em>物化冲突</em></p>
</blockquote>
<p align="center">
  <img src="/2023/09/21/ddia/11.jpg" width="75%" alt="Your image description">
    <br>
  <span style="color:gray"> 干扰事务 干扰 主事务的执行 </span>
</p>
<p>🅰️ 主事务，检测表中是否有<code>id=1</code>的记录，没有则插入（<code>for update</code> 没有用，因为没有加锁对象），这是我们期望的正常业务逻辑</p>
<p>🅱️ 干扰事务，目的在于扰乱，主事务的正常的事务执行</p>
<p>我们看到，干扰事务率先执行了，主事务发生了幻读，因为主事务读取的状态并不能支持它的下一步逻辑，感觉看到了幻影。上例中是干扰事务妨碍了主事务搜索结果。在MySQL中，使用间隙锁（下文会涉及到）来处理幻读问题。<em>不可重复读侧重表达读-读，幻读则是说读-写，用写来证实读的是鬼影</em></p>
<h2 id="序列化-串行化">序列化/串行化</h2>
<p>对串行化的理解应当是这样的：一次只执行一个事务。设计单线程的系统有时候比支持并发的系统更好，因为它可以避免协调锁的开销。数据库的早期，数据库意图包含整个用户的活动流程，但是如今的web应用，一个事务不会跨越多个请求，事务会在同一个HTTP请求被提交</p>
<h3 id="两阶段锁定-2PL">两阶段锁定-2PL</h3>
<p>30年以来，数据库中只有一种广泛使用的序列化算法：<strong>两阶段锁定(2PL，two-phase locking)</strong>。两阶段这个名字的来源：第1阶段（当事务正在执行时）获取锁，第2阶段(在事务结束时)释放所有的锁</p>
<p>2PL要求只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入(修改或删除)，就需要<strong>独占访问(exclusive access)</strong> 权限。锁可以处于<em>共享模式</em>，可以处于<em>独占模式</em>：</p>
<p>1️⃣ 若事务要读取对象，则须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务已经在对象上持有排它锁，则这些事务必须等待</p>
<p>2️⃣ 若事务要写入一个对象，它必须首先以独占模式获取该锁。没有其他事务可以同时持有锁(无论是共享模式还是独占模式)，所以如果对象上存在任何锁，该事务必须等待</p>
<p>3️⃣ 如果事务先读取再写入对象，则它可能会将其共享锁升级为独占锁。升级锁的工作与直接获得排他锁相同</p>
<p>4️⃣ 事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）</p>
<p>由于加了这么多的锁，可能会发生死锁情况，死锁及死锁检测的内容可以看看MySQL的笔记</p>
<p>在Java中有这么一个定律：对象（Object）就是锁，前面内容涉及到的锁都是针对特定对象的(如表中的一行)，对于某些更改没有特定对象，有没有一种锁针对这种场景呢？</p>
<h3 id="谓词锁">谓词锁</h3>
<p>谓词锁类似于共享/排它锁，但不属于特定的对象（例如，表中的一行），它属于所有符合某些搜索条件的对象，如：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bookings</span><br><span class="line"><span class="keyword">where</span> room_id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">and</span></span><br><span class="line">      end_time <span class="operator">&gt;</span> <span class="string">'2018-01-01 12:00'</span> <span class="keyword">and</span> </span><br><span class="line">      start_time <span class="operator">&lt;</span> <span class="string">'2018-01-01 13:00'</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>谓词锁限制访问：</p>
<p>🅰️ 如果事务A想要，<strong>读取</strong>匹配某些条件的对象，就像在这个 <code>select</code> 查询中那样，它必须获取查询条件上的<strong>共享谓词锁(shared-mode predicate lock)</strong>。如果另一个事务B，持有任何满足这一查询条件对象的排它锁，事务A必须等到B释放它的锁之后才允许进行查询</p>
<p>🅱️ 如果事务A想要，<strong>插入，更新或删除</strong>任何对象，则必须首先检查旧值或新值，是否与任何现有的谓词锁匹配。如果事务B持有匹配的谓词锁，那么A必须等到B已经提交或中止后才能继续</p>
<p>谓词锁的关键思想是，<strong>谓词锁甚至适用于数据库中尚不存在，但将来可能会添加的对象（幻象）</strong>。和快照隔离的区别在是：快照隔离中读不阻塞写，写不阻塞读；2PL中，写阻塞读，读阻塞写</p>
<h3 id="索引范围锁">索引范围锁</h3>
<p>索引范围锁，也称为<strong>间隙锁(next-key locking)</strong></p>
<p>谓词锁的弊端是性能不佳：<strong>如果活跃事务持有很多锁，检查匹配的锁会非常耗时</strong>。因此，大多数使用2PL的数据库实际上实现了索引范围锁，间隙锁是一种简化的近似版谓词锁</p>
<p>比如在房间预订数据库中，您可能会在<code>room_id</code>列上有一个索引，并且/或者在<code>start_time</code> 和 <code>end_time</code>上有索引（否则前面的查询在大型数据库上的速度会非常慢</p>
<p>🅰️ 假设您的索引位于<code>room_id</code>上，并且数据库使用此索引查找<code>123</code>号房间的现有预订。现在数据库可以简单地将共享锁附加到这个索引项上，指示事务已搜索<code>123</code>号房间用于预订</p>
<p>🅱️ 或者，如果数据库使用基于时间的索引来查找现有预订，那么它可以将共享锁附加到该索引中的一系列值，指示事务已经将<code>12:00~13:00</code> 时间段标记为用于预定</p>
<p>无论哪种方式，搜索条件的近似值都附加到其中一个索引上。现在，如果另一个事务想要插入，更新或删除同一个房间和/或重叠时间段的预订，则它将不得不更新索引的相同部分。在这样做的过程中，它会遇到共享锁，它将被迫等到锁被释放。这种方法能够有效防止幻读和写入偏差</p>
<h2 id="序列化快照隔离（SSI）">序列化快照隔离（SSI）</h2>
<p><strong>可序列化快照隔离(SSI, serializable snapshot isolation)</strong> 它提供了完整的可序列化隔离级别，但与快照隔离相比只有只有很小的性能损失，是一种新的隔离技术</p>
<h2 id="总结-2">总结</h2>
<p>1️⃣ 脏读: 一个客户端读取到另一个客户端尚未提交的写入。<strong>读已提交</strong>或更强的隔离级别可以防止脏读</p>
<p>2️⃣ 脏写: 一个客户端覆盖写入了另一个客户端尚未提交的写入。几乎所有的事务实现都可以防止脏写</p>
<p>3️⃣ 读取偏差(不可重复读): 在同一个事务中，客户端在不同的时间点会看见数据库的不同状态。<strong>快照隔离</strong>经常用于解决这个问题，它允许事务，从一个特定时间点的一致性快照中读取数据。快照隔离通常使用<strong>多版本并发控制(MVCC)</strong> 来实现</p>
<p>4️⃣ 更新丢失: 两个客户端同时执行<strong>读取-修改-写入序列</strong>。其中一个写操作，在没有合并另一个写入变更情况下，直接覆盖了另一个写操作的结果。所以导致数据丢失。快照隔离的一些实现可以自动防止这种异常，而另一些实现则需要手动锁定(<code>select for update</code>)</p>
<blockquote>
<p>和脏写的区别在于：脏写是覆盖尚未提交的写入，更新丢失是覆盖了一个已提交的写入</p>
</blockquote>
<p>5️⃣ 写偏差: 一个事务读取一些东西，根据它所看到的值作出决定，并将决定写入数据库。但是，写的时候，决定的前提不再是真实的。只有可序列化的隔离才能防止这种异常</p>
<p>6️⃣ 幻读 : 事务读取符合某些搜索条件的对象，另一个客户端进行写入，影响搜索结果。快照隔离可以防止直接的幻像读取，但是写入歪斜环境中的幻读需要特殊处理，例如索引范围锁定。只有可序列化的隔离才能防范所有这些问题。我们讨论了实现可序列化事务的三种不同方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>字面意义上的串行执行: 如果每个事务的执行速度非常快，并且事务吞吐量足够低，足以在单个CPU核上处理，这是一个简单而有效的选择</p>
</li>
<li class="lvl-2">
<p>两阶段锁定: 数十年来，两阶段锁定一直是实现可序列化的标准方式，但是许多应用出于性能问题的考虑避免使用它</p>
</li>
<li class="lvl-2">
<p><strong>可串行化快照隔离(SSI)</strong></p>
</li>
</ul>
<h1>第9章节-一致性与共识</h1>
<p>构建容错系统的最好方法，是找到一些带有实用保证的通用抽象，实现一次，然后让应用依赖这些保证。比如通过使用<strong>事务</strong>这个抽象，应用可以假装没有崩溃(原子性)，没有其他人同时访问数据库(隔离性)，存储设备是完全可靠的(持久性)。即使发生崩溃，竞态条件和磁盘故障，事务抽象隐藏了这些问题，因此应用不必担心它们</p>
<p>同样的分布式系统最重要的抽象之一就是<strong>共识(consensus)</strong>：<strong>其非正式定义是让所有的节点对某件事达成一致</strong></p>
<blockquote>
<p>分布式一致性模型和事务的特性ACID中的一致性 ，隔离级别的区别❓</p>
<p>ACID一致性的概念是，<strong>对数据的一组特定陈述必须始终成立</strong>。即<strong>不变量(invariants)</strong></p>
<p>分布式一致性主要是关于：面对延迟和故障时，如何协调副本间的状态</p>
<p>事务隔离的目的是为了，避免由于同时执行事务而导致的竞争状态</p>
</blockquote>
<h2 id="线性一致性">线性一致性</h2>
<p>多数的数据库提供了最终一致性的保证(数据是最终收敛的)。最终一致性的问题是：如果你在同一个时刻问2个副本同样一个问题，可能得到不同的答案，<strong>线性一致性</strong>尝试提供只有一个副本的假象，即提供新鲜度保证(一个客户端完成写操作，所有client可以必须能看到最新的答案)</p>
<blockquote>
<p>线性一致性和可序列化的区别❓</p>
<p>可序列化是事务的隔离性，它确保事务的执行是特定的顺序</p>
<p>线性一致性是读取和写入寄存器(单个对象)的新鲜度保证，它不会将多个操作组合为事务</p>
<p>一个数据库可以提供可串行性和线性一致性，这种组合称之为，单副本强可串行性(strong-1SR)，基于2阶段锁的可串行化实现，通常是线性一致的，可重复读不是线性一致的</p>
</blockquote>
<h3 id="线性一致性的作用">线性一致性的作用</h3>
<p>🅰️ 单主复制的系统中，领导选取(只有一个节点持有锁)</p>
<p>🅱️ 唯一性约束(只有一个对象持有该id)</p>
<h3 id="实现线性一致的系统">实现线性一致的系统</h3>
<p>1️⃣ 单主复制：可能线性一致</p>
<p>2️⃣ 共识算法：线性一致</p>
<p>3️⃣ 多主复制：非线性一致</p>
<h2 id="CAP">CAP</h2>
<p>有一种说法是： 一致性、可用性、分区容错性，三者只能选择其二，这种说法有一定的误导性。这里的<em>P</em>指的是网络分区<sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>，网络分区是一种故障，是一定会(概率事件)存在的，P不是一个可选项而是一个必选项，那么就有了</p>
<p>🅰️ CP : 在网络分区下一致但不可用 。若应用需要线性一致性，某些副本和其他副本断开连接，那么这些副本掉线时不能处理请求(单主复制+同步)，请求必须等到网络问题解决，或直接返回错误。无论哪种方式，服务都<strong>不可用(unavailable)</strong></p>
<p>🅱️ AP : 在网络分区下可用但不一致 。应用不需要线性一致性，那么某个副本即使与其他副本断开连接，也可以独立处理请求（例如多主复制）。在这种情况下，应用可以在网络问题前保持可用，但其行为不是线性一致的</p>
<blockquote></blockquote>
<h2 id="全序-vs-偏序">全序 vs 偏序</h2>
<h3 id="因果顺序不是全序的">因果顺序不是全序的</h3>
<p>自然数集是全序的，如1,2,3；数学集合是偏序的，比如<code>{a,b}</code>  和 <code>{b,c}</code> 是没有办法比较大小的。线性一致是全序的，不存在任何并发，所有的操作在一条时间线上。而因果关系是偏序的，存在着并发，线性一致性强于因果一致性，但是性能不如因果一致性</p>
<h3 id="序列号顺序">序列号顺序</h3>
<p>显示跟踪所有已读数据确保因果关系意味着巨大的额外开销，可以使用序列号或时间戳来排序事件，时间戳并不一定来自时钟，可以是一个逻辑时钟(自增计数器)，单主复制的数据库中，主库为每个操作自增一个计数器，从库按照复制日志的顺序来应用写操作，那么从库的状态始终是因果一致的</p>
<h3 id="非因果序列号生成器">非因果序列号生成器</h3>
<p>对于无主复制或者多主复制，如何生成序列号呢？有下面三种方式：</p>
<p>1️⃣ 每个节点生成自己独立的一组序列号，如有2个节点，一个奇数一个偶数</p>
<p>2️⃣ 将物理时钟附加到每个操作上，也许可以提供一个全序关系</p>
<p>3️⃣ 预先分配序列区块号，如节点A是1-1000区块的所有权；节点B是1001-2000区块的所有权</p>
<p>三种共同的问题是：生成的序列号与因果关系不一致。兰伯特时间戳可以产生与因果关系一致的时间戳</p>
<h3 id="兰伯特时间戳">兰伯特时间戳</h3>
<p>(计数器，节点ID)$(counter, node ID)$ 组成<em>兰伯特</em>时间戳，每个节点和每个客户端跟踪迄今为止所见到的最大<strong>计数器</strong>值，并在每个请求中包含这个最大计数器值。当一个节点收到最大计数器值大于自身计数器值的请求或响应时，它立即将自己的计数器设置为这个最大值。下面2条规则去判断：</p>
<p>🅰️ 如果你有两个时间戳，则<strong>计数器</strong>值大者是更大的时间戳</p>
<p>🅱️  如果计数器值相同，则节点ID越大的，时间戳越大</p>
<p align="center">
  <img src="/2023/09/21/ddia/12.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>其中客户端 A 从节点2 接收计数器值 <code>5</code> ，然后将最大值 <code>5</code> 发送到节点1 。此时，节点1 的计数器仅为 <code>1</code> ，但是它立即前移至 <code>5</code> ，所以下一个操作的计数器的值为 <code>6</code> 。虽然兰伯特时间戳定义了一个与因果一致的全序，但它还不足以解决分布式系统中的许多常见问题，比如确保用户名能唯一标识用户帐户的系统，你得搜集所有相同用户名的兰伯特时间戳，才能比较他们的时间戳，节点无法马上决定当前请求失败还是成功。所以仅知道全序是不够的，还需要知道全序何时结束</p>
<h2 id="全序广播-原子广播">全序广播(原子广播)</h2>
<p>全序广播通常被描述为在节点间交换消息的协议。 非正式地讲，它要满足两个安全属性：</p>
<p>1️⃣ 可靠交付（reliable delivery）:  没有消息丢失：如果消息被传递到一个节点，它将被传递到所有节点</p>
<p>2️⃣ 全序交付（totally ordered delivery）:  消息以相同的顺序传递给每个节点</p>
<p>正确的全序广播算法必须始终保证可靠性和有序性，即使节点或网络出现故障。当然在网络中断的时候，消息是传不出去的，但是算法可以不断重试，以便在网络最终修复时，消息能及时通过并送达</p>
<p>可以使用全序广播来实现可序列化的事务，由于具备上述2个安全属性，数据库的分区和副本就可以相互保持一致。<em>节点得到了共识</em></p>
<blockquote>
<p>🅰️ <strong>全序广播等于共识</strong></p>
<p>🅱️ <strong>线性一致的CAS等于共识</strong></p>
</blockquote>
<h2 id="分布式事务与共识">分布式事务与共识</h2>
<p>共识的目标只是<strong>让几个节点达成一致(get serveral nodes to agree on something)</strong>。节点达成一致(共识)的应用场景：</p>
<p>🅰️ 领导选取：如在单主复制中，如果有2个以上领导就会有发生脑裂情况，脑裂时2主都会接收写入，导致数据不一致或数据丢失</p>
<p>🅱️ 原子提交：在跨多节点或跨多分区事务的数据库中，所有节点必须就：<em>一个事务是否成功</em>这件事达成一致(要不都成功；要不都失败)</p>
<p>2PC是一个最简单的共识算法，更好的一致性算法比如ZooKeeper(Zab)和etcd(Raft)中使用的算法</p>
<blockquote>
<p>区分普通事务和两种的不同的分布式事务</p>
<p>0️⃣ 普通事务是相对单个节点而言的多对象操作；而分布式事务涉及多个节点</p>
<p>1️⃣ 数据库内部的分布式事务， 一些分布式数据库(即在其标准配置中使用复制和分区的数据库)支持数据库节点之间的内部事务，比如MySQL Cluster的NDB存储引擎就有这样的内部事务支持。此情形下，所有参与事务的节点都运行相同的软件</p>
<p>2️⃣ 异构分布式事务：在异构事务中，参与者是2者或者以上的技术，比如来自不同供应商的2个数据库/消息代理，跨系统的分布式事务需要保证原子提交</p>
</blockquote>
<h2 id="原子提交和2PC">原子提交和2PC</h2>
<p>对于多对象事务及维护次级索引的数据库，原子提交可以防止失败的事务搅乱数据库，避免数据库陷入半成品结果和半更新状态；对于单对象的原子性一般时都由数据库(存储引擎)本身保证。 <strong>两阶段提交(two-phase commit)</strong> 是一种用于实现跨多个节点的原子事务提交的算法，即确保所有节点提交或所有节点中止</p>
<p align="center">
  <img src="/2023/09/21/ddia/13.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>2PC使用一个通常不会出现在单节点事务中的新组件：<strong>协调者(coordinator)</strong>（也称为<strong>事务管理器(transaction manager)</strong>）。2PC事务以应用在多个数据库节点(<strong>参与者(participants)</strong>)上读写数据开始。当应用准备提交时，协调者开始阶段1：它发送一个 <strong>准备(prepare)</strong> 请求到每个节点，询问它们是否能够提交，然后协调者会跟踪参与者的响应：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果所有参与者都回答“是”，表示它们已经准备好提交，那么协调者在阶段2发出 <strong>提交(commit)</strong> 请求，然后提交真正发生</p>
</li>
<li class="lvl-2">
<p>如果任意一个参与者回复了“否”，则协调者在阶段2 中向所有节点发送 <strong>中止(abort)</strong> 请求</p>
</li>
</ul>
<p>2PC具体的流程如下：</p>
<p>1️⃣ 当应用想要启动一个分布式事务时，它向协调者请求一个事务ID。此事务ID是全局唯一的</p>
<p>2️⃣ 应用在每个参与者上启动单节点事务，并在单节点事务上捎带上这个全局事务ID</p>
<p>3️⃣ 当应用准备提交时，协调者向所有参与者发送一个<strong>准备</strong>请求，并打上全局事务ID的标记。如果任意一个请求失败或超时，则协调者向所有参与者发送针对该事务ID的中止请求</p>
<p>4️⃣ 参与者收到准备请求时，需要确保在任意情况下都可以提交事务。这包括将所有事务数据写入磁盘(出现故障，电源故障，或硬盘空间不足都不能是稍后拒绝提交的理由)以及检查是否存在任何冲突或违反约束。通过向协调者回答“是”，节点承诺，只要请求，这个事务一定可以不出差错地提交。换句话说，<em>参与者放弃了中止事务的权利，但没有实际提交</em></p>
<p>5️⃣ 当协调者收到所有准备请求的答复时，会就提交或中止事务作出明确的决定(只有在所有参与者投赞成票的情况下才会提交)。协调者必须把这个决定写到磁盘上的事务日志中，如果它随后就崩溃，恢复后也能知道自己所做的决定。这被称为<strong>提交点(commit point)</strong></p>
<p>6️⃣一旦协调者的决定落盘，提交或放弃请求会发送给所有参与者。如果这个请求失败或超时，协调者必须永远保持重试，直到成功为止。没有回头路：如果已经做出决定，不管需要多少次重试它都必须被执行。如果参与者在此期间崩溃，事务将在其恢复后提交——由于参与者投了赞成，因此恢复后它不能拒绝提交</p>
<p>下图是MySQL的两阶段提交过程，该过程保证bin-log和redo-log一致</p>
<p align="center">
  <img src="/2023/09/21/ddia/03.png" width="55%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<h2 id="协调者失效">协调者失效</h2>
<p>上述第3️⃣步中很协调者发送“准备”请求之前失败，参与者可以安全的终止事务；在第5️⃣ 步中如果任何提交和终止请求失败，协调者将无条件重试，但是协调者崩溃，参与者就什么也做不了只能等待。参与者的这这种事务状态称为：<strong>存疑或者不确定</strong></p>
<p align="center">
  <img src="/2023/09/21/ddia/14.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>上图中：协调者实际上决定提交，数据库2收到提交请求，但是协调者在将提交请求发送到数据库1之前发生崩溃，因此数据库1不知道是否提交或中止。这里即便<strong>超时</strong>， 也是没用的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果数据库1 在超时后单方面中止，它将最终与执行提交的数据库2 不一致</p>
</li>
<li class="lvl-2">
<p>单方面提交也是不安全的，因为另一个参与者可能已经中止了</p>
</li>
</ul>
<p>此时完成2PC的唯一方法是等待协调者恢复，因此，协调者必须在<em>向</em>参与者发送提交/中止请求之前，将其提交/中止决定写入磁盘上的事务日志，协调者恢复后，通过读取其事务日志来确定所有存疑事务的状态，任何在协调者日志中没有提交记录的事务都会中止</p>
<h2 id="恰好一次的消息处理">恰好一次的消息处理</h2>
<p>异构的分布式事务能够集成两种不同的系统，比如当用于处理消息的数据库事务成功提交后，消息队列中的一条消息可以被认为已处理。如果消息或者数据库事务任意一个失败，2者都会终止，而消息代理可能会在稍后安全的重传消息。通过这种方式，可以确保消息被有效地恰好处理一次</p>
<h2 id="XA事务">XA事务</h2>
<p>扩展架构(eXtended Architecture)是跨异构技术实现两阶段提交的标准。许多关系型数据库(PostgresSQL、MySQL、SQL Server、Oracle))和消息代理(ActiveMQ，HornetQ，MSMQ和IBM MQ)都支持XA</p>
<h2 id="容错共识">容错共识</h2>
<blockquote>
<p>共识的定义：一个或多个节点可以**提议(propose)<strong>某些值，而共识算法</strong>决定(decides)**采用其中的某个值</p>
<p>共识算法需要满足以下性质：</p>
<p>1️⃣ 一致同意：没有2个节点的决定不同</p>
<p>2️⃣ 完整性：没有节点决定2次</p>
<p>3️⃣ 有效性：如果一个节点决定了值<code>v</code>,则<code>v</code>由某个节点所提议</p>
<p>4️⃣ 终止 ： 由所有未崩溃的节点来最终决定值</p>
</blockquote>
<p>终止属性形成了容错的思想，该属性是一个活性属性，而另外三个是安全属性。如果不关心容错，仅仅满足前三个属性就OK，因为你可以将其中一个节点硬编码为leader，让该节点做出所有的决定，但是节点一旦失效，系统无法就无法做出决定了。比如2PC就能够满足，但是2PC的问题是，协调者失效，存疑的参与者无法决定是提交还是终止，故2PC不满足终止属性的要求</p>
<p>绝大多数共识算法实际上并不直接使用1️⃣2️⃣3️⃣4️⃣形式化模型，而是使用全序广播代为实现</p>
<h2 id="共识算法和全序广播">共识算法和全序广播</h2>
<p>最著名的容错共识算法是<strong>视图戳复制(VSR, viewstamped replication)</strong>，Paxos，Raft 以及 Zab。视图戳复制，Raft和Zab直接实现了全序广播，因为这样做比重复 <strong>一次一值(one value a time)</strong> 的共识更高效，因为全序广播的要求是：</p>
<blockquote>
<p>1️⃣ 可靠交付（reliable delivery）:  没有消息丢失：如果消息被传递到一个节点，它将被传递到所有节点</p>
<p>2️⃣ 全序交付（totally ordered delivery）:  消息以相同的顺序传递给每个节点</p>
</blockquote>
<p>可以发现，<strong>全序广播等于进行了重复多轮共识</strong></p>
<p>在单主复制中，将所有的写入操作都交给主库，并以相同的顺序将他们应用到从库，从而使副本保持在最新状态，这里其实是一种 <strong>“独裁类型”</strong> 的共识算法，领导者是运维指定的，一旦故障必须人为干预，它无法满足共识算法的终止属性</p>
<h2 id="时代编号和法定人数">时代编号和法定人数</h2>
<p>共识协议一般会定义1个<strong>时代编号(epoch number)</strong>，在Paxos中称为<strong>投票编号(ballot number)</strong>，视图戳复制中的<strong>视图编号(view number)</strong>，以及Raft中的<strong>任期号码(term number)</strong>，并确保在每个时代中，领导者都是唯一的。每次领导者被认为挂掉的时候，会产生全序且单调递增的新的时代编号，更高时代编号的领导才真的领导。节点在做出决定之前对提议进行投票的过程是一种同步复制，这是共识的局限性</p>
<h2 id="总结：">总结：</h2>
<p>很多问题都可以归结为共识问题，并且彼此等价(从这个意义上来讲，如果你有其中之一的解决方案，就可以轻易将它转换为其他问题的解决方案)。这些等价的问题包括：</p>
<p>1️⃣ <strong>线性一致性的CAS寄存器</strong>:  寄存器需要基于当前值是否等于操作给出的参数，原子地<strong>决定</strong>是否设置新值</p>
<p>2️⃣ <strong>原子事务提交</strong> :  数据库必须<strong>决定</strong>是否提交或中止分布式事务</p>
<p>3️⃣  <strong>全序广播</strong>:  消息系统必须<strong>决定</strong>传递消息的顺序</p>
<p>4️⃣ <strong>锁和租约</strong>:  当几个客户端争抢锁或租约时，由锁来<strong>决定</strong>哪个客户端成功获得锁</p>
<p>5️⃣ <strong>成员/协调服务</strong>: 给定某种故障检测器(例如超时)，系统必须<strong>决定</strong>哪些节点活着，哪些节点因为会话超时需要被宣告死亡</p>
<p>6️⃣ <strong>唯一性约束</strong>: 当多个事务同时尝试使用相同的键创建冲突记录时，约束必须<strong>决定</strong>哪一个被允许，哪些因为违反约束而失败</p>
<p>如果你只有一个节点，或者你愿意将决策权分配给单个节点，所有这些事都很简单。这就是在单领导者数据库中发生的事情：所有决策权归属于领导者，这就是为什么这样的数据库能够提供线性一致的操作，唯一性约束，完全有序的复制日志等。但如果该领导者失效，或者如果网络中断导致领导者不可达，这样的系统就无法取得任何进展。应对这种情况可以有三种方法：</p>
<blockquote>
<p>1️⃣等待领导者恢复，接受系统将在这段时间阻塞的事实。许多XA/JTA事务协调者选择这个选项。这种方法并不能完全达成共识，因为它不能满足<strong>终止</strong>属性的要求：如果领导者续命失败，系统可能会永久阻塞</p>
<p>2️⃣ 人工故障切换，让人类选择一个新的领导者节点，并重新配置系统使之生效，许多关系型数据库都采用这种方方式。这是一种来自“天意”的共识 —— 由计算机系统之外的运维人员做出决定。故障切换的速度受到人类行动速度的限制，通常要比计算机慢得多</p>
<p>3️⃣ 使用算法自动选择一个新的领导者。这种方法需要一种共识算法，使用成熟的算法来正确处理恶劣的网络条件是明智之举</p>
</blockquote>
<h1>批处理</h1>
<h2 id="关于衍生数据">关于衍生数据</h2>
<p>第三部分的内容，主要讨论将多个不同数据系统(有着不同的数据模型，并针对不同的访问模式进行优化)集成为一个协调一致的应用架构时，会遇到的问题。从高层次看，存储和记录数据系统分为2大类：</p>
<p>🅰️ 记录系统(System of record) ：数据的权威版本(如果其他系统和<strong>记录系统</strong>之间存在任何差异，那么记录系统中的值是正确的)</p>
<p>🅱️ 衍生数据系统(Derived data systems) ：通常是另一个系统中的现有数据进行转换或处理的结果，如缓存、索引、物化视图等，推荐系统中，预测汇总数据通常衍生自用户日志</p>
<p>三种不同的数据处理系统：</p>
<p>1️⃣ 服务(在线系统)</p>
<p>2️⃣ 批处理系统(离线系统)</p>
<p>3️⃣ 流处理系统(准实时系统)</p>
<p>流处理和批处理最关键的区别是处理无界数据和有界数据</p>
<blockquote>
<p>MPP数据库(大规模并行处理(MPP， massively parallel processing)专注于在一组机器上并行执行分析SQL查询，而MapReduce和分布式文件系统的组合则更像是一个可以运行任意程序的通用操作系统，批处理框架看起来越来越像MPP数据库了</p>
</blockquote>
<h2 id="UNIX">UNIX</h2>
<p>基于Unix的awk，sed，grep，sort，uniq和xargs等工具的组合，可以轻松的帮助我们完成一些数据分析的工作，而且性能相当的好。而且，这些工具使用相同的接口，在Unix中，这种接口是一个file(准确的说是一个文件描述符)</p>
<blockquote>
<p>文件是一个统一的接口，如果我们的程序的输入和输出都是文件，那么所有的程序缝合起来，像接力一样完成复杂的工作；统一的接口还包括URL和HTTP(我们可以在网站和网站之间无缝跳转)。这和函数式编程的理念非常类似</p>
</blockquote>
<p>Unix工具很强大，但是其局限性就是只能在一台机器上运行，所以Hadoop这样的工具应运而生</p>
<h2 id="MapReduce">MapReduce</h2>
<p>Unix和MapReduce比对</p>
<table>
<thead>
<tr>
<th>MR</th>
<th>除了生成输出没有副作用</th>
<th>简单粗暴却有效</th>
<th>分布式</th>
<th>分布式文件系统上读写文件</th>
<th>使用无共享架构</th>
<th>通过工作流(workflow)将多个MR作业连接在一起，文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unix</td>
<td>除了生成输出没有副作用</td>
<td>简单粗暴却有效</td>
<td>单机</td>
<td>使用<code>stdin</code>和<code>stdout</code>作为输入输出</td>
<td>共享架构</td>
<td>管道符，内存缓存区<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup></td>
</tr>
</tbody>
</table>
<blockquote></blockquote>
<p>MapReduce是一个编程框架，可以使用它编写代码处理HDFS等分布式文件系统中的大型数据集，并且遵循<em>移动计算大于移动数据的原则</em>。MapReduce的数据处理过程如下：</p>
<p>1️⃣ 读取一组输入文件，并将其分解成记录(records)</p>
<p>2️⃣ 调用Mapper函数，从每条输入记录中提取一对键值；map的任务数由输入文件块的数量决定</p>
<p>3️⃣ 按键排序所有的键值对</p>
<p>4️⃣ 调用Reducer函数遍历排序后的键值对，相同的key，将会在reducer中相邻；reduce的任务数量是可配置的</p>
<p>其中第2️⃣4️⃣步是自定义数据处理代码的地方，第3️⃣步Mapper的输出始终在送往Reducer之前进行排序，无须编写。下图是个三个Mapper和三个Reducer的MR任务：</p>
<p align="center">
  <img src="/2023/09/21/ddia/42.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>Mapper中的数据去往Reducer的过程可以看做是Mapper将消息发送给Reducer，每当Mapper发出一个键值对，这个键的作用就好像是去往到目标地址(IP地址)</p>
<h2 id="Reducer端联接：">Reducer端联接：</h2>
<p>如下图，左侧是事件日志，右侧是用户数据库，任务需要将用户活动和用户档案相关联：</p>
<p align="center">
  <img src="/2023/09/21/ddia/43.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
整个连接的MapReduce过程如下:
<p align="center">
  <img src="/2023/09/21/ddia/44.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
MapReduce框架通过键对Mapper输出进行分区，然后对键值对进行排序，使得具有相同ID的所有活动事件和用户记录在Reducer输入中彼此相邻。 Map-Reduce作业可以进一步让这些记录排序，使Reducer总能先看到来自用户数据库的记录，紧接着是按时间戳顺序排序的活动事件(二次排序/secondary sort)
<p>然后Reducer可以执行实际的连接逻辑：每个用户ID都会被调用一次Reducer函数，且因为二次排序，第一个值应该是来自用户数据库的出生日期记录。 Reducer将出生日期存储在局部变量中，然后使用相同的用户ID遍历活动事件，输出已观看网址和观看者年龄的结果对。随后的Map-Reduce作业可以计算每个URL的查看者年龄分布，并按年龄段进行聚集</p>
<p>因为Mapper的输出是按键排序的，然后Reducer将来自连接两侧的有序记录列表合并在一起，所以这个算法被称为排序合并连接(sort-merge join)</p>
<p>MapReduce实现这分组操作的方法是设置Mapper，使得Mapper生成的键值对使用所需的分组键</p>
<blockquote>
<p>热键(hot pot)和倾斜连接(skewed join) ： 热键是指记录中某个键记录数显著高于其他的键，热键关联是会产生倾斜关联(1个Reducer会处理比其他Reducer更多的记录)；一般处理倾斜连接方式是分2次MR</p>
</blockquote>
<h2 id="Map端联接：">Map端联接<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>：</h2>
<p>在Reducer端连接中，排序，复制至Reducer，以及合并Reducer输入，所有这些操作可能开销巨大，如果数据具备某些特性，或许可以使用一些性能更优的连接方式，如：</p>
<p>1️⃣广播散列连接：在小表足够小的情况下，将小表读取到内存散列表中，然后Mapper扫描大表在散列表中查找每个事件</p>
<p>2️⃣ 分区散列连接：本质是GRACE Hash Join，在Hive中叫做：Map 端桶连接</p>
<p>3️⃣ Map端合并连接：本质是 sort-merge-join</p>
<blockquote></blockquote>
<p>批处理的常见用途是：构建机器学习系统(分类器/推荐系统等)，建立搜索索引(google最初使用MR就是为其搜索索引建立索引)，批处理的输出哲学和Unix一致，除了产生输出不会产生任何副作用，即容错能力高</p>
<h2 id="Hadoop与分布式数据库比对">Hadoop与分布式数据库比对</h2>
<p>Hadoop很像Unix的分布式版本，其中HDFS是分布式文件系统，MapReduce是Unix进程的变种实现，我们一直讨论的并行连接算法在MPP数据库中已有实现，区别在于MPP数据库专注于在一组机器上并行执行分析SQL，而MapReduce和分布式文件系统的组合更像是可以运行任意通用程序的操作系统</p>
<table>
<thead>
<tr>
<th></th>
<th>存储多样性</th>
<th>处理模型</th>
<th>故障处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hadoop</td>
<td>字节序列</td>
<td>MapReduce模型，SQL模型等<br>处理模型多样性<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup></td>
<td>针对故障频繁而设计<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup></td>
</tr>
<tr>
<td>分布式数据库</td>
<td>要求特定的模型(关系/文档)</td>
<td>SQL模型<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup></td>
<td>查询失效时，多数MPP会终止查询</td>
</tr>
</tbody>
</table>
<blockquote></blockquote>
<p>💔：使用原始的<code>MapReduce API</code>来实现复杂的处理工作实际上是非常困难，所以在MapReduce上有很多高级编程模型(Pig，Hive，Cascading，Crunch)被创造出来。🅰️方面，MapReduce非常稳健；🅱️方面，对于某些类型的处理而言，其他工具有时会快上几个数量级。流处理组件(storm、spark、flink)可以认为是解决"慢"这个问题而被发展出来的，物化中间状态也是一种加速方式</p>
<h2 id="物化中间状态">物化中间状态</h2>
<p>将数据发布到分布式文件系统中众所周知的位置能够带来<strong>松耦合</strong>，这样作业就不需要知道是谁在提供输入或谁在消费输出，一个作业的输出只能用作另一个作业的输入的情况下，分布式文件系统上的文件只是简单的<strong>中间状态(intermediate state)</strong>：一种将数据从一个作业传递到下一个作业的方式。将这个中间状态写入文件的过程称为<strong>物化(materialization)</strong>[<sup>22][</sup>23]</p>
<blockquote>
<p>link: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Materialized_view">https://en.wikipedia.org/wiki/Materialized_view</a> + <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/93539/what-is-the-difference-between-views-and-materialized-views-in-oracle">https://stackoverflow.com/questions/93539/what-is-the-difference-between-views-and-materialized-views-in-oracle</a> + <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Materialized_view">https://en.wikipedia.org/wiki/Materialized_view</a></p>
</blockquote>
<p>💔：Unix管道将一个命令的输出与另一个命令的输入连接起来。管道并没有完全物化中间状态，而是只使用一个小的内存缓冲区，将输出增量地**流(stream)**向输入，与Unix管道相比，MapReduce完全物化中间状态的方法的不足之处在于：</p>
<p>1️⃣MapReduce作业只有在前驱作业(生成其输入)中的所有任务都完成时才能启动，而由Unix管道连接的进程会同时启动，输出一旦生成就会被消费</p>
<p>2️⃣ Mapper通常是多余的，如果Reducer和Mapper的输出有着相同的分区与排序方式，那么Reducer就可以直接串在一起，而不用与Mapper相互交织</p>
<p>3️⃣ 将中间状态存储在分布式文件系统中意味着这些文件被复制到多个节点</p>
<h2 id="数据流引擎">数据流引擎</h2>
<p>为了解决MapReduce的这些问题，几种用于分布式批处理的新执行引擎(Spark、Tez、Flink)被开发出来，它们的设计方式有很多区别，但有一个共同点：把整个工作流作为单个作业来处理，而不是把它分解为独立的子作业。由于它们将工作流显式建模为数据从几个处理阶段穿过，所以这些系统被称为<strong>数据流引擎(dataflow engines)</strong>，像MapReduce一样，它们在一条线上通过反复调用用户定义的函数来一次处理一条记录，这些函数为<strong>算子(operators)</strong>，数据流引擎提供了几种不同的选项来将一个算子的输出连接到另一个算子的输入：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>一种选项是对记录按键重新分区并排序，就像在MapReduce的混洗阶段一样。这种功能可以用于实现排序合并连接和分组</p>
</li>
<li class="lvl-2">
<p>另一种可能是接受多个输入，并以相同的方式进行分区，但跳过排序。当记录的分区重要但顺序无关紧要时，这省去了分区散列连接的工作，因为构建散列表还是会把顺序随机打乱</p>
</li>
<li class="lvl-2">
<p>对于广播散列连接，可以将一个算子的输出，发送到连接算子的所有分区</p>
</li>
</ul>
<p>与MapReduce模型相比，它有几个优点：</p>
<p>1️⃣排序等昂贵的工作只需要在实际需要的地方执行，而不是默认地在每个Map和Reduce阶段之间出现</p>
<p>2️⃣没有不必要的Map任务，因为Mapper所做的工作通常可以合并到前面的Reduce算子中(因为Mapper不会更改数据集的分区)</p>
<p>3️⃣由于工作流中的所有连接和数据依赖都是显式声明的，因此调度程序能够总览全局，知道哪里需要哪些数据，因而能够利用局部性进行优化。例如，它可以尝试将消费某些数据的任务放在与生成这些数据的任务相同的机器上，从而数据可以通过共享内存缓冲区传输，而不必通过网络复制</p>
<p>4️⃣通常，算子间的中间状态足以保存在内存中或写入本地磁盘，这比写入HDFS需要更少的I/O(必须将其复制到多台机器，并将每个副本写入磁盘)。 MapReduce已经对Mapper的输出做了这种优化，但数据流引擎将这种思想推广至所有的中间状态</p>
<p>5️⃣ 算子可以在输入就绪后立即开始执行；后续阶段无需等待前驱阶段整个完成后再开始</p>
<p>6️⃣ 与MapReduce(为每个任务启动一个新的JVM)相比，现有Java虚拟机(JVM)进程可以重用来运行新算子，从而减少启动开销</p>
<p>你可以使用数据流引擎执行与MapReduce工作流同样的计算，而且由于此处所述的优化，通常执行速度要明显快得多。相同的处理逻辑，可以通过修改配置切换底层计算引擎，简单地从MapReduce切换到Tez或Spark<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup></p>
<blockquote></blockquote>
<h2 id="总结-3">总结</h2>
<p>本章主要讲述了Unix的管道思想，MapReduce与其接口HDFS，最后是数据流引擎构建自己的管道式的数据传输机制。并且还讨论了分布式批处理框架要解决的2个主要问题：</p>
<p>🅰️ 分区：这一过程的目的是把所有的<strong>相关</strong>数据(例如带有相同键的所有记录)都放在同一个地方</p>
<p>🅱️容错：MapReduce经常写入磁盘，这使得从单个失败的任务恢复很轻松，无需重新启动整个作业，但在无故障的情况下减慢了执行速度。数据流引擎更多地将中间状态保存在内存中，更少地物化中间状态，这意味着如果节点发生故障，则需要重算更多的数据。确定性算子减少了需要重算的数据量</p>
<h1>流处理</h1>
<p>流处理和批处理最原始的区别在于，流处理处理无界数据，而批处理针对有界数据。在流处理中的上下文中，记录通常被叫做<strong>事件</strong>，一个事件由生产者(producer)/发布者(publisher)/发送者(sender)生成一次，然后可能由多个消费者(consumer)/订阅者(subscribers)/接收者(recipients)进行处理。流处理的目标是<strong>事件发生后，立刻得到处理</strong>。流处理中相关的事件通常被聚合为一个主题(topic)或流(stream)</p>
<p>本质上来说，文件或者是数据库可以连接生产者和消费者，但是这种方式下消费者需要不断降低轮询文件/数据库的间隔，才能降低事件处理的延迟，而轮询会增加数据库的额外开销，我们希望在有新的事件产生的时候，能够通知到消费者，数据库的触发器或许是一个可选项，但是触发器功能有限，为了解决这个问题，消息系统应运而生</p>
<blockquote>
<p>2个进程之间进行消息传递(通信)，可以通过接口调用，还可以使用消息服务</p>
</blockquote>
<h2 id="消息系统">消息系统</h2>
<p>消息系统一定要考虑2个问题：</p>
<p>🅰️生产者发送消息的速度比消费者能够处理的速度快该如何应对？有三种方式处理：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>1️⃣丢掉消息</p>
</li>
<li class="lvl-2">
<p>2️⃣将消息放入缓冲队列</p>
</li>
<li class="lvl-2">
<p>3️⃣ 背压机制(backpressure)/流量控制(flow control)：即为阻塞生产者，避免其发送更多的消息<sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup></p>
</li>
</ul>
<blockquote></blockquote>
<p>🅱️ 如果节点崩溃或短暂脱机，是否会有消息丢失？也即<strong>持久性</strong>要求</p>
<p>批处理的一个优良的特性是，它提供了强大的可靠性保证：失败的任务会自动重试，且失败任务的输出会自动丢弃。这意味着好像故障没有发生一样，我们尝试⚠️<em>在流处理中达到类似的保证</em>。有些消息系统是直连生产者和消费者，比如使用UDP连接的应用，这种方式的确latency很低，但此类应用有一个前提假设：消费者和生产者始终在线，流处理如果是用这种方式，消费者一旦脱机，可能会丢失期间的消息</p>
<p><strong>消息代理/消息队列</strong></p>
<p>本质上消息代理是<strong>针对处理消息流</strong>的数据库。消息代理解决了上文提及的2个问题：</p>
<p>🅰️ (消费者)消费能力不足时，暂存消息；不需要丢弃消息或者背压</p>
<p>🅱️ 持久性保证：落盘</p>
<table>
<thead>
<tr>
<th>消息代理</th>
<th>消息<em>成功</em>传递给消费者后，自动删除</th>
<th>基于主题的模式匹配</th>
<th>不支持任意查询，数据变化时，会通知消费者</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库</td>
<td>数据库保留数据直到显示删除</td>
<td>数据库支持二级索引</td>
<td>查询时，往往是基于某个时间点的快照</td>
</tr>
</tbody>
</table>
<p>如上描述的，消息队列和常规的数据的差别，其中行1是关于消息代理的传统观点，被封装在JMS/AMQP<sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup>标准中，其实现有RabbitMQ，ActiveMQ等</p>
<blockquote>
<p>AMQP: Advanced Message Queuing Protocol 高级消息队列协议：面向消息中间件提供的开放的应用层协定</p>
</blockquote>
<p>消息代理中，如果有多个消费者读取同一个主题的消息时，使用2种主要的消息传递模式:</p>
<p>🅰️ 负载均衡(load balance) : 在消费者间共享消费主题</p>
<p>🅱️ 扇出(fan-out) ： 将每条消息传递给多个消费者</p>
<p>两种模式可以组合使用：两个独立的消费者组可以每组各订阅一个主题，每一组都共同收到所有消息，但在每一组内部，每条消息仅由单个节点处理</p>
<p align="center">
  <img src="/2023/09/21/ddia/38.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>消息代理使用确认(acknowledgment)<sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup>机制，来确保消息不会丢失，但一种可能的情况是：代理向消费者传递消息后消费者崩溃或处理了部分崩溃了，代理由于超出一段时间没有收到确认(也可能是确认在网络中丢失了)，便将消息传递给另外一个消费者，当消费者的消费模式是负载均衡时，下面的情况可能会发生：处理m3时消费者2崩溃，因此稍后重传至消费者1</p>
<p align="center">
  <img src="/2023/09/21/ddia/39.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<blockquote></blockquote>
<p>批处理的关键特性是：重试失败任务不会发生任何副作用，而AMQP/JMS风格的消息传递收到消息是具有破坏性的，因为确认可能导致消息从代理中被删除，因此再次运行同一个消费者可能会得到不同的结果。即便是注册新的消费者到消息系统，通常只能接收到消费者注册之后开始发送的消息，而文件系统/数据库系统新增的客户端能够读取到任意久远的数据</p>
<p><strong>基于日志的消息代理(log-based message brokers)</strong> 尝试实现 🅰️既有数据库的持久存储方式；🅱️又有消息传递的低延迟通知</p>
<h2 id="基于日志的消息代理">基于日志的消息代理</h2>
<p>在基于日志(append only mode)的消息代理中，生产者通过将消息追加到日志末尾来发送消息，而消费者通过依次读取日志来接收消息，若消费者读到日志末尾，则会等待新消息追加的通知(如Unix的 <code>tail -f</code>)。同时为了提升吞吐量，基于日志的消息代理可以对日志进行分区，每个分区内，代理为每个消息分配一个<em>单调递增</em>的序列号/偏移量(offset)。并且<em>分区内消息完全有序(跨分区无顺序保证</em>)</p>
<p align="center">
  <img src="/2023/09/21/ddia/40.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>Apache Kafka、Amazon Kinesis Streams、Twitter的DistributedLog都是基于日志的消息代理。其中下面几点要注意：</p>
<p>1️⃣消费者组：支持多个消费者组成一个消费者主订阅一个主题，单个节点消费特定的分区，一般而言单线程处理单分区是更适合的选择，通过增加分区的方式提高并行度</p>
<p>2️⃣ 消费者偏移量：所有偏移量小于消费者的当前偏移量的消息已经被处理(类似单主复制中的日志序列号)<sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup></p>
<blockquote></blockquote>
<p>3️⃣重播旧消息：消费者的消费唯一的副作用就是导致偏移量的前进，但是消费者可以操纵偏移量(类似于批处理)</p>
<h2 id="流和数据库">流和数据库</h2>
<p>此间的讨论，我们发现基于日志的消息代理从数据库中获得灵感并将其应用于消息传递，其实也可以反过来，从消息传递和流中获得灵感，并将他们应用于数据库。在单主复制中，主库的写入事件构成写入流，将写入流应用到从库，最终得到数据的精确副本。在异构数据系统中，由于相同或相关的数据出现在了不同的地方，因此相互间需要保持同步：如果某个项目在数据库中被更新，它也应当在缓存，搜索索引和数据仓库(使用ETL)中被更新，我们在批处理将描述了如何使用批处理去更新其他衍生数据系统。使用的批处理的弊端是时延，如何保证衍生数据系统低延迟获取记录系统的变更数据？</p>
<p>这就涉及到<strong>变更数据捕获(change data capture, CDC)</strong>,这是一种观察写入数据库的所有数据变更，并将其提取并转换为可以复制到其他系统中的形式的过程。如下图：捕获数据库中的变更，并不断将相同的变更应用至搜索索引</p>
<p align="center">
  <img src="/2023/09/21/ddia/45.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
从本质上说，变更数据捕获使得一个数据库成为领导者(被捕获变化的数据库)，并将其他组件变为追随者。基于日志的消息代理非常适合从源数据库传输变更事件，因为它保留了消息的顺序。 LinkedIn的Databus，Facebook的Wormhole和Yahoo!的Sherpa大规模地应用这个思路。 Bottled Water使用解码WAL的API实现了PostgreSQL的CDC，Maxwell和Debezium通过解析binlog对MySQL做了类似的事情
<p>重放<strong>所有</strong>对数据库进行变更的日志，过于耗时，因此一般会保留数据库的快照，快照+快照时刻对应的偏移量可以加快重建数据库的完整状态。另外一个加速重建数据库完整状态的方式是日志压缩<sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup>，Apache Kafka支持这种日志压缩功能</p>
<blockquote></blockquote>
<h2 id="事件溯源-Event-Sourcing">事件溯源(Event Sourcing)</h2>
<p>事件溯源起源于领取驱动设计(domain-driven design,DDD)，和CDC类似，事件溯源将<strong>所有涉及对应用状态的变更存储为变更事件日志</strong>，其核心在于将用户的行为记录为不可变的事件，而不是在可变数据库中记录这些行为的影响。事件存储是仅追加的，原地删除和更新是不被鼓励的。事件日志和星型模式中的事实表有相似之处</p>
<p>使用事件溯源的应用需要拉取事件日志(表示写入系统的数据)，并将其转换为适合向用户显示的应用状态，和CDC一样，重放事件日志可以重新构建系统的当前状态。 事件溯源的哲学是仔细区分<strong>事件(event)<strong>和</strong>命令(command)</strong>，用户的请求刚到达时，它一开始是一个命令(在这个时间点上它仍然可能可能失败，比如违反了一些完整性条件)应用必须首先验证它是否可以执行该命令。如果验证成功并且命令被接受，则它变为一个持久化且不可变的事件。从数学角度来看，应用状态是事件流对时间求积分的结果 $state(now) = \int_{t=0}^{now}{stream(t) \ dt}$，变更流是应用状态对时间求微分的结果 $stream(t) = \frac{d\ state(t)}{dt}$</p>
<p>日志压缩是连接事件日志与数据库状态之间的桥梁：它只保留每条记录的最新版本，并丢弃被覆盖的版本。我们可以基于事件溯源中的记录的事件日志派生出多个视图，通过将数据写入的形式与读取形式相分离<sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup>，并允许几个不同的读取视图，这样极大的提高了灵活性</p>
<blockquote></blockquote>
<p>事件溯源和变更数据捕获的最大缺点是事件日志的消费者通常是异步的，所以可能出现的情况是：用户写入日志，然后从日志衍生视图中读取，结果发现他的写入还没有反映在读取视图中，一种解决方案是将事件附加到日志时同步执行读取视图的更新，如果是事件日志和读取视图保存在同一个存储系统中，需要使用事务，如果是异构数据库则涉及分布式事务</p>
<p>🎈至此，我们谈及到了流的来源1️⃣用户活动事件，2️⃣传感器，3️⃣写入数据库；流如何传输1️⃣直接通过消息传送 2️⃣消息代理 3️⃣ 事件日志。那么我们用流干什么？</p>
<h2 id="流处理">流处理</h2>
<p>流一般有以下三种用途</p>
<p>1️⃣ 你可以将事件中的数据写入数据库，缓存，搜索索引或类似的存储系统，然后能被其他客户端查询</p>
<p>2️⃣ 以某种方式将事件推送给用户，如发送报警邮件或推送通知，或将事件流式传输到可实时显示的仪表板上。这种情况下，人是流的最终消费者</p>
<p>3️⃣ 你可以处理一个或多个输入流，并产生一个或多个输出流。流可能会经过由几个这样的处理阶段组成的流水线，最后再输出1️⃣或2️⃣</p>
<p>我们将重点讨论3️⃣处理流产生其他衍生流，处理这样的流的代码片段，称之为算子(operator)或者作业(job)；流处理和批处理最大的区别是流处理处理无界数据，由于是无界导致排序没有意义，也就无法使用排序合并连接（sort merge join），容错机制也不能像批处理那样通过从头执行的方式</p>
<h2 id="流处理应用">流处理应用</h2>
<p>1️⃣ 复合事件处理(complex,event processing CEP)，CEP通常使用高层次的声明式查询语句如SQL，在流中搜索某些事件（就像正则表达式一样），当发现匹配时，引擎发出一个<strong>复合事件(complex event)</strong>（因此得名）。一般而言，数据库会持久存储数据，并将查询视为临时的，当查询进入时，数据库搜索与查询匹配的数据，然后在查询完成时丢掉查询。 CEP引擎反转了角色：查询是长期存储的，来自输入流的事件不断流过它们。CEP的实现包括 Esper、IBM InfoSphere Streams</p>
<p>2️⃣流分析，流分析关注大量事件上的聚合与统计指标，统计指标通常是在固定时间区（窗口[window]）间内进行计算的。许多开源分布式流处理框架的设计都是针对分析设计的：例如Apache Storm，Spark Streaming，Flink</p>
<p>3️⃣ 维护物化视图。数据库的变更流（CDC或是事件日志）可以用于维护衍生数据系统，使其与源数据库保持最新，基于衍生查询（写入和查询相分离）。也是流的一个应用，但是要求任意时间段内的所有事件，和流分析场景有很大的不同。类似Spark Streaming 不支持</p>
<h3 id="关于事件时间和处理时间">关于事件时间和处理时间</h3>
<p>🅰️ 处理时间：事件到达处理节点的时钟。使用处理时间定义窗口，会因为处理速率的变动引入人为因素，如下图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/46.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>🅱️ 事件时间：事件发生的时间。延迟先发生的事件先到达处理节点，无法确定是否已经收到了特定窗口的所有事件，如何处理这种在窗口宣告完成之后到达的滞留（straggler）事件？</p>
<h3 id="窗口">窗口</h3>
<p>1️⃣ 滚动窗口(Tumbling Window)：窗口有固定的长度，而且每个事件都只属于一个窗口</p>
<p>2️⃣跳动窗口(Hopping Window) ：窗口有固定的长度，如1分钟跳跃步长的5分钟窗口</p>
<p>3️⃣滑动窗口(Sliding Window)：滑动窗口包含了彼此间距在特定时长内的所有事件，通过维护一个按时间排序的事件缓冲区，并不断从窗口中移除过期的旧事件，可以实现滑动窗口</p>
<p>4️⃣会话窗口(Session window) 将同一用户出现时间相近的所有事件分组在一起，而当用户一段时间没有活动时（例如，如果30分钟内没有事件）窗口结束</p>
<h2 id="流式连接">流式连接</h2>
<p>涉及<strong>流-流</strong>连接，<strong>流-表</strong>连接，与<strong>表-表</strong>连接</p>
<p>1️⃣ 流流连接，实际是窗口的连接，Window join 作用在两个流中有<em>相同 key</em> 且处于<em>相同窗口</em>的元素上。比如Flink将流流连接细分为滚动Window Join，滑动Window Join，会话Window Join。<a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/datastream/operators/joining/">Flink的双流Join</a>。比如下图是Spark Streaming中一个广告流和一个点击流的连接</p>
<p align="center">
  <img src="/2023/09/21/ddia/55.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>流表连接，实际是流扩展。如下图的点击流和用户档案的连接，首先将数据库副本加载到流处理器中，然后流处理器需要一次处理一个活动事件。 流表连接实际上非常类似于流流连接；最大的区别在于对于表的变更日志流，连接使用了一个可以回溯到“时间起点”的窗口
<p align="center">
  <img src="/2023/09/21/ddia/43.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 表表连接。在推特时间线的例子中，用户查看自身主页时间线时，迭代用户所关注人群的推文并合并它们需要一个时间线缓存，在流处理器中实现这种缓存维护，需要推文事件流(发送与删除)和关注关系事件流(关注与取消关注)，即该流处理的过程是维护了一个连接了两个表(推文与关注)的物化视图，如下时间线实际上是这个查询结果的缓存，每当基础表发生变化时都会更新
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> follows.follower_id <span class="keyword">as</span> timeline_id, </span><br><span class="line">    <span class="built_in">array_agg</span>(tweets.<span class="operator">*</span> <span class="keyword">order</span> <span class="keyword">by</span> tweets.timestamp <span class="keyword">desc</span>)</span><br><span class="line"><span class="keyword">from</span> tweets</span><br><span class="line"><span class="keyword">join</span> follows <span class="keyword">on</span>  tweets.sender_id <span class="operator">=</span> follows.followee_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> follows.follower_id</span><br></pre></td></tr></tbody></table></figure>
<h2 id="连接的时间依赖性">连接的时间依赖性</h2>
<p>流流、流表、表表连接有很多共同点，<strong>他们都需流处理器维护连接一侧的一些状态(广告流和点击流，用户档案，关注列表)，然后当连接另外一侧的消息到达时查询该状态</strong>。这里会有一个问题，如在流表连接的例子中，如果用户更新了档案，哪些活动事件与旧档案连接(在档案更新前)？，哪些又与新档案连接(在档案更新后)？即连接存在<em>时序依赖</em>，比如处理发票和税率问题时，当连接销售额与税率表时，你可能期望的是使用销售时的税率参与连接，如果你正在重新处理历史数据，销售时的税率可能和现在的税率有所不同</p>
<p>即如果跨流事件的顺序是未定的，则连接会变成不确定性的，那么在同样输入上重跑可能会得到不同的结果。这个问题在数仓中叫<em>缓慢变化的维度(slowly changing dimension,SCD)<sup class="footnote-ref"><a href="#fn31" id="fnref31">[31]</a></sup></em>，通常通过对特定版本的记录使用唯一的标识符来解决：例如，每当税率改变时都会获得一个新的标识符，而发票在销售时会带有税率的标识符。这种变化使连接变为确定性的，但也会导致日志压缩无法进行：表中所有的记录版本都需要保留</p>
<blockquote></blockquote>
<h2 id="流处理如何处理容错">流处理如何处理容错</h2>
<p>在批处理中，容错的方式就是重跑，而且其输出的效果就像只处理了一次一样，这个原则叫做<strong>恰好/精确一次语义(exactly-once semantics)</strong>，流处理为了实现恰好一次语义，有以下2种方式</p>
<p>🅰️ 微批，即将流分解成小块，并像微型批处理一样处理每个块，微批次(通常为1S)也隐式提供了一个与批次大小相等的滚动窗口(<em>按处理时间而不是事件时间戳分窗</em>)，代表应用为Spark Streaming</p>
<p>🅱️存档点， Apache Flink会定期生成状态的滚动存档点并将其写入持久存储。如果流算子崩溃，它可以从最近的存档点重启，并丢弃从最近检查点到崩溃之间的所有输出</p>
<p>在流处理框架的范围内，微批次与存档点方法提供了与批处理一样的<strong>恰好一次语义</strong>。但是，只要输出离开流处理器(例如，写入数据库，向外部消息代理发送消息，或发送电子邮件)，框架就无法抛弃失败批次的输出了。在这种情况下，重启失败任务会导致外部副作用发生两次，只有微批次或存档点不足以阻止这一问题，我们需要确保事件处理的所有输出和副作用<strong>当且仅当</strong>处理成功时才会生效。分布式事务是一种解决方案，另外一种方式是<strong>幂等性</strong>(idempotence)</p>
<p>幂等操作是多次重复执行与单次执行效果相同的操作，例如，将键值存储中的某个键设置为某个特定值是幂等的（再次写入该值，只是用同样的值替代），而递增一个计数器不是幂等的(再次执行递增意味着该值递增两次)。在使用来自Kafka的消息时，每条消息都有一个持久的，单调递增的偏移量。将值写入外部数据库时可以将这个偏移量带上，这样你就可以判断一条更新是不是已经执行过了，因而避免重复执行</p>
<p>&lt;完&gt;</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>意味着即使发生故障，系统也能正常工作 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>意味着即使在负载增加的情况下也有保持性能的策略 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>有许多方面，但实质上是关于工程师和运维团队的生活质量的 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>SSTable : Sort String Table ，排序字符串表，对每个段文件中的键进行排序 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>卡桑德拉，Apache Cassandra是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于改善电子邮件系统的搜索性能的简单格式数据，集Google BigTable的数据模型与Amazon Dynamo的完全分布式架构于一身 <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>和ES一样是一个企业级的搜索索引 <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Hologres存储引擎： <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/779284?spm=a2c4g.11186623.0.0.11cf49fc9XL2Nw&amp;groupCode=hologres">https://developer.aliyun.com/article/779284?spm=a2c4g.11186623.0.0.11cf49fc9XL2Nw&amp;groupCode=hologres</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>固定大小的块或者页面：如果读者注意到过SQL引擎的执行计划的话，一般会有一个类似seq_page_cost（postgresql叫这个）的参数描述的就是每次Planner抓取一个数据页的成本（cost）， the planner’s estimate of the cost of a disk page fetch that is part of a series of sequential fetches <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>数据湖：是指使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%80%B2%E4%BD%8D%E5%A4%A7%E5%9E%8B%E7%89%A9%E4%BB%B6">大型二进制对象</a>或文件这样的自然格式储存数据的系统[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%B9%96#cite_note-1">1]</a>  ，数据湖可以包括<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93">关系数据库</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">结构化数据</a>(行与列)、半结构化的数据(<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94%E5%80%BC">CSV</a>，日志，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/XML">XML</a>, <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/JSON">JSON</a>)，非结构化数据 (电子邮件、文件、PDF)和 二进制数据(图像、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E9%9F%B3%E8%A8%8A">音频</a>、视频) <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>分区有很多中叫法，比如Solr Cloud中被称为分片(shard),在HBase中称之为区域(Region)，Bigtable/Kudu中则是表块(tablet，Cassandra和Riak中是虚节点(vnode), Couchbase中叫做虚桶(vBucket)，但是分区(partition)是约定俗成的叫法 <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>该分区方式依赖于散列函数，一个 $32$ 位散列函数,无论何时给定一个新的字符串输入，它将返回一个 $0$ 到 $2^{32} -1$ 之间的"随机"数 <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>我们搜索的关键词决定了次级索引的分区方式，因此称之为关键词索引，关键词(term)一词来源于全文搜索索引(一种特殊的次级索引)。 <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>即一致性哈希解决的问题，一致性哈希的主要应用就是降低路由成本 <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>关于硬件故障：硬件故障率是很高的，磁盘在进行大量的读写之后失效的概率是很高的，IDC数据中心对物理环境的要求是很苛刻的，为了降低温度空调不够用，甚至把数据中心搬到山洞里，比如阿里在贵州云南的IDC，地板使用静电地板，每个机房入口的挡鼠板比膝盖还高，供电都是双路供电等。 <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>行锁满足两阶段锁协议，两阶段锁协议是说：锁需要的时候才加上的，在事务结束的时候才释放；同时行锁也是2PL（2阶段锁定），在当前事务写入时必须持有排它锁，直到事务提交才释放排它锁。 <strong>两阶段锁协议和2pl说的是一个事情</strong> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制； <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>更新数据是先读后写的，读只能读当前<strong>已提交</strong>的最新值，这就是当前读 <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>网络分区区别于分区，分区是一种中将数据集划分为多块，以此来提升并发读写能力； 而网络分区是指节点<em>彼此断开</em>但是仍然活跃。 <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>多个MR任务连接的方式是将后一个MR任务的输入配置为前一个MR任务的输出；而Unix命令管道是直接将一个进程的输出作为另外一个进程的输入，仅用一个很小的内存缓冲区 <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>关于上述三种连接方式请参阅：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lulNpgxillQ0s5fb_rgvdw">https://mp.weixin.qq.com/s/lulNpgxillQ0s5fb_rgvdw</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>并非所有数据类型的处理都可以合理的用SQL表达(推进系统、特征工程等)，所以编写代码是必须的，而MR能使得工程师可以轻松的在大型数据集上执行自己的代码，甚至还可以基于MapReduce+HDFS 建立SQL查询执行引擎，比如Hive就是这么做的；除了SQL和MapReduce之外，由于Hadoop平台的开放性，还可以构建更多的模型。由于不需要将数据导入到专门的系统进行不同类型的处理，采用新的处理模型也更容易。如MPP风格的分析型数据库impala，随机访问风格的OLTP数据库HBase(LSM) <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>落盘一方面是容错，一方面是假设数据集太大不能适应内存。并且支持支持资源的过度使用 <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>MPP 是单体的紧密集成的软件，负责磁盘上的存储布局，查询计划，调度和执行，这些组件针对数据库的特定需求做了优化，因此可以对特定查询有很好的性能，但只支持SQL模型 <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Tez是一个相当薄的库，它依赖于YARN shuffle服务来实现节点间数据的实际复制，而Spark和Flink则是包含了独立网络通信层，调度器，及用户向API的大型框架 <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>比如能够恰好连接1个生产者和一个消费者Unix管道和TCP连接，他们在应对这个问题的时候使用背压机制，它们有一个固定大小的缓冲区，一旦填满发送者就会被阻塞，直到接受者从缓冲区取出数据 <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>JMS: Java Message Service，是关于Java消息中间的一组接口标准，所有消息中间件(MOM)需要实现这组接口，可类比JDBC <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>确认机制：消费者必须显示的告知代理处理完毕的时间，以便代理将消息从队列中移除 <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>❓消费者节点失效，则失效消费者的分区将指派给其他节点，并从最后记录的偏移量开始消费消息。如果消费者已经处理了后续的消息，但还没有记录它们的偏移量，那么重启后这些消息将被处理两次，这个问题如何解决呢? <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>日志压缩：类似在hash索引中讨论的日志压缩，存储引擎定期查找具有相同键的记录，丢弃到重复的内容并且只保留每个键的最新值。比如在CDC系统被配置为，每个变更都包含一个主键，且每个键的更新都替换了该键以前的值，那么只需要保留对键的最新写入就足够了。无论何时需要重建衍生数据系统(如搜索索引)，你可以从压缩日志主题0偏移量处启动新的消费者，然后依次扫描日志中的所有消息 <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>写入和读取形式相分离，也叫命令查询责任分离(command query responsibility segregation, CQRS） <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>SCD，处理SCD问题有很多种方式，从SCD0到SCD6，其中最流行的是：SCD1和SCD2；wiki：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Slowly_changing_dimension%EF%BC%9BYouTube">https://en.wikipedia.org/wiki/Slowly_changing_dimension；YouTube</a> tutorial：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=XqdZF0DJpUs">https://www.youtube.com/watch?v=XqdZF0DJpUs</a> <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag"># 技术</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2023/09/30/mysql/" rel="next" title="msyql 45 讲">
      msyql 45 讲 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Eddia%E7%9A%84%E6%BA%A2%E7%BE%8E%E4%B9%8B%E8%AF%8D"><span class="nav-number">1.</span> <span class="nav-text">关于ddia的溢美之词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85"><span class="nav-number">2.</span> <span class="nav-text">关于作者</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">整书大纲</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%AA3%E9%83%A8%E5%88%86"><span class="nav-number"></span> <span class="nav-text">哪3部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%B8%8F%E2%83%A3-%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="nav-number">1.</span> <span class="nav-text">1️⃣ 数据系统的基石</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%B8%8F%E2%83%A3-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE"><span class="nav-number">2.</span> <span class="nav-text">2️⃣ 分布式数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%B8%8F%E2%83%A3-%E6%B4%BE%E7%94%9F%E6%95%B0%E6%8D%AE"><span class="nav-number">3.</span> <span class="nav-text">3️⃣ 派生数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86vs%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86"><span class="nav-number"></span> <span class="nav-text">计算密集vs数据密集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0%E8%B4%9F%E8%BD%BD%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">如何描述负载？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">如何描述性能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%B9%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">什么是弹性的？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">第2章节-数据模型与查询语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8A%BF%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">文档模型和关系模型的优劣势？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9F%A5%E8%AF%A2vs%E5%91%BD%E4%BB%A4%E5%BC%8F%E6%9F%A5%E8%AF%A2"><span class="nav-number"></span> <span class="nav-text">声明式查询vs命令式查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MapReduce%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number"></span> <span class="nav-text">MapReduce是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number"></span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%9E%E6%80%A7%E5%9B%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">A-什么是属性图模型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Cypher-%E5%B1%9E%E6%80%A7%E5%9B%BE%E6%A8%A1%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.</span> <span class="nav-text">B-Cypher 属性图模型声明式查询语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E6%97%B6%E6%A8%A1%E5%BC%8Fvs%E5%86%99%E6%97%B6%E6%A8%A1%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">读时模式vs写时模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number"></span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">第3章节-存储与检索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E7%B4%A2%E5%BC%95%E6%97%A5%E5%BF%97"><span class="nav-number"></span> <span class="nav-text">无索引日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">如何提升查找效率？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E6%9E%84%E5%BB%BAhash%E7%B4%A2%E5%BC%95"><span class="nav-number"></span> <span class="nav-text">内存中构建hash索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8-%E5%8E%8B%E7%BC%A9-%E5%88%86%E6%AE%B5%E5%90%88%E5%B9%B6-hash%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">分段存储&amp;压缩&amp;分段合并 &amp; hash索引的局限性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSTable-%E6%8E%92%E5%BA%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8"><span class="nav-number"></span> <span class="nav-text">SSTable 排序字符串表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LSM-%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E5%90%88%E5%B9%B6%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">LSM 日志结构合并树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E9%A1%B5%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number"></span> <span class="nav-text">面向页存储引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E9%A1%B5%E9%9D%A2%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-number"></span> <span class="nav-text">向页面添加元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%94%E5%AF%B9LSM%E6%A0%91-%E5%92%8C-B%E6%A0%91"><span class="nav-number"></span> <span class="nav-text">比对LSM树 和 B树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OLTP-OLAP-%E5%92%8C-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93"><span class="nav-number"></span> <span class="nav-text">OLTP&amp;OLAP 和 数据仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6"><span class="nav-number"></span> <span class="nav-text">数据仓库系统组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%AA%E8%8A%B1%E6%A8%A1%E5%9E%8B"><span class="nav-number"></span> <span class="nav-text">雪花模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number"></span> <span class="nav-text">列式存储</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">第四章节-编码和演化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E6%BC%94%E5%8C%96%E6%80%A7%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">什么是可演化性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%EF%BC%8C%E5%90%91%E5%89%8D%E5%85%BC%E5%AE%B9"><span class="nav-number"></span> <span class="nav-text">向后兼容，向前兼容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">编码数据的格式有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E7%BC%96%E7%A0%81%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81"><span class="nav-number"></span> <span class="nav-text">文本编码和二进制编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number"></span> <span class="nav-text">数据流的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Web%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.</span> <span class="nav-text">A-Web服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-RPC"><span class="nav-number">2.</span> <span class="nav-text">B-RPC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">第5章节-复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="nav-number"></span> <span class="nav-text">单主复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5"><span class="nav-number"></span> <span class="nav-text">同步&#x2F;异步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%95%85%E9%9A%9C%E8%8A%82%E7%82%B9"><span class="nav-number"></span> <span class="nav-text">处理故障节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">复制延迟问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">A-什么是最终一致性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%99%E5%90%8E%E8%AF%BB%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">B-什么是写后读一致性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E8%B0%83%E8%AF%BB%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">C-什么是单调读？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E5%89%8D%E7%BC%80%E8%AF%BB%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">D-什么是一致前缀读？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">多主复制的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="nav-number"></span> <span class="nav-text">无主复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E5%8F%91%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">A-什么是并发？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">第6章-分区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">键值数据的分区方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-number"></span> <span class="nav-text">分区和二级索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1"><span class="nav-number"></span> <span class="nav-text">分区再平衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1"><span class="nav-number"></span> <span class="nav-text">请求路由</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">第7章节-事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="nav-number"></span> <span class="nav-text">事务的起源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACID"><span class="nav-number"></span> <span class="nav-text">ACID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E5%92%8C%E5%A4%9A%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C"><span class="nav-number"></span> <span class="nav-text">单对象操作和多对象操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="nav-number"></span> <span class="nav-text">读已提交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="nav-number"></span> <span class="nav-text">实现读已提交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB"><span class="nav-number"></span> <span class="nav-text">实现快照隔离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0"><span class="nav-number"></span> <span class="nav-text">丢失更新</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%81%8F%E5%B7%AE"><span class="nav-number"></span> <span class="nav-text">写偏差</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BB%E8%AF%BB"><span class="nav-number"></span> <span class="nav-text">幻读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96-%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-number"></span> <span class="nav-text">序列化&#x2F;串行化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%AE%9A-2PL"><span class="nav-number">1.</span> <span class="nav-text">两阶段锁定-2PL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%93%E8%AF%8D%E9%94%81"><span class="nav-number">2.</span> <span class="nav-text">谓词锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">索引范围锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB%EF%BC%88SSI%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">序列化快照隔离（SSI）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number"></span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">第9章节-一致性与共识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">线性一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">线性一致性的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E7%9A%84%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">实现线性一致的系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAP"><span class="nav-number"></span> <span class="nav-text">CAP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%BA%8F-vs-%E5%81%8F%E5%BA%8F"><span class="nav-number"></span> <span class="nav-text">全序 vs 偏序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%A0%E6%9E%9C%E9%A1%BA%E5%BA%8F%E4%B8%8D%E6%98%AF%E5%85%A8%E5%BA%8F%E7%9A%84"><span class="nav-number">1.</span> <span class="nav-text">因果顺序不是全序的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8F%B7%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">序列号顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%9B%A0%E6%9E%9C%E5%BA%8F%E5%88%97%E5%8F%B7%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">非因果序列号生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B0%E4%BC%AF%E7%89%B9%E6%97%B6%E9%97%B4%E6%88%B3"><span class="nav-number">4.</span> <span class="nav-text">兰伯特时间戳</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%BA%8F%E5%B9%BF%E6%92%AD-%E5%8E%9F%E5%AD%90%E5%B9%BF%E6%92%AD"><span class="nav-number"></span> <span class="nav-text">全序广播(原子广播)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%85%B1%E8%AF%86"><span class="nav-number"></span> <span class="nav-text">分布式事务与共识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%8F%90%E4%BA%A4%E5%92%8C2PC"><span class="nav-number"></span> <span class="nav-text">原子提交和2PC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%B0%83%E8%80%85%E5%A4%B1%E6%95%88"><span class="nav-number"></span> <span class="nav-text">协调者失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%B0%E5%A5%BD%E4%B8%80%E6%AC%A1%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="nav-number"></span> <span class="nav-text">恰好一次的消息处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XA%E4%BA%8B%E5%8A%A1"><span class="nav-number"></span> <span class="nav-text">XA事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E9%94%99%E5%85%B1%E8%AF%86"><span class="nav-number"></span> <span class="nav-text">容错共识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%85%A8%E5%BA%8F%E5%B9%BF%E6%92%AD"><span class="nav-number"></span> <span class="nav-text">共识算法和全序广播</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E4%BB%A3%E7%BC%96%E5%8F%B7%E5%92%8C%E6%B3%95%E5%AE%9A%E4%BA%BA%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">时代编号和法定人数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number"></span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">批处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%A1%8D%E7%94%9F%E6%95%B0%E6%8D%AE"><span class="nav-number"></span> <span class="nav-text">关于衍生数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UNIX"><span class="nav-number"></span> <span class="nav-text">UNIX</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MapReduce"><span class="nav-number"></span> <span class="nav-text">MapReduce</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reducer%E7%AB%AF%E8%81%94%E6%8E%A5%EF%BC%9A"><span class="nav-number"></span> <span class="nav-text">Reducer端联接：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E7%AB%AF%E8%81%94%E6%8E%A5%EF%BC%9A"><span class="nav-number"></span> <span class="nav-text">Map端联接[20]：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hadoop%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AF%94%E5%AF%B9"><span class="nav-number"></span> <span class="nav-text">Hadoop与分布式数据库比对</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E5%8C%96%E4%B8%AD%E9%97%B4%E7%8A%B6%E6%80%81"><span class="nav-number"></span> <span class="nav-text">物化中间状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%BC%95%E6%93%8E"><span class="nav-number"></span> <span class="nav-text">数据流引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number"></span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">流处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F"><span class="nav-number"></span> <span class="nav-text">消息系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%97%A5%E5%BF%97%E7%9A%84%E6%B6%88%E6%81%AF%E4%BB%A3%E7%90%86"><span class="nav-number"></span> <span class="nav-text">基于日志的消息代理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number"></span> <span class="nav-text">流和数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%BA%AF%E6%BA%90-Event-Sourcing"><span class="nav-number"></span> <span class="nav-text">事件溯源(Event Sourcing)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E5%A4%84%E7%90%86"><span class="nav-number"></span> <span class="nav-text">流处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E5%A4%84%E7%90%86%E5%BA%94%E7%94%A8"><span class="nav-number"></span> <span class="nav-text">流处理应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4%E5%92%8C%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4"><span class="nav-number">1.</span> <span class="nav-text">关于事件时间和处理时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3"><span class="nav-number">2.</span> <span class="nav-text">窗口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E5%BC%8F%E8%BF%9E%E6%8E%A5"><span class="nav-number"></span> <span class="nav-text">流式连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E9%97%B4%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">连接的时间依赖性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E5%A4%84%E7%90%86%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%AE%B9%E9%94%99"><span class="nav-number"></span> <span class="nav-text">流处理如何处理容错</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="i_add_u"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">i_add_u</p>
  <div class="site-description" itemprop="description">小舟从此逝，江海寄余生</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://mp.weixin.qq.com/s/IQkJlzX3l4DY_UL5NoQxdg" title="WeChat → https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;IQkJlzX3l4DY_UL5NoQxdg" rel="noopener" target="_blank"><i class="fa fa-fw fa-wechat"></i>WeChat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/ifseayou" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ifseayou" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_31807385?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_31807385?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-fw fa-codiepie"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">i_add_u</span>
</div>
  <div class="powered-by">
    <!--Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>-->
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
