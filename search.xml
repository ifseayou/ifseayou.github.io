<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hive 及相关 SQL笔记</title>
    <url>/2023/10/01/Hive/</url>
    <content><![CDATA[<p>本篇文章记录了，自己在实际工作和学习中遇到的一些问题，算是SQL相关的总结</p>
<p>更多文章欢迎关注公众号：stackoverflow</p>
<p>下面是关于SQL在引擎内部执行的顺序的简易版/必记版：</p>
<blockquote>
<p><code>from</code> 某表，<code>group by</code> 某字段，开窗 ，聚合函数，<code>having</code>，<code>distinct</code> , <code>order by</code> , <code>limit</code> ，尤其注意当 <code>group by</code> 和 开窗相遇时，一定是分组<code>group by</code>优先</p>
</blockquote>
<h2 id="hive的架构">hive的架构</h2>
<p>如下图是Hive的架构图，即解析器-编译器-优化器-执行器，区别于MySQL的，连接器-分析器-优化器-执行器</p>
<span id="more"></span>
<p align="center">
  <img src="/2023/10/01/Hive/1.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> Hive架构 VS Mysql架构 </span>
</p>
<p>Metastrore是存储元数据的数据库，默认使用的是derby，可以更改为<em><strong>MySQL</strong></em>，元数据指的是将结构化数据映射成一张表的表名，表所属的数据库(默认为default)，表的拥有者，表的列，分区字段，表的类型(是否为外部表)表所在的目录等。Hive只是和RDB只是在SQL语句上有着类似之处</p>
<h2 id="第一部分">第一部分</h2>
<h3 id="collect-x">collect_x</h3>
<p>在使用这个函数时，需要设置<code>set hive.map.aggr = false;</code> 否则可能会发生<code>IllegalArgumentException Size requested for unknown type: java.util.Collection</code>的异常<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> collect_set(col_a)  <span class="keyword">as</span>          set_a</span><br><span class="line">     , collect_list(col_a) <span class="keyword">as</span>          list_a</span><br><span class="line">     , sort_array(collect_list(col_a)) sort_list_a  <span class="comment">-- sort_array 可对序列排序</span></span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">         <span class="keyword">select</span> <span class="string">'a'</span> col_a</span><br><span class="line">         <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">         <span class="keyword">select</span> <span class="string">'b'</span> col_a</span><br><span class="line">         <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">         <span class="keyword">select</span> <span class="string">'a'</span> col_a</span><br><span class="line">         <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">         <span class="keyword">select</span> <span class="string">'a'</span> col_a</span><br><span class="line">     ) t</span><br></pre></td></tr></tbody></table></figure>
<p align="center">
  <img src="/2023/10/01/Hive/12.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> collect_list函数和 collect_set函数的用法 </span>
</p>
<blockquote></blockquote>
<h3 id="日期">日期</h3>
<p>以下是 hive 语法</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_format(<span class="string">'2019-02-10'</span>,<span class="string">'yyyy-MM'</span>);  </span><br><span class="line"><span class="number">2019</span><span class="number">-02</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> date_add(<span class="string">'2019-02-10'</span>,<span class="number">-1</span>),date_add(<span class="string">'2019-02-10'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="number">2019</span><span class="number">-02</span><span class="number">-09</span>  <span class="number">2019</span><span class="number">-02</span><span class="number">-11</span></span><br><span class="line"><span class="comment">-- (1)取当前天的下一个周一</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="string">'2019-02-12'</span>,<span class="string">'MO'</span>)</span><br><span class="line"><span class="number">2019</span><span class="number">-02</span><span class="number">-18</span></span><br><span class="line"><span class="comment">-- 说明：星期一到星期日的英文(Monday，Tuesday、Wednesday、Thursday、Friday、Saturday、Sunday)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (2)取当前周的周一   </span></span><br><span class="line"><span class="keyword">select</span> date_add(next_day(<span class="string">'2019-02-12'</span>,<span class="string">'MO'</span>),<span class="number">-7</span>);</span><br><span class="line"><span class="number">2019</span><span class="number">-02</span><span class="number">-11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (3)取当前周的周日   </span></span><br><span class="line"><span class="keyword">select</span> date_add(next_day(<span class="string">'2019-06-09'</span>,<span class="string">'mo'</span>),<span class="number">-1</span>);</span><br><span class="line"><span class="number">2019</span><span class="number">-06</span><span class="number">-09</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (4)求当月最后一天日期</span></span><br><span class="line"><span class="keyword">select</span> last_day(<span class="string">'2019-02-10'</span>);</span><br><span class="line"><span class="number">2019</span><span class="number">-02</span><span class="number">-28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 求上个月</span></span><br><span class="line"><span class="keyword">select</span> substr(add_months(<span class="built_in">current_date</span>(),<span class="number">-1</span>),<span class="number">1</span>,<span class="number">7</span>) method_one</span><br><span class="line">, substr(date_sub(from_unixtime(unix_timestamp()), dayofmonth(from_unixtime(unix_timestamp()))), <span class="number">1</span>, <span class="number">7</span>) <span class="keyword">as</span> method_two</span><br></pre></td></tr></tbody></table></figure>
<h3 id="时区">时区</h3>
<p>格林威治时间（Greenwich Mean Time，简称GMT）是世界上最常用的时间标准之一。它以英国伦敦的格林威治皇家天文台为参考点，用于标定全球的时间。格林威治时间通常用作协调世界时（Coordinated Universal Time，简称UTC）的基准，因此这两个术语通常是互换使用的</p>
<p><strong>UTC的时间戳，在全球任何一个地点，都是一个值，是一个13位的数字</strong>，小明在纽约，小红在上海，小蓝在格林威治天文台，他们三个在同一个时刻，得到的时间戳是一致的。只是在各自在不同的时区，换算当地的时区的时间表现形式不一致，如下的这个例子中</p>
<figure class="highlight tex"><table><tbody><tr><td class="code"><pre><span class="line">时间戳: 1694682379271</span><br><span class="line">纽约时间: 2023-09-14 05:06:19</span><br><span class="line">GMT<span class="built_in">&amp;</span>UTC时间: 2023-09-14 09:06:19</span><br><span class="line">北京时间: 2023-09-14 17:06:19</span><br></pre></td></tr></tbody></table></figure>
<p>以下的hive，impala语法</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 用于将【指定时区的时间】转换为 【UTC（协调世界时）时间】。这个函数接受两个参数：【要转换的时间】和【源时区】</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> to_utc_timestamp(<span class="string">'2023-09-14 17:06:19'</span>, <span class="string">'Asia/Shanghai'</span>)  <span class="keyword">as</span>  `将输入时区对应的时间转为GMT时间`;</span><br><span class="line"><span class="number">2023</span><span class="number">-09</span><span class="number">-14</span> <span class="number">09</span>:<span class="number">06</span>:<span class="number">19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用于将【UTC时区的时间】转换为【目标时区的时间】。这个函数接受两个参数：【UTC时区的时间】和【目标时区】</span></span><br><span class="line"><span class="keyword">SELECT</span> from_utc_timestamp(<span class="string">'2023-09-14 09:06:19'</span>, <span class="string">'Asia/Shanghai'</span>)  <span class="keyword">as</span>  `将UTC时区对应的时间转为目标时区`;</span><br><span class="line"><span class="number">2023</span><span class="number">-09</span><span class="number">-14</span> <span class="number">17</span>:<span class="number">06</span>:<span class="number">19</span></span><br><span class="line"><span class="keyword">SELECT</span> from_unixtime(unix_timestamp()) <span class="keyword">as</span> `UTC时间<span class="operator">&amp;</span>GMT时间`</span><br><span class="line">     , <span class="built_in">current_timestamp</span>()             <span class="keyword">as</span> `返回东八区`</span><br><span class="line">     , unix_timestamp()                <span class="keyword">as</span> `返回时间戳`</span><br></pre></td></tr></tbody></table></figure>
<p>下图可以发现 <code>hive 3</code>  中 <code>from_unixtime</code> 函数并没有根据本地的时区进行时间的转化，而是直接使用UTC的时区，而 <code>impala</code> 对时区做了转换</p>
<p align="center">
  <img src="/2023/10/01/Hive/27.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> impala和hive3时区对比 </span>
</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 将北京时间转为巴西时间</span></span><br><span class="line"><span class="keyword">select</span> from_utc_timestamp(to_utc_timestamp("2021-05-09 22:14:30",<span class="string">'GMT+8'</span>),"GMT-3")</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-09</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">30.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> date_format(from_utc_timestamp(to_utc_timestamp("2021-05-09 22:14:30",<span class="string">'GMT+8'</span>),"GMT-3"),<span class="string">'yyyy-MM-dd HH:mm:ss'</span>)</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-09</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">30</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="字符串处理">字符串处理</h3>
<p><code>substr</code>，<code>replace</code>等就不赘述了</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 1)</span></span><br><span class="line"><span class="keyword">select</span> regexp_extract(<span class="string">'http://a.m.taobao.com/i41915173660.html'</span>, <span class="string">'i([0-9]+)'</span>, <span class="number">0</span>)</span><br><span class="line">     , regexp_extract(<span class="string">'http://a.m.taobao.com/i41915173660.html'</span>, <span class="string">'i([0-9]+)'</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">-- i41915173660    ,   41915173660</span></span><br><span class="line"><span class="comment">-- 0是显示与之匹配的整个字符串； 1是显示第一个括号里面的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2)</span></span><br><span class="line"><span class="keyword">select</span>  regexp_replace(<span class="string">'a1b2c3d4'</span>, <span class="string">'[0-9]'</span>, <span class="string">'-'</span>);</span><br><span class="line"><span class="comment">-- a-b-c-d-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3)</span></span><br><span class="line"><span class="comment">-- 某字符串是另外一个字符串的子串</span></span><br><span class="line">instr(string string, string substring)</span><br><span class="line"><span class="comment">-- 返回查找字符串string中子字符串substring出现的位置，如果查找失败将返回0，如果任一参数为Null将返回null，位置为从1开始。</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="除数为0处理">除数为0处理</h3>
<p>这里我们将比较不同的引擎是如何处理<strong>除数为0</strong>的问题的，如下图：</p>
<p align="center">
  <img src="/2023/10/01/Hive/13.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 不同引擎除0的结果比对 </span>
</p>
<blockquote>
<p>对于除数为0问题，优先使用<code>nullif(a,0)</code>函数来进行处理，但是该函数Hive2.2才有对应实现，<code>nullif((a,b)</code> 的语义在于，如果参数 a 等于 参数 b 那么，该函数返回 <code>null</code></p>
</blockquote>
<h2 id="第二部分">第二部分</h2>
<h3 id="sum-over">sum()  + over()</h3>
<p align="center">
  <img src="/2023/10/01/Hive/6.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 不同引擎除0的结果比对 </span>
</p>
<blockquote>
<ul class="lvl-1">
<li class="lvl-2">
<p>over() 全局求和</p>
</li>
<li class="lvl-2">
<p>over(order by) 全局累积求和</p>
</li>
<li class="lvl-2">
<p>over(partition by ) 分区内全局求和</p>
</li>
<li class="lvl-2">
<p>over(partition by order by) 分区内累积求和</p>
</li>
</ul>
</blockquote>
<p>内网环境下，下面的脚本分别在 impala，hive，holo，pg , mysql ,执行以下，看下是什么情况</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="string">'a'</span> <span class="keyword">as</span> a,<span class="number">1</span> <span class="keyword">as</span> b </span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'a'</span> <span class="keyword">as</span> a , <span class="number">2</span> <span class="keyword">as</span> b</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span> </span><br><span class="line">    <span class="keyword">select</span> <span class="string">'b'</span> <span class="keyword">as</span> b , <span class="number">10</span> <span class="keyword">as</span> b</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> a , </span><br><span class="line">     <span class="built_in">avg</span>(b) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> b) x ,</span><br><span class="line">     <span class="built_in">sum</span>(b) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> b) y</span><br><span class="line"><span class="keyword">from</span> tmp1 </span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>
<p>关于聚合函数+窗口函数的描述，<a href="https://www.geeksforgeeks.org/window-functions-in-sql/">GreeksforGreeks上的那个博文是错的</a></p>
<h3 id="侧写视图-lateral-view">侧写视图(lateral view)</h3>
<p>🎈<code>explode(split())</code> 只能用来解决一行转多列的单字段问题，侧写视图主要用来处理，通用行转列的问题</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- hive 语法</span></span><br><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="string">'A;B;C'</span> <span class="keyword">as</span> name , <span class="number">20</span> <span class="keyword">as</span> age</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> explode(split(name,<span class="string">';'</span>))</span><br><span class="line">         , age <span class="comment">-- Only a single expression in the SELECT clause is supported with UDTF's </span></span><br><span class="line">         <span class="comment">-- 如果是多列，使用测斜视图语法</span></span><br><span class="line"><span class="keyword">from</span> tmp1</span><br><span class="line">;</span><br><span class="line"><span class="comment">-- 如下（hive语法）</span></span><br><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="string">'A;B;C'</span> <span class="keyword">as</span> name , <span class="number">20</span> <span class="keyword">as</span> age</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> name </span><br><span class="line">     , age </span><br><span class="line">     , col_x</span><br><span class="line"><span class="keyword">from</span> tmp1 <span class="keyword">lateral</span> <span class="keyword">view</span> explode(split(name,<span class="string">';'</span>)) x <span class="keyword">as</span> col_x</span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
<th>col_x</th>
</tr>
</thead>
<tbody>
<tr>
<td>A;B;C</td>
<td>20</td>
<td>A</td>
</tr>
<tr>
<td>A;B;C</td>
<td>20</td>
<td>B</td>
</tr>
<tr>
<td>A;B;C</td>
<td>20</td>
<td>C</td>
</tr>
</tbody>
</table>
<center>该表格可左右移动</center>
<h3 id="lag-over的使用">lag+over的使用</h3>
<p>其中最为常用的是：**按照时间正序排序，<code>lag</code>获取上个周期的值  **</p>
<p align="center">
  <img src="/2023/10/01/Hive/8.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> lag + over 的使用 </span>
</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>lag （落后）是获取上一个</p>
</li>
<li class="lvl-2">
<p>lead （领导）是获取下一个</p>
</li>
</ul>
<p align="center">
  <img src="/2023/10/01/Hive/21.png" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> SQL（StructuredQueryLanguage）标准认为当前行的上一个行是后面，下一行是前面 </span>
</p>
<h3 id="一周内连续3天活跃">一周内连续3天活跃</h3>
<p align="center">
  <img src="/2023/10/01/Hive/14.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 一周连续X天活跃的最佳解法 </span>
</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="number">0</span> <span class="keyword">as</span> mid_id,<span class="string">'2020-02-12'</span> <span class="keyword">as</span> dt <span class="keyword">union</span>  <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">0</span> <span class="keyword">as</span> mid_id,<span class="string">'2020-02-16'</span> <span class="keyword">as</span> dt  <span class="keyword">union</span>  <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">0</span> <span class="keyword">as</span> mid_id,<span class="string">'2020-02-17'</span> <span class="keyword">as</span> dt  <span class="keyword">union</span>  <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">0</span> <span class="keyword">as</span> mid_id,<span class="string">'2020-02-18'</span> <span class="keyword">as</span> dt  <span class="keyword">union</span>  <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">as</span> mid_id,<span class="string">'2020-02-11'</span> <span class="keyword">as</span> dt  <span class="keyword">union</span>  <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">as</span> mid_id,<span class="string">'2020-02-13'</span> <span class="keyword">as</span> dt  <span class="keyword">union</span>  <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">as</span> mid_id,<span class="string">'2020-02-14'</span> <span class="keyword">as</span> dt  <span class="keyword">union</span>  <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">1</span> <span class="keyword">as</span> mid_id,<span class="string">'2020-02-17'</span> <span class="keyword">as</span> dt</span><br><span class="line">) ,</span><br><span class="line">tmp2 <span class="keyword">as</span> (</span><br><span class="line">         <span class="keyword">select</span> mid_id</span><br><span class="line">            , dt</span><br><span class="line">            , <span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> mid_id <span class="keyword">order</span> <span class="keyword">by</span> dt)               rk</span><br><span class="line">            , date_sub(dt, <span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> mid_id <span class="keyword">order</span> <span class="keyword">by</span> dt)) diff</span><br><span class="line">       <span class="keyword">from</span> tmp1</span><br><span class="line">       <span class="keyword">where</span> dt <span class="keyword">between</span> date_sub(<span class="string">'2020-02-18'</span>, <span class="number">7</span>) <span class="keyword">and</span> <span class="string">'2020-02-18'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> mid_id</span><br><span class="line"><span class="keyword">from</span> tmp2</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> mid_id,diff</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span><span class="number">3</span> ;</span><br></pre></td></tr></tbody></table></figure>
<p>对于类似的连续X天的问题，最优的解决方案是使用开窗函数，另外的一种解题思路是<strong>自关联</strong>，关联时，使用 <code>t1.mid_id = t2.mid_id and t1.dt = date_sub(t2.dt,x)</code>的方式</p>
<h3 id="left-semi-join">left semi join</h3>
<p>关于<code>left semi join</code> 注意2点：</p>
<p>🅰️<code>left semi join</code> 要严格区分于<code>left outer join(left join)</code></p>
<p>🅱️ <code>t1 left semi join t2 </code> 选列时，不允许出现t2 的字段</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.id, t1.fieldA</span><br><span class="line"><span class="keyword">from</span> `table_A` t1</span><br><span class="line"><span class="keyword">where</span> t1.id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> id</span><br><span class="line">    <span class="keyword">from</span> `table_B`</span><br><span class="line">); <span class="comment">-- A 和 B的 交集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可改写为exists的方式</span></span><br><span class="line"><span class="keyword">select</span> t1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `table_A` t1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> t2.id</span><br><span class="line">    <span class="keyword">from</span> `table_B` t2</span><br><span class="line">    <span class="keyword">where</span> t1.id <span class="operator">=</span> t2.id</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 还可改写为</span></span><br><span class="line"><span class="keyword">select</span> t1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `table_A` t1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> `table_B` t2</span><br><span class="line"><span class="keyword">on</span> t1.id <span class="operator">=</span> t2.id</span><br><span class="line"><span class="keyword">where</span> t2.id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="comment">-- A 和 B 的交集</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改写为 ，这种方式更加高效</span></span><br><span class="line"><span class="keyword">select</span> t1.<span class="operator">*</span> <span class="comment">-- 不允许出现t2 的字段</span></span><br><span class="line"><span class="keyword">from</span> `table_A` t1</span><br><span class="line"><span class="keyword">left</span> semi <span class="keyword">join</span> `table_B` t2</span><br><span class="line"><span class="keyword">on</span> t1.id <span class="operator">=</span> t2.id;</span><br></pre></td></tr></tbody></table></figure>
<p>同理对于<code>not  exist</code></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `table_A` t1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> `table_B` t2</span><br><span class="line"><span class="keyword">on</span> t1.id <span class="operator">=</span> t2.id</span><br><span class="line"><span class="keyword">where</span> t2.id <span class="keyword">is</span>  <span class="keyword">null</span> <span class="comment">-- A中有B中没有</span></span><br><span class="line">;</span><br><span class="line"><span class="comment">-- 我们换成下面的写法</span></span><br><span class="line"><span class="keyword">select</span> t1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `table_A` t1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> t2.id</span><br><span class="line">    <span class="keyword">from</span> `table_B` t2</span><br><span class="line">    <span class="keyword">where</span> t1.id <span class="operator">=</span> t2.id</span><br><span class="line">) <span class="comment">-- A中有B中没有</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者换成下面的写法</span></span><br><span class="line"><span class="keyword">select</span> t1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `table_A` t1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> t2.id</span><br><span class="line">    <span class="keyword">from</span> `table_B` t2</span><br><span class="line">    <span class="keyword">where</span> t1.id <span class="operator">=</span> t2.id</span><br><span class="line">) <span class="comment">-- A中有B中没有</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="distinct">distinct</h3>
<h4 id="🅰️-distinct-和-order-by-的结合">🅰️ distinct 和 order by 的结合</h4>
<p>先执行distinct ，后执行order by ，最后limit</p>
<p align="center">
  <img src="/2023/10/01/Hive/3.jpg" width="50%" alt="Your image description">
    <br>
  <span style="color:gray"> 先执行 distinct ，后执行 order by </span>
</p>
<h4 id="🅱️-distinct-多个字段">🅱️ distinct 多个字段</h4>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">distinct` 多个字段对所有字段都起作用，并不是一个；如 `select distinct field_a,field_b from table;</span><br><span class="line">a1,b1;</span><br><span class="line">a1,b2;</span><br><span class="line">a2,b2;</span><br><span class="line">-- 只要有不同就会被选择出来</span><br></pre></td></tr></tbody></table></figure>
<h3 id="limit-offset">limit offset</h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">limit x offset y` ,$y$是$x$的倍数出现，可以恰好将数据取完，`limit x offset y` 等效于 `limit y,x</span><br></pre></td></tr></tbody></table></figure>
<p align="center">
  <img src="/2023/10/01/Hive/15.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> limit 的用法 </span>
</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="number">1</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">2</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">3</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">4</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">5</span> a</span><br><span class="line">) t</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> a <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">3</span> <span class="keyword">offset</span> <span class="number">3</span>; </span><br></pre></td></tr></tbody></table></figure>
<p>最后一个截图的SQL语句，我在Hive2.1.1中的执行结果是：</p>
<p align="center">
  <img src="/2023/10/01/Hive/24.png" width="70%" alt="Your image description">
    <br>
  <span style="color:gray">24 </span>
</p>
<p>说明在Hive中<code>offset</code>的排序是从1开始的（x取0等于x=1）</p>
<h3 id="ntile-over">ntile+over</h3>
<p><code>ntile(x)</code>将数据划均分为x个桶，并且返回桶编号，如果有多的元素，优先进入第一个桶</p>
<p align="center">
  <img src="/2023/10/01/Hive/22.png" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 使用nile将数据均分到x桶内 </span>
</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="string">'a'</span> <span class="keyword">as</span> name , <span class="string">'one'</span> <span class="keyword">as</span> claz, <span class="number">1</span> <span class="keyword">as</span> score <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'b'</span> <span class="keyword">as</span> name , <span class="string">'two'</span> <span class="keyword">as</span> claz, <span class="number">2</span> <span class="keyword">as</span> score <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'c'</span> <span class="keyword">as</span> name , <span class="string">'two'</span> <span class="keyword">as</span> claz, <span class="number">3</span> <span class="keyword">as</span> score <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'d'</span> <span class="keyword">as</span> name , <span class="string">'one'</span> <span class="keyword">as</span> claz, <span class="number">4</span> <span class="keyword">as</span> score <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'e'</span> <span class="keyword">as</span> name , <span class="string">'one'</span> <span class="keyword">as</span> claz, <span class="number">5</span> <span class="keyword">as</span> score <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'f'</span> <span class="keyword">as</span> name , <span class="string">'two'</span> <span class="keyword">as</span> claz, <span class="number">6</span> <span class="keyword">as</span> score <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'g'</span> <span class="keyword">as</span> name , <span class="string">'one'</span> <span class="keyword">as</span> claz, <span class="number">7</span> <span class="keyword">as</span> score <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'h'</span> <span class="keyword">as</span> name , <span class="string">'one'</span> <span class="keyword">as</span> claz, <span class="number">8</span> <span class="keyword">as</span> score <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'i'</span> <span class="keyword">as</span> name , <span class="string">'two'</span> <span class="keyword">as</span> claz, <span class="number">9</span> <span class="keyword">as</span> score <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'j'</span> <span class="keyword">as</span> name , <span class="string">'two'</span> <span class="keyword">as</span> claz, <span class="number">0</span> <span class="keyword">as</span> score</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">     , <span class="built_in">ntile</span>(<span class="number">2</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> claz <span class="keyword">order</span> <span class="keyword">by</span> score) rn</span><br><span class="line"><span class="keyword">from</span> tmp1;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="模糊匹配多个字段">模糊匹配多个字段</h3>
<img src="/2023/10/01/Hive/23-6152215.png" width="100%" height="25%" alt="图片名称" align="left">
<p>在hive或者是impala种，或者使用 <code>rlike</code>：其作用在于<strong>模糊匹配多个值</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- hive &amp; impala</span></span><br><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="string">'abc大'</span> <span class="keyword">as</span> a <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'中abc'</span> <span class="keyword">as</span> a <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'abc小'</span> <span class="keyword">as</span> a</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tmp1</span><br><span class="line"><span class="comment">-- where a rlike '大|中' -- 写法1</span></span><br><span class="line"><span class="keyword">where</span> a regxp <span class="string">'大|中'</span>    <span class="comment">-- 写法2</span></span><br><span class="line"><span class="comment">-- 中abc</span></span><br><span class="line"><span class="comment">-- abc大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- holo &amp; pg</span></span><br><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="string">'abc大'</span> <span class="keyword">as</span> a <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'中abc'</span> <span class="keyword">as</span> a <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'abc小'</span> <span class="keyword">as</span> a</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tmp1</span><br><span class="line"><span class="keyword">where</span> a <span class="operator">~</span> <span class="string">'大|中'</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="窗口函数的范围选择">窗口函数的范围选择</h3>
<p>注意 <code>range</code> 和<code>rows</code>之间的使用区别：  <strong>rows计算的是行，range 计算的是值</strong>， preceding 往上，following 往下</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">agg_func <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> col_name <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> proceding <span class="keyword">and</span> <span class="number">1</span> following) <span class="comment">-- col_name的前后1行</span></span><br><span class="line">agg_func <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> col_name <span class="keyword">range</span> <span class="keyword">between</span> <span class="number">1</span> proceding <span class="keyword">and</span> <span class="number">1</span> following) <span class="comment">-- col_name值的(+/- 1) 的值</span></span><br><span class="line"></span><br><span class="line">agg_func <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> col_name <span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> unbounded following) <span class="comment">-- 全部行</span></span><br><span class="line">agg_func <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> col_name <span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>) <span class="comment">-- 开头到当前行</span></span><br></pre></td></tr></tbody></table></figure>
<p align="center">
  <img src="/2023/10/01/Hive/19.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 窗口函数的选择范围 </span>
</p>
<img src="/2023/10/01/Hive/20-6152215.png" width="100%" height="100%" alt="图片名称" align="left/">
<h2 id="第三部分">第三部分</h2>
<h3 id="select-非-group-by-字段">select 非 group by 字段</h3>
<p><strong>MySQL支持</strong>，Hive,Impala,PostgreSQL 不支持</p>
<p>对于下面这一段SQL</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dept</span><br><span class="line">     , emp</span><br><span class="line">     , <span class="built_in">max</span>(sal) <span class="keyword">as</span> max_sal</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="string">'A'</span> <span class="keyword">as</span> dept, <span class="string">'a1'</span> <span class="keyword">as</span> emp, <span class="number">10</span> <span class="keyword">as</span> sal <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'A'</span> <span class="keyword">as</span> dept, <span class="string">'a2'</span> <span class="keyword">as</span> emp, <span class="number">20</span> <span class="keyword">as</span> sal <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'B'</span> <span class="keyword">as</span> dept, <span class="string">'b2'</span> <span class="keyword">as</span> emp, <span class="number">100</span> <span class="keyword">as</span> sal <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'B'</span> <span class="keyword">as</span> dept, <span class="string">'b1'</span> <span class="keyword">as</span> emp, <span class="number">200</span> <span class="keyword">as</span> sal</span><br><span class="line">) t</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept</span><br></pre></td></tr></tbody></table></figure>
<p>1️⃣MySQL 通过</p>
<p align="center">
  <img src="/2023/10/01/Hive/5.jpg" width="50%" alt="Your image description">
    <br>
  <span style="color:gray"> mysql select 非 group by 的字段 </span>
</p>
<p>MySQL 选择记录中的第一个记录(从实验结果来看，是记录的第一行)</p>
<p>2️⃣ postgreSQL：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="number">42803</span>] ERROR: <span class="keyword">column</span> "t.emp" must appear <span class="keyword">in</span> the <span class="keyword">GROUP</span> <span class="keyword">BY</span> clause <span class="keyword">or</span> be used <span class="keyword">in</span> an aggregate <span class="keyword">function</span></span><br></pre></td></tr></tbody></table></figure>
<p>3️⃣ Hive：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">Error while compiling statement: FAILED: SemanticException [Error <span class="number">10025</span>]: line <span class="number">2</span>:<span class="number">7</span> Expression <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> key <span class="string">'emp'</span></span><br></pre></td></tr></tbody></table></figure>
<p>4️⃣ Impala：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">AnalysisException: <span class="keyword">select</span> list expression <span class="keyword">not</span> produced <span class="keyword">by</span> aggregation output (missing <span class="keyword">from</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> clause?): emp</span><br></pre></td></tr></tbody></table></figure>
<h3 id="having-过滤是否支持别名">having 过滤是否支持别名</h3>
<p>MySQL和Hive是支持的， impala和postgreSQL不支持，🎈：<strong>推荐无论何时都不使用别名进行分组后过滤</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="number">5</span> <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">4</span> <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">4</span> <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">3</span> <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">3</span> <span class="keyword">as</span> a</span><br><span class="line">) t</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a</span><br><span class="line"><span class="keyword">having</span> cnt <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>上述的SQL在MySQL 和 hive中执行都是没问题的，在impala和postgreSQL报错 <code>column "cnt" does not exist</code>,需要下面的写法</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="number">5</span> <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">4</span> <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">4</span> <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">3</span> <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="number">3</span> <span class="keyword">as</span> a</span><br><span class="line">) t</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="order-by-字符串">order by 字符串</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span>  <span class="string">'a'</span> <span class="keyword">as</span> a <span class="keyword">union</span> <span class="keyword">all</span>  <span class="comment">-- 97</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">''</span> <span class="keyword">as</span> a <span class="keyword">union</span> <span class="keyword">all</span>    <span class="comment">-- 66</span></span><br><span class="line">    <span class="keyword">select</span>  <span class="string">' '</span> <span class="keyword">as</span> a <span class="keyword">union</span> <span class="keyword">all</span>  <span class="comment">-- 32</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">null</span> <span class="keyword">as</span> a            <span class="comment">-- 0</span></span><br><span class="line">) t</span><br><span class="line"><span class="keyword">order</span>  <span class="keyword">by</span> a <span class="keyword">desc</span> ;</span><br></pre></td></tr></tbody></table></figure>
<p>对于以上查询和排序，Hive和MySQL认为NULL是最小；Impala和PostgresSQL认为NULL最大，如果使用<code>explain</code>命令查看SQL的执行计划的话，会明显看到编译器会给SQL添加1个<code>null first / null last</code>的明亮，这个取决于具体的引擎，感兴趣的读者可以自己test下，比如Hive会将null设为最小，impala会将null设为最大</p>
<p align="center">
  <img src="/2023/10/01/Hive/10.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> null，空串，空格 之间的排序关系</span>
</p>
<h3 id="24-5-的结果">$24/5$的结果</h3>
<table>
<thead>
<tr>
<th>DB/Program Language</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java / PostgreSQL</td>
<td>4</td>
</tr>
<tr>
<td>Hive / Impala / MySQL</td>
<td>4.8</td>
</tr>
</tbody>
</table>
<h3 id="窗口函数是否支持distinct">窗口函数是否支持<code>distinct</code></h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  A, B , <span class="built_in">count</span>( <span class="keyword">distinct</span> A) <span class="keyword">over</span>()</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="number">1</span> <span class="keyword">as</span> A ,<span class="string">'a'</span> <span class="keyword">as</span> B <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">2</span> <span class="keyword">as</span> A ,<span class="string">'b'</span> <span class="keyword">as</span> B <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">1</span> <span class="keyword">as</span> A ,<span class="string">'c'</span> <span class="keyword">as</span> B <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">3</span> <span class="keyword">as</span> A ,<span class="string">'d'</span> <span class="keyword">as</span> B</span><br><span class="line">) t</span><br></pre></td></tr></tbody></table></figure>
<p>比如以上的SQL查询：Hive是支持的，Impala，MySQL，PostgreSQL暂时没有实现</p>
<h3 id="窗口嵌套">窗口嵌套</h3>
<p>窗口函数的嵌套，只Hive<sub>2.1.1</sub>中是支持的，PostgreSQL(<code>window functions are not allowed in window definitions</code>)，MySQL，Impala 中只能多嵌套一层</p>
<p align="center">
  <img src="/2023/10/01/Hive/17.jpg" width="80%" alt="Your image description">
    <br>
  <span style="color:gray"> 不同的引擎对于窗口嵌套的支持 </span>
</p>
<h3 id="字符串写入数值类型">字符串写入数值类型</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span>  business (</span><br><span class="line">    name strng,</span><br><span class="line">    order_date string,</span><br><span class="line">    cost <span class="type">float</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> business <span class="keyword">values</span>(<span class="string">'xioaming'</span>,<span class="string">'2021-08-22'</span>,<span class="string">''</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>Hive 会将字符串转为<code>null</code>写入；Impala，MySQL，PostgreSQL会进行类型检查异常</p>
<h3 id="字段截取">字段截取</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- MySql</span></span><br><span class="line"><span class="keyword">select</span> substring_index(substring_index(<span class="string">'A/B/C/D/E'</span>, <span class="string">'/'</span>, <span class="number">4</span>), <span class="string">'/'</span>, <span class="number">-1</span>) <span class="keyword">as</span> dept_name0 <span class="comment">-- D</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- hive，索引从0开始</span></span><br><span class="line"><span class="keyword">select</span> substring_index(substring_index(<span class="string">'A/B/C/D/E'</span>, <span class="string">'/'</span>, <span class="number">4</span>), <span class="string">'/'</span>, <span class="number">-1</span>) <span class="keyword">as</span> dept_name0 <span class="comment">-- D</span></span><br><span class="line">     , split(<span class="string">'A/B/C/D/E'</span>, <span class="string">'/'</span>)[<span class="number">3</span>]                                     <span class="keyword">as</span> dept_name1 <span class="comment">-- D</span></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line"><span class="comment">-- pg/holo 索引从1开始</span></span><br><span class="line"><span class="keyword">select</span> split_part(<span class="string">'A/B/C/D/E'</span>, <span class="string">'/'</span>,<span class="number">4</span>)                                <span class="keyword">as</span> dept_name1 <span class="comment">-- D</span></span><br><span class="line"><span class="comment">-- impala 索引从1开始</span></span><br><span class="line"><span class="keyword">select</span> split_part(<span class="string">'A/B/C/D/E'</span>, <span class="string">'/'</span>,<span class="number">4</span>)                                <span class="keyword">as</span> dept_name1 <span class="comment">-- D、</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其中，holo存在以下函数</span></span><br><span class="line"><span class="keyword">select</span> string_to_array(<span class="string">'xx~^~yy~^~zz'</span>, <span class="string">'~^~'</span>)           <span class="comment">-- {xx,yy,zz}</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="column-name-not-in-a-会过滤掉-null-的记录"><code>column_name not in (a)</code> 会过滤掉 <code>null</code> 的记录</h3>
<p><code>column_name not in (a)</code>： 出了会过滤掉值为<code>a</code>的记录，还会过滤掉 <code>column_name</code>为 <code>null</code> 的记录</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span> (<span class="comment">-- </span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'a'</span> <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'b'</span> <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'c'</span> <span class="keyword">as</span> a</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">null</span> <span class="keyword">as</span> a</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tmp1</span><br><span class="line"><span class="keyword">where</span> a <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">-- 结果返回 a,c</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="Impala-的模糊关联（非等值关联）"><code>Impala</code> 的模糊关联（非等值关联）</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- t2.name 是 t1.name 的子串的时候即返回 true ，注意顺序</span></span><br><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span> ( <span class="comment">--</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'康恩贝/CONBA'</span> <span class="keyword">as</span> name, <span class="string">'2023-01-01'</span> <span class="keyword">as</span> live_date</span><br><span class="line">)</span><br><span class="line">   , tmp2 <span class="keyword">as</span> ( <span class="comment">--</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'CONBA'</span> <span class="keyword">as</span> name, <span class="string">'2023-01-01'</span> <span class="keyword">as</span> live_date</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tmp1      t1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tmp2 t2</span><br><span class="line">          <span class="keyword">on</span> t1.live_date <span class="operator">=</span> t2.live_date</span><br><span class="line">              <span class="keyword">and</span> t1.name rlike t2.name</span><br></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">name</th>
<th style="text-align:left">live_date</th>
<th style="text-align:left">name</th>
<th style="text-align:left">live_date</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">康恩贝/CONBA</td>
<td style="text-align:left">2023-01-01</td>
<td style="text-align:left">CONBA</td>
<td style="text-align:left">2023-01-01</td>
</tr>
</tbody>
</table>
<h2 id="第四部分">第四部分</h2>
<h3 id="null-x-关联"><code>null</code>,<code>x</code> 关联</h3>
<p align="center">
  <img src="/2023/10/01/Hive/11.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> null 和其他值的关联 </span>
</p>
<p>在任何 <code>SQL(MySQL,PostgreSQL,Hive,Impala) </code>引擎中，<strong><code>null</code>和任意值都无法关联无法相互关联，包括其本身</strong></p>
<blockquote>
<p>PostgreSQL中有类型探测，执行以上关联会发生：<a href="https://stackoverflow.com/questions/18073901/failed-to-find-conversion-function-from-unknown-to-text">Failed to find conversion function from unknown to text</a></p>
</blockquote>
<h3 id="返回1行-返回0行">返回1行&amp;返回0行</h3>
<p><strong>使用聚合函数，返回的行数一定大于等于1</strong></p>
<p align="center">
  <img src="/2023/10/01/Hive/16.png" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 返回0行和返回1行 </span>
</p>
<h3 id="union-all-的类型">union all 的类型</h3>
<p><strong>任何引擎，<code>union all</code>的类型必须保持一致</strong></p>
<h3 id="组合主键非null">组合主键非<code>null</code></h3>
<p>对于<code>test01</code>表，字段<code>a</code>和字段<code>b</code>在作为联合主键时，在字段<code>a</code>为<code>null</code>，字段<code>b</code>非<code>null</code>的时候</p>
<p>1️⃣<code>kudu</code>将不会写入该记录，不会抛异常，<strong>导致写入数据和查询数据记录数不一致</strong></p>
<p>2️⃣<code>MySql</code>插入时抛出异常 类似(<code>primary key not null</code>)</p>
<p>3️⃣<code>postgresql</code> 插入时抛出异常 类似(<code>primary key not null</code>)</p>
<h3 id="时间戳">时间戳</h3>
<p>⚠️时间是人可识别的，时间戳基本是机器识别的，比如2022-01-01 00:00:00（1640966400），前者是时间，后者是时间戳，几乎所有的引擎都实现了 <code>unix_timestamp</code>方法，支持传入一个时间，如果没有传入时间将使用当前的时刻</p>
<p>1️⃣ 获取时间戳</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">--mysql</span></span><br><span class="line"><span class="keyword">select</span> unix_timestamp(<span class="string">'2022-01-01 00:00:00'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- hive </span></span><br><span class="line"><span class="keyword">select</span> unix_timestamp(<span class="string">'2022-01-01 00:00:00'</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>2️⃣获取时间</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- mysql</span></span><br><span class="line"><span class="keyword">select</span> now();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- hive</span></span><br><span class="line"><span class="keyword">select</span> from_unixtime( unix_timestamp());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- impala</span></span><br><span class="line"><span class="keyword">select</span> now(),  utc_timestamp(),<span class="built_in">current_timestamp</span>(),from_unixtime( unix_timestamp());</span><br><span class="line"></span><br><span class="line"><span class="comment">-- pg</span></span><br><span class="line"><span class="keyword">select</span>  now() ,  <span class="built_in">current_timestamp</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="去掉文本中的换行符-回车符-制表符-空格，正则替换">去掉文本中的换行符/回车符/制表符/空格，正则替换</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- \s 表示匹配一个或者多个空白字符（包括空格、制表符、换行符）， '+' 表示匹配前面的模式（即'\s'）一次或多次 </span></span><br><span class="line"><span class="keyword">select</span> regexp_replace(input_content,<span class="string">'\\s+'</span>,<span class="string">''</span>) <span class="keyword">as</span> after_content</span><br><span class="line"><span class="comment">-- hive</span></span><br><span class="line"><span class="keyword">select</span> regexp_replace(video_desc,<span class="string">'\t|\n|\001|\r'</span>,<span class="string">''</span>) <span class="keyword">as</span> video_desc</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mysql5.7中不支持regexp_replace，8.0中支持，所以在5.7中使用</span></span><br><span class="line"><span class="keyword">select</span> replace(replace(video_desc, <span class="type">char</span>(<span class="number">13</span>), <span class="string">''</span>), <span class="type">char</span>(<span class="number">10</span>), <span class="string">''</span>) <span class="keyword">as</span> video_desc</span><br><span class="line"><span class="keyword">select</span> <span class="string">'1\r2\t\3\n4\0015'</span></span><br><span class="line">    ,regexp_replace(<span class="string">'1\r2\t\3\n4'</span>,<span class="string">'\\s+'</span>,<span class="string">''</span>)</span><br><span class="line">    ,regexp_replace(<span class="string">'1     \r2\t\3\n4\0015'</span>,<span class="string">'\\s+'</span>,<span class="string">''</span>)</span><br><span class="line">    ,regexp_replace(<span class="string">'1     \r2\t\3\n4\0015'</span>,<span class="string">'\t|\n|\001|\r'</span>,<span class="string">''</span>)</span><br></pre></td></tr></tbody></table></figure>
<p align="center">
  <img src="/2023/10/01/Hive/18.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 由于特殊字符导致表错位串行的问题描述 </span>
</p>
<h3 id="impala-upsert-Kudu">impala upsert + Kudu</h3>
<p>本质是<code>insert</code>  + <code>update</code> 的结合</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>主键存在时，<strong>全字段</strong>更新</p>
</li>
<li class="lvl-2">
<p>主键不存在时，插入</p>
</li>
</ul>
<h3 id="不使用order-by-找到工资第二的员工">不使用<code>order by</code> 找到工资第二的员工</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    e.emp_no,</span><br><span class="line">    salary,</span><br><span class="line">    last_name,</span><br><span class="line">    first_name</span><br><span class="line"><span class="keyword">from</span> employees e</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> salaries s</span><br><span class="line"><span class="keyword">on</span> e.emp_no <span class="operator">=</span> s.emp_no</span><br><span class="line"><span class="keyword">where</span> s.to_date <span class="operator">=</span> <span class="string">'9999-01-01'</span> </span><br><span class="line"><span class="keyword">and</span> s.salary <span class="operator">=</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> s1.salary</span><br><span class="line">    <span class="keyword">from</span> salaries s1</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> salaries s2</span><br><span class="line">    <span class="keyword">on</span> s1.salary <span class="operator">&lt;=</span> s2.salary</span><br><span class="line">    <span class="keyword">where</span> s1.to_date <span class="operator">=</span> <span class="string">'9999-01-01'</span> <span class="keyword">and</span> s2.to_date <span class="operator">=</span> <span class="string">'9999-01-01'</span> </span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> s1.salary</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> s2.salary) <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<p>最大值只能小于等于最大值（出现1次)；次大值只能小于等于最大值和本身（出现2次）</p>
<p align="center">
  <img src="/2023/10/01/Hive/4.jpg" width="30%" alt="Your image description">
    <br>
  <span style="color:gray"> 求薪资次高的员工 </span>
</p>
<h3 id="from-tmp1-tmp2-的本质">from tmp1 , tmp2 的本质</h3>
<p><strong><code>from tmp1 , tmp2</code> 的本质就是 <code>inner join</code>的行为</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span> (<span class="keyword">select</span> <span class="string">'a'</span> <span class="keyword">as</span> name, <span class="number">10</span> <span class="keyword">as</span> age</span><br><span class="line">              <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">              <span class="keyword">select</span> <span class="string">'b'</span> <span class="keyword">as</span> name, <span class="number">11</span> <span class="keyword">as</span> age</span><br><span class="line">              <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">              <span class="keyword">select</span> <span class="string">'c'</span> <span class="keyword">as</span> name, <span class="number">12</span> <span class="keyword">as</span> age</span><br><span class="line">)</span><br><span class="line">   , tmp2 <span class="keyword">as</span> (<span class="keyword">select</span> <span class="string">'c'</span> <span class="keyword">as</span> name, <span class="string">'female'</span> <span class="keyword">as</span> sex</span><br><span class="line">              <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">              <span class="keyword">select</span> <span class="string">'d'</span> <span class="keyword">as</span> name, <span class="string">'male'</span> <span class="keyword">as</span> sex</span><br><span class="line">              <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">              <span class="keyword">select</span> <span class="string">'e'</span> <span class="keyword">as</span> name, <span class="string">'female'</span> <span class="keyword">as</span> sex</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> t1.name</span><br><span class="line">     , t1.age</span><br><span class="line">     , t2.sex</span><br><span class="line"><span class="keyword">from</span> tmp1 t1</span><br><span class="line">   , tmp2 t2</span><br><span class="line"><span class="keyword">where</span> t1.name <span class="operator">=</span> t2.name</span><br></pre></td></tr></tbody></table></figure>
<p>上述的SQL等同于下列SQL</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span> (<span class="keyword">select</span> <span class="string">'a'</span> <span class="keyword">as</span> name, <span class="number">10</span> <span class="keyword">as</span> age</span><br><span class="line">              <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">              <span class="keyword">select</span> <span class="string">'b'</span> <span class="keyword">as</span> name, <span class="number">11</span> <span class="keyword">as</span> age</span><br><span class="line">              <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">              <span class="keyword">select</span> <span class="string">'c'</span> <span class="keyword">as</span> name, <span class="number">12</span> <span class="keyword">as</span> age</span><br><span class="line">)</span><br><span class="line">   , tmp2 <span class="keyword">as</span> (<span class="keyword">select</span> <span class="string">'c'</span> <span class="keyword">as</span> name, <span class="string">'female'</span> <span class="keyword">as</span> sex</span><br><span class="line">              <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">              <span class="keyword">select</span> <span class="string">'d'</span> <span class="keyword">as</span> name, <span class="string">'male'</span> <span class="keyword">as</span> sex</span><br><span class="line">              <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">              <span class="keyword">select</span> <span class="string">'e'</span> <span class="keyword">as</span> name, <span class="string">'female'</span> <span class="keyword">as</span> sex</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> t1.name, t1.age, t2.sex</span><br><span class="line"><span class="keyword">from</span> tmp1       t1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> tmp2 t2</span><br><span class="line">           <span class="keyword">on</span> t1.name <span class="operator">=</span> t2.name</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Hive-中强制-mapjoin">Hive 中强制 <code>mapjoin</code></h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="comment">/*+ mapjoin(t2)*/</span>  <span class="comment">--强制指定关联方式</span></span><br><span class="line"><span class="keyword">from</span> t1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t2 </span><br><span class="line"><span class="keyword">on</span> t1.key<span class="operator">=</span> t2.key</span><br></pre></td></tr></tbody></table></figure>
<h2 id="第四部分-2">第四部分</h2>
<p><a href="https://github.com/ifseayou/virgin-sql/blob/master/test_app.fna_compare_zhubo_stat_df.sql">ORC存储格式 和 RCFile存储格式的一个问题 - 发生 Unknow Reason问题</a></p>
<p><a href="https://github.com/ifseayou/virgin-sql/blob/master/test_app.live_goods_category_detail_df.sql">union all  + distint 的时候需要设置 <code>set hive.vectorized.execution.enabled=false;</code></a></p>
<p><a href="https://stackoverflow.com/questions/41057311/the-value-of-spark-yarn-executor-memoryoverhead-setting">spark.yarn.executor.memoryOverhead</a> ，该参数<a href="https://spark.apache.org/docs/2.2.0/running-on-yarn.html">官方地址</a>，出现这个问题提升该参数的阈值是一方面，另一方面可以增加 executor的数量，<code>set spark.dynamicAllocation.maxExecutors=14;</code></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">return code 3 from org.apache.hadoop.hive.ql.exec.spark.SparkTask. Spark job failed because of out of memory.</span><br><span class="line"></span><br><span class="line">ExecutorLostFailure (executor 10 exited caused by one of the running tasks) Reason: Container killed by YARN for exceeding memory limits. 15.3 GB of 15.3 GB physical memory used. Consider boosting spark.yarn.executor.memoryOverhead</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>spark.yarn.executor.memoryOverhead</code>是Yarn分配给 <code>executor</code> 的堆外内存</p>
</blockquote>
<figure class="highlight lua"><table><tbody><tr><td class="code"><pre><span class="line">Finished Stage<span class="number">-2</span>_0: <span class="number">1098</span>(+<span class="number">1</span>,<span class="number">-35</span>) /<span class="number">1099</span></span><br><span class="line">Finished Stage<span class="number">-2</span>_0: <span class="number">1099</span>(<span class="number">-35</span>)/<span class="number">1099</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- success/total</span></span><br><span class="line"><span class="comment">-- a(x,y)/b</span></span><br><span class="line">hive,spark的运行日志，如果a最终等于b,就是task是成功的；</span><br></pre></td></tr></tbody></table></figure>
<h3 id="如何获取月初月末">如何获取月初月末</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> trunc(date_add(<span class="built_in">current_date</span>,<span class="number">-1</span>),<span class="string">'MM'</span>) <span class="keyword">as</span> month_first_day    <span class="comment">-- hive  月初</span></span><br><span class="line"><span class="keyword">select</span> date_format(<span class="string">'2020-01-02 10:09:08'</span>,<span class="string">'yyyy-MM-01'</span>) <span class="comment">--  hive</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="built_in">current_date</span>,<span class="string">'MM'</span>)  <span class="comment">-- spark-sql ,hive</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> last_day(<span class="built_in">current_timestamp</span>()) <span class="comment">-- 月末</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="如何处理动态分区写入">如何处理动态分区写入</h3>
<ol>
<li class="lvl-3">
<p>开启非严格模式 <code>set hive.exec.dynamic.partition.mode=nonstrict</code></p>
</li>
<li class="lvl-3">
<p>动态分区写入注意partition（date_id）的字段和select 后的字段名称保持一致</p>
</li>
<li class="lvl-3">
<p>动态分区字段放在<code>select</code> 的最后一行</p>
</li>
</ol>
<p>Memory limit exceeded: Could not allocate memory while trying to increase reservation</p>
<blockquote>
<ol>
<li class="lvl-3">
<p>最常用的方式是：重试</p>
</li>
<li class="lvl-3">
<p>降低查询并发度：减少同时执行的查询数量，这样可以为每个查询分配更多的内存</p>
</li>
<li class="lvl-3">
<p>配置准入控制：Impala 支持准入控制功能，可以限制同时执行的查询数量，避免资源竞争。 <a href="https://docs.cloudera.com/documentation/enterprise/5-8-x/topics/impala_admission.html">Impala Admission Control 文档</a></p>
</li>
<li class="lvl-3">
<p>考虑优化查询以降低内存需求（sql 本身，<code>limit</code> 等）</p>
</li>
</ol>
</blockquote>
<h3 id="json数组如何解析">json数组如何解析</h3>
<p>如何解析JSON 数组？JSON数组大概长这个样子： <code>[{},{}]</code>，以下是解析demo</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> explode(</span><br><span class="line">               split(</span><br><span class="line">                       regexp_replace(</span><br><span class="line">                               regexp_replace(                                      <span class="string">'[{"skuNo":"KU413455571546619913","propertyValue":"雾霾蓝"},{"skuNo":"KU413455571546619912","propertyValue":"北极绿"},{"skuNo":"KU413455571546619911","propertyValue":"亚麻金"}]'</span>,</span><br><span class="line">                                       <span class="string">'\\[|\\]'</span>, <span class="string">''</span>), <span class="comment">--将json数组两边的中括号去掉</span></span><br><span class="line">                               <span class="string">'\\}\\,\\{'</span>, <span class="string">'\\}\\;\\{'</span>), <span class="comment">--将json数组元素之间的逗号换成分号</span></span><br><span class="line">                       <span class="string">'\\;'</span>) <span class="comment">--以分号作为分隔符(split函数以分号作为分隔)</span></span><br><span class="line">           )</span><br></pre></td></tr></tbody></table></figure>
<h3 id="如何求-当前日期至前7-30天-的聚合值？">如何求 <code>当前日期至前7/30天</code> 的聚合值？</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span> ( <span class="comment">-- 求：同一个账号，同一个商品，在包含直播日期内的7天内，播过多少次？</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'1424128656'</span> <span class="keyword">as</span> account_id, <span class="string">'259183220'</span> <span class="keyword">as</span> goods_id, <span class="string">'2022-06-28'</span> live_date</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'1424128656'</span> <span class="keyword">as</span> account_id, <span class="string">'259183220'</span> <span class="keyword">as</span> goods_id, <span class="string">'2022-06-22'</span> live_date</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'1424128656'</span> <span class="keyword">as</span> account_id, <span class="string">'259183220'</span> <span class="keyword">as</span> goods_id, <span class="string">'2022-06-17'</span> live_date</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'1424128656'</span> <span class="keyword">as</span> account_id, <span class="string">'259183220'</span> <span class="keyword">as</span> goods_id, <span class="string">'2022-06-15'</span> live_date</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'1424128656'</span> <span class="keyword">as</span> account_id, <span class="string">'262220152'</span> <span class="keyword">as</span> goods_id, <span class="string">'2021-12-09'</span> live_date</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">     , <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">             <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> account_id,goods_id</span><br><span class="line">                 <span class="keyword">order</span> <span class="keyword">by</span> unix_timestamp(live_date, <span class="string">'yyyy-MM-dd'</span>) <span class="keyword">desc</span></span><br><span class="line">                 <span class="keyword">range</span> <span class="keyword">between</span> <span class="number">1</span> following <span class="keyword">and</span> <span class="number">604800</span> following) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">as</span> day_7 <span class="comment">-- 过去包含今天在内的7天内出现了多少次</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tmp1</span><br></pre></td></tr></tbody></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">account_id</th>
<th style="text-align:left">goods_id</th>
<th style="text-align:left">live_date</th>
<th style="text-align:left">day_</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1424128656</td>
<td style="text-align:left">259183220</td>
<td style="text-align:left">2022-06-28</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">1424128656</td>
<td style="text-align:left">259183220</td>
<td style="text-align:left">2022-06-22</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">1424128656</td>
<td style="text-align:left">259183220</td>
<td style="text-align:left">2022-06-17</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">1424128656</td>
<td style="text-align:left">259183220</td>
<td style="text-align:left">2022-06-15</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">1424128656</td>
<td style="text-align:left">262220152</td>
<td style="text-align:left">2021-12-09</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<h3 id="Hive，cast-as-int-into-bigint-时，数据都是0">Hive，cast( as int) into  bigint 时，数据都是0</h3>
<p>Hive中</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- table_A 中 A字段的类型为 bigint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> table_A</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>(a <span class="keyword">as</span> <span class="type">int</span>) <span class="keyword">as</span> A</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最后查询 A的数据为，均为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- solutions ： 2边类型保持一致即可</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="时间A在B时间开始后的第几个小时">时间A在B时间开始后的第几个小时</h3>
<p>确定A 时间（ <code>on_top_time</code> ）在 B时间 （<code>start_time</code>） 的第几个小时内，相当于求相对位置问题（5相对于1的位置是多少）</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span> ( <span class="comment">-- </span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'2023-01-01 12:00:00'</span> <span class="keyword">as</span> on_top_time, <span class="string">'2023-01-01 11:00:00'</span> <span class="keyword">as</span> start_time</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'2023-01-01 12:02:00'</span> <span class="keyword">as</span> on_top_time, <span class="string">'2023-01-01 11:00:00'</span> <span class="keyword">as</span> start_time</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'2023-01-01 12:59:00'</span> <span class="keyword">as</span> on_top_time, <span class="string">'2023-01-01 11:00:00'</span> <span class="keyword">as</span> start_time</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'2023-01-01 16:00:00'</span> <span class="keyword">as</span> on_top_time, <span class="string">'2023-01-01 11:00:00'</span> <span class="keyword">as</span> start_time</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> on_top_time                                          <span class="keyword">as</span> on_top_time</span><br><span class="line">     , start_time                                           <span class="keyword">as</span> start_time</span><br><span class="line">     , <span class="built_in">cast</span>((unix_timestamp(on_top_time) <span class="operator">-</span></span><br><span class="line">             unix_timestamp(start_time)) <span class="operator">/</span> <span class="number">3600</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">as</span> <span class="type">int</span>) <span class="keyword">as</span> hours_id</span><br><span class="line"><span class="keyword">from</span> tmp1</span><br></pre></td></tr></tbody></table></figure>
<h3 id="is-not-in-the-vectorization-context-column-map">is not in the vectorization context column map</h3>
<p>在<a href="https://community.cloudera.com/t5/Support-Questions/hive-vectorization-union-all-problem/td-p/183179">Hive vectorization union all problem </a> 一文中，提出了一定的解决方案，但是没有写出原因</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 在计算时不使用向量化计算</span></span><br><span class="line"><span class="keyword">set</span> hive.vectorized.execution.enabled<span class="operator">=</span><span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="如何处理数据倾斜？">如何处理数据倾斜？</h3>
<p>当你遇到下面倾斜的问题的时候：假设A表在 <code>id = 1</code> 有大量的数据，针对这种倾斜场景，有2种处理方式：方式 🅰️</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 原有的逻辑是：</span></span><br><span class="line"><span class="keyword">select</span> A.id </span><br><span class="line"><span class="keyword">from</span> A </span><br><span class="line"><span class="keyword">join</span> B </span><br><span class="line"><span class="keyword">on</span> A.id <span class="operator">=</span> B.id </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改进后的逻辑，第一部分，该部分查询不会有任何倾斜</span></span><br><span class="line"><span class="keyword">select</span> A.id </span><br><span class="line"><span class="keyword">from</span> A </span><br><span class="line"><span class="keyword">join</span> B </span><br><span class="line"><span class="keyword">on</span> A.id <span class="operator">=</span> B.id </span><br><span class="line"><span class="keyword">where</span> A.id <span class="operator">&lt;&gt;</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 改进后的逻辑，第二部分,B.id=1的数据量很小，我们将其放入内存关联，在spark种叫广播关联，在hive中叫做 map-join</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+ mapjoin(B)*/</span> A.id </span><br><span class="line"><span class="keyword">from</span> A </span><br><span class="line"><span class="keyword">join</span> B </span><br><span class="line"><span class="keyword">on</span> A.id <span class="operator">=</span> B.id </span><br><span class="line"><span class="keyword">where</span> A.id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">and</span> B.id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>方式 🅱️</p>
<p>通过增加随机数 列的方式，增加关联键,举个例子：对于A表</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">id</span><br><span class="line">a </span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line"><span class="comment">-- 将变成</span></span><br><span class="line">id  rand_column(<span class="number">0</span><span class="operator">~</span><span class="number">2</span>) </span><br><span class="line">a               <span class="number">0</span></span><br><span class="line">a           <span class="number">1</span></span><br><span class="line">a             <span class="number">2</span></span><br><span class="line">a           <span class="number">2</span></span><br><span class="line"></span><br><span class="line">对于B表</span><br><span class="line">```<span class="keyword">sql</span></span><br><span class="line">id</span><br><span class="line">a</span><br><span class="line"><span class="comment">-- 将变成</span></span><br><span class="line">id rand_num</span><br><span class="line">a  <span class="number">0</span></span><br><span class="line">a  <span class="number">1</span></span><br><span class="line">a  <span class="number">2</span></span><br><span class="line"></span><br><span class="line">假设之前的关联关系是 A.id <span class="operator">=</span> B.id，为了处理倾斜，我们间关联关系修改为：</span><br><span class="line">`A.id <span class="operator">=</span> B.id <span class="keyword">and</span> A.rand_num <span class="operator">=</span> B.rand_num`</span><br></pre></td></tr></tbody></table></figure>
<h3 id="如何为Hive表增加一列？">如何为Hive表增加一列？</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">`<span class="keyword">alter</span> <span class="keyword">table</span> dw.live_thin_room_order_goods_df  <span class="keyword">add</span> columns (third_party_shop_id string comment <span class="string">'三方店铺id'</span>)`</span><br></pre></td></tr></tbody></table></figure>
<h3 id="生成日期维度列">生成日期维度列</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 在hive中</span></span><br><span class="line"><span class="keyword">select</span> date_add("2023-08-01", a.pos) <span class="keyword">as</span> range_date</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">   <span class="keyword">select</span> posexplode(split(repeat("@", datediff("2023-08-31", "2023-08-01")), "@")) <span class="comment">-- 第一个日期终止日期，第二个日期起始日期，</span></span><br><span class="line">) a</span><br></pre></td></tr></tbody></table></figure>
<p>维表生成，使用 <code>date_id = '2023-08-08'</code> 的日期生成 <code>date_id = '2023-08-08'</code> 之前的日期</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode<span class="operator">=</span>nonstrict;</span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> target_table <span class="keyword">partition</span> (date_id)</span><br><span class="line"><span class="keyword">select</span> id   <span class="keyword">as</span> id</span><br><span class="line">     , name <span class="keyword">as</span> name</span><br><span class="line">     , t1.date_id</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> date_add("2023-02-01", a.pos) <span class="keyword">as</span> date_id</span><br><span class="line">      <span class="keyword">from</span> (<span class="keyword">select</span> posexplode(split(repeat("@", datediff("2023-08-08", "2023-02-01")), "@")) <span class="comment">-- 第一个日期终止日期，第二个日期起始日期，</span></span><br><span class="line">      ) a</span><br><span class="line">)            t1</span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">            <span class="keyword">from</span> target_table</span><br><span class="line">            <span class="keyword">where</span> date_id <span class="operator">=</span> <span class="string">'2023-08-09'</span></span><br><span class="line">           ) t2</span><br></pre></td></tr></tbody></table></figure>
<h3 id="如何将过程数据划分到小时">如何将过程数据划分到小时</h3>
<p>场景描述：现在有一个网页的页面，爬虫读取数据，每分钟读取一次，并且落库，需求是得到每个小时的增量数据</p>
<p align="center">
  <img src="/2023/10/01/Hive/26.png" width="100%" alt="Your image description">
   <br>
   <span style="color:gray"> info about the picture </span>
</p>
<p>以上的代码如下</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span> ( <span class="comment">-- l_c : launch_consume, up_at : updated_at, s_at: start_time ， s_diff 更改时间距离开始时间多少秒</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_01'</span> <span class="keyword">as</span> o_id, <span class="number">10</span> <span class="keyword">as</span> l_c, <span class="string">'2023-08-01 01:00:00'</span> <span class="keyword">as</span> up_at, <span class="string">'2023-08-01 00:30:00'</span> <span class="keyword">as</span> s_at</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_01'</span> <span class="keyword">as</span> o_id, <span class="number">20</span> <span class="keyword">as</span> l_c, <span class="string">'2023-08-01 01:30:00'</span> <span class="keyword">as</span> up_at, <span class="string">'2023-08-01 00:30:00'</span> <span class="keyword">as</span> s_at</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_01'</span> <span class="keyword">as</span> o_id, <span class="number">30</span> <span class="keyword">as</span> l_c, <span class="string">'2023-08-01 01:50:00'</span> <span class="keyword">as</span> up_at, <span class="string">'2023-08-01 00:30:00'</span> <span class="keyword">as</span> s_at</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_01'</span> <span class="keyword">as</span> o_id, <span class="number">25</span> <span class="keyword">as</span> l_c, <span class="string">'2023-08-01 02:00:00'</span> <span class="keyword">as</span> up_at, <span class="string">'2023-08-01 00:30:00'</span> <span class="keyword">as</span> s_at</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_01'</span> <span class="keyword">as</span> o_id, <span class="number">60</span> <span class="keyword">as</span> l_c, <span class="string">'2023-08-01 02:40:00'</span> <span class="keyword">as</span> up_at, <span class="string">'2023-08-01 00:30:00'</span> <span class="keyword">as</span> s_at</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_01'</span> <span class="keyword">as</span> o_id, <span class="number">80</span> <span class="keyword">as</span> l_c, <span class="string">'2023-08-01 03:00:00'</span> <span class="keyword">as</span> up_at, <span class="string">'2023-08-01 00:30:00'</span> <span class="keyword">as</span> s_at</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_01'</span> <span class="keyword">as</span> o_id, <span class="number">180</span> <span class="keyword">as</span> l_c, <span class="string">'2023-08-01 04:00:00'</span> <span class="keyword">as</span> up_at, <span class="string">'2023-08-01 00:30:00'</span> <span class="keyword">as</span> s_at</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_01'</span> <span class="keyword">as</span> o_id, <span class="number">200</span> <span class="keyword">as</span> l_c, <span class="string">'2023-08-01 04:05:00'</span> <span class="keyword">as</span> up_at, <span class="string">'2023-08-01 00:30:00'</span> <span class="keyword">as</span> s_at</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_01'</span> <span class="keyword">as</span> o_id, <span class="number">400</span> <span class="keyword">as</span> l_c, <span class="string">'2023-08-01 04:20:00'</span> <span class="keyword">as</span> up_at, <span class="string">'2023-08-01 00:30:00'</span> <span class="keyword">as</span> s_at</span><br><span class="line">)</span><br><span class="line">   , tmp2 <span class="keyword">as</span> ( <span class="comment">--</span></span><br><span class="line">    <span class="keyword">select</span> o_id                                                         <span class="keyword">as</span> o_id</span><br><span class="line">         , l_c                                                          <span class="keyword">as</span> l_c</span><br><span class="line">         , up_at                                                        <span class="keyword">as</span> up_at</span><br><span class="line">         , s_at                                                         <span class="keyword">as</span> s_at</span><br><span class="line">         , <span class="built_in">lag</span>(l_c, <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> o_id <span class="keyword">order</span> <span class="keyword">by</span> up_at)       <span class="keyword">as</span> l_l_c</span><br><span class="line"></span><br><span class="line">         , l_c <span class="operator">-</span> <span class="built_in">lag</span>(l_c, <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> o_id <span class="keyword">order</span> <span class="keyword">by</span> up_at) <span class="keyword">as</span> l_c_diff</span><br><span class="line">         , (unix_timestamp(up_at) <span class="operator">-</span> unix_timestamp(s_at))               <span class="keyword">as</span> s_diff</span><br><span class="line">         , (unix_timestamp(up_at) <span class="operator">-</span> unix_timestamp(s_at)) <span class="operator">/</span> <span class="number">3600</span>        <span class="keyword">as</span> hour_diff</span><br><span class="line">         , <span class="built_in">cast</span>((unix_timestamp(up_at) <span class="operator">-</span></span><br><span class="line">                 unix_timestamp(s_at)) <span class="operator">/</span> <span class="number">3600</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">as</span> <span class="type">int</span>)               <span class="keyword">as</span> real_hours_id</span><br><span class="line">    <span class="keyword">from</span> tmp1</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tmp2</span><br></pre></td></tr></tbody></table></figure>
<h3 id="动态参数">动态参数</h3>
<p>实现效果：当某一列没有传参时，将 <code>where</code> 当前列的过滤逻辑去除</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="keyword">case</span> <span class="keyword">when</span> ${param} <span class="operator">=</span> <span class="string">'你预设的参数'</span> <span class="keyword">then</span> ture</span><br><span class="line">        <span class="keyword">else</span> platform_name <span class="operator">=</span> ${param}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="多字段-full-join">多字段 full join</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp1 <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_01'</span> <span class="keyword">as</span> o_id, <span class="string">'2023-08-01'</span> <span class="keyword">as</span> data_id, <span class="number">50</span> <span class="keyword">as</span> money</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_03'</span> <span class="keyword">as</span> o_id, <span class="string">'2023-08-02'</span> <span class="keyword">as</span> data_id, <span class="number">50</span> <span class="keyword">as</span> money</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_04'</span> <span class="keyword">as</span> o_id, <span class="string">'2023-08-03'</span> <span class="keyword">as</span> data_id, <span class="number">50</span> <span class="keyword">as</span> money</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">   , tmp2 <span class="keyword">as</span> ( <span class="comment">--</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_01'</span> <span class="keyword">as</span> o_id, <span class="string">'2023-08-01'</span> <span class="keyword">as</span> data_id, <span class="number">60</span> <span class="keyword">as</span> money</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_02'</span> <span class="keyword">as</span> o_id, <span class="string">'2023-08-02'</span> <span class="keyword">as</span> data_id, <span class="number">60</span> <span class="keyword">as</span> money</span><br><span class="line">    <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">    <span class="keyword">select</span> <span class="string">'o_05'</span> <span class="keyword">as</span> o_id, <span class="string">'2023-08-03'</span> <span class="keyword">as</span> data_id, <span class="number">60</span> <span class="keyword">as</span> money</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> if(t1.data_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>, t1.o_id, t2.o_id)       <span class="keyword">as</span> o_id</span><br><span class="line">     , if(t1.data_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>, t1.data_id, t2.data_id) <span class="keyword">as</span> date_id</span><br><span class="line">     , <span class="built_in">coalesce</span>(t1.money, t2.money)                       <span class="keyword">as</span> money</span><br><span class="line"><span class="keyword">from</span> tmp1      t1</span><br><span class="line"><span class="keyword">full</span> <span class="keyword">join</span> tmp2 t2</span><br><span class="line">          <span class="keyword">on</span> t1.o_id <span class="operator">=</span> t2.o_id</span><br><span class="line">              <span class="keyword">and</span> t1.data_id <span class="operator">=</span> t2.data_id</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p align="center">
  <img src="/2023/10/01/Hive/28.png" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 从 select * 到 select 判断逻辑  </span>
</p>
<h2 id="第-X-部分">第 X 部分</h2>
<p>这里继续收录一下问题或者解决方案，ToDo</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>设置map的聚合为false , 在map端聚合还可能会引发内存溢出的问题，详情可查看：<a href="http://dev.bizo.com/2013/02/map-side-aggregations-in-apache-hive.html">http://dev.bizo.com/2013/02/map-side-aggregations-in-apache-hive.html</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>技术总结</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>现代人的数学修养</title>
    <url>/2023/10/02/math/</url>
    <content><![CDATA[<p>本文档最初起源于阅读《吴军数学通识讲义》的读书笔记，后来在如果有关于数学有趣的见闻和应用，都留存在这里</p>
<p>世界上有各种各样的知识体系，有些是建立在信仰基础上的，比如宗教；有些事建立在实证基础之上的，比如自然科学。数学和它们都不同，它是建立在纯粹理性（逻辑）基础之上的，因为它是不同信仰，不同语言，不同知识背景的人都能够接受的一种语言。<strong>如果存在外星文明，那么地球文明和外星文明最相同的应该是数学</strong></p>
<p>我的个人公众号：stackoverflow</p>
<span id="more"></span>
<h1>基础篇</h1>
<h2 id="第1章-理解数学的线索：从毕达哥拉斯讲起">第1章-理解数学的线索：从毕达哥拉斯讲起</h2>
<h3 id="勾股定理：为什么在西方叫做毕达哥拉斯定理">勾股定理：为什么在西方叫做毕达哥拉斯定理</h3>
<p>毕达哥拉斯定理，国内称之为勾股定理，其内容如下：</p>
<blockquote>
<p>直角三角形的两条直角边<code>a</code>和<code>b</code>边长的平方和等于斜边长<code>c</code>的平方和，即： $a^2 + b^2 = c^2$</p>
</blockquote>
<p>古埃及人（公元前25世纪）、美索不达米亚人（公元前15世纪）、中国人（公元前10世纪）的文明中都有勾股数的记录，<strong>公元前6世纪，毕达哥拉斯使用演绎法证明了毕达哥拉斯定理</strong></p>
<p>勾股数（例如3,4,5）只是毕达哥拉斯定理的特例，要区分定理和特例/现象的区别。在自然科学中，一个假说通过了实验证实，就成为了定理，比如说波义耳-马略特定理（一个封闭容器内的气压和体积成反比），而数学的结论只能从逻辑出发，通过归纳和演绎得出来，比如哥德巴赫猜想（任意一个大于2的偶数都可以写成2个素数之和）至今没有被证明，就只能是猜想，而不是定理</p>
<p>1️⃣ 自然数：全体非负整数的合集</p>
<p>2️⃣ 素数（也叫做质数）：指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数</p>
<p>3️⃣ 互素：指的是2个数写成分数的形式的时候，2者都不能再约分，比如 $5/8$是素数， $10/16$不是素数</p>
<h3 id="数学的预见性：无理数是毕达哥拉斯定理的推论">数学的预见性：无理数是毕达哥拉斯定理的推论</h3>
<p>🅰️ 有理数，即分数，可以写成 $p/q$ 的形式，其中 $p,q$ 都是整数，比如 $2/3$，任何两个有理数进行加减乘除运算后，结果仍然是有理数（这种性质也叫做运算的封闭性）</p>
<p>🅱️ 无理数：无限不循环小数，如 $\sqrt2$ ，无理数是第一次数学危机</p>
<p>宇宙的质量是一个负数（宇宙中存在暗物质）</p>
<h3 id="黄金分割：数学和美学的桥梁">黄金分割：数学和美学的桥梁</h3>
<p>黄金分割的大致比例为： $1:0.618$ 或者 $1.618:1$ ，公式为</p>
<p>$$<br>
\frac{a+b}{a} = \frac{a}{b} = \varphi = \frac{\sqrt5+1}{2}<br>
$$</p>
<p>其中 (a&gt;b&gt;0)，得出 $\varphi$的值的过程是求解一元二次方程组的过程，当 $b^2 &gt; 4ac$的时候，一元二次方程组的2个解分别是</p>
<p>$$<br>
x_1,x_2=\frac{-b \pm \sqrt{b^2-4ac}}{2a}<br>
$$</p>
<p>今天认为，最早计算出黄金分割比例值的人是毕达哥拉斯，一般的，在谈论黄金分割时，是较大值vs较小值</p>
<p align="center">
  <img src="/2023/10/02/math/1.png" width="100%" alt="Your image description">
  <br>
  <span style="color:gray"> 黄金分割比  </span>
</p>
<p>在正五角星中，每个等腰三角形的斜边长和底边长的比例都是黄金分割，每个三角形的内角分别是 $36<sup>\circ,72</sup>\circ,72^\circ$，如果将任意一个底角一分为二会得到一个相似三角形，该相似三角形的面积和上一级三角形的的比例为： $0.618:1.618$，内角分别是 $36<sup>\circ,36</sup>\circ,108^\circ$的三角形同理</p>
<p>建筑，绘画，音乐，摄影都和黄金分割比息息相关。单点/两点/三点透视法利用了相似三角形的原理，即从同一个角度看过去物体的大小和距离成比例</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>单点透视：景物，按照远近比例，在远处汇成一个点</p>
</li>
<li class="lvl-2">
<p>两点透视：景物，按照远近比例，在远处汇成二个点</p>
</li>
</ul>
<p>优选法：其有2个含义，首先它能够找到实际问题的最优解，其次它强调寻找最优解的方法本身也应该是最简单的/最优的，优选法基于黄金分割，即每次在0.618的位置实验</p>
<h2 id="第2章-数列与极数：承上启下的关键内容">第2章-数列与极数：承上启下的关键内容</h2>
<h3 id="数学的关联性：斐波那契数列和黄金分割">数学的关联性：斐波那契数列和黄金分割</h3>
<p>斐波那契数列的通项/表达式是： $F_{n+2} = F_{n+1} + F_n$，比如 1，1，2，3，5，8，13，21…，斐波那契数列相邻两项的比值是收敛于黄金分割的</p>
<p>长度是1的线段第一次黄金分割后得到 $0.618(1 \times 0.618)$，0.618再分割一次得到 $0.382(0.618^2 )$两者相加等于1，等同于斐波那契数列中的 $F_{n+2} = F_{n+1} + F_n$的关系，很多现象在数学中是统一的</p>
<p>斐波那契数列一直写下去，最后会趋向于无穷大，因此它是一个发散数列，数列的其他两种趋势是，振荡和收敛</p>
<h3 id="数列变化：趋势比当下重要">数列变化：趋势比当下重要</h3>
<p>等差数列通项</p>
<p>$$<br>
a_n = a_1 + (n - 1) * d<br>
$$</p>
<p>等差数列的求和公式为</p>
<p>$$<br>
S_n=\frac{n * (a_1 + a_n)}{2}<br>
$$</p>
<p>等比数列通项</p>
<p>$$<br>
S_n = a_1 * q ^{n - 1}<br>
$$</p>
<p>$$<br>
S_n = a_m * q^{n-m}<br>
$$</p>
<p>等比数列求和公式</p>
<p>$$<br>
S_n = n * a_1 (q = 1)<br>
$$</p>
<p>当 $q \ne 1$ 时</p>
<p>$$<br>
S_n = \frac{a_1 * (1-{q^n})}{1-q}<br>
$$</p>
<p>一个数列的级数就是它所有项或者有限项的和，比如等比级数，等差级数，其中等差级数要么趋向于无穷大，要么趋向于无穷小，等比数列可能发散，可能收敛</p>
<p>如果我们知道了数列每一次的变化速率，以及一头一尾的情况，就可以推算出发生这样的变化需要多长时间，比如今天用于测定年代的碳14<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>测定法，利用的就是等比数列的这一个性质</p>
<p align="center">
  <img src="/2023/10/02/math/2.png" width="100%" alt="Your image description">
  <br>
  <span style="color:gray"> 裂变过程 </span>
</p>
<p>从等比数列的角度来看核裂变的链式反应，假定第一批核裂变的原子数量是 $a_1$,释放3个中子能够命中新的原子核的平均数量为  $r$，那么第二批核裂变的原子数量是 $a_1*r$ 个，第三批就是 $a_1 * r^2$个，…那么最终参与核反应的原子数目就是级数（等比数列级数）</p>
<p>$$<br>
S = a_1+{a_1}<em>r+{a_1}</em>{r^2}+…<br>
$$</p>
<p>其中 $r&gt;1$，链式反应就是发散的，反应就会越来越剧烈，形成原子弹； $r=1$（或者说是保证r值在1左右），就是可控核聚变，主要用于发电，由于将 $r$值控制在1左右不是一件容易的事，一旦比1稍微大了一点，经过几次指数增长后就会失控，所以在核反应堆中都会有“刹车装置”控制棒（吸收中子）和“油门”铀棒（增大铀块体积）</p>
<p>传销，社交网络上的信息传播都是等比级数问题</p>
<blockquote></blockquote>
<h2 id="第3章-数学边界：数学是万能的么？">第3章-数学边界：数学是万能的么？</h2>
<p>数学并不是万能的</p>
<h3 id="数学的局限性：从勾股定理到费马大定理">数学的局限性：从勾股定理到费马大定理</h3>
<p>毕达哥拉斯定理出现在几何学中，该定理的另外一个角度就是 $x<sup>2+y</sup>2=z^2$有没有整数解问题，现在我们知道所有的勾股数都是这个方程的整数解，如3，4，5。那么进一步，方程 $x<sup>3+y</sup>3=z^3$ 有没有整数解呢？一般的，n 为 $n&gt;2$的整数的情况下 $x<sup>n+y</sup>n=z^n$ 有没有整数解？17世纪，法国数学家费马提出一个假说： $x<sup>n+y</sup>n=z^n (n&gt;2$) 时没有整数解，该猜想在1994年由 <strong>英国数学家安德鲁怀尔斯</strong>证明出来，从此这个<strong>猜想成为一个定理，并且成为数学大厦的奠基石</strong></p>
<p>这个定理历经了300多年，几代数学家的努力，才得以证明</p>
<h3 id="数学的边界：希尔伯特第十问题">数学的边界：希尔伯特第十问题</h3>
<p>1900年巴黎举行的国际数学家大会上，数学家希尔伯特提出著名的23个数学问题，其中第10个为：</p>
<blockquote>
<p><strong>对于任意一个整数系的多项式方程，我们能否在有限步内，判定它是否有整数解？</strong></p>
</blockquote>
<p>1970年，俄罗斯数学天才，尤里·马季亚谢维奇在大学毕业一年后，证明了这类问题是无解的，这个定理也成为马季亚谢维奇定理，希尔伯特第10问题说明了，对于一些问题，我们通过数学的方法无法判断该问题的答案存在与否，更不要说通过数学的方法解决它们了。如此就给数学划定了一个明确的边界</p>
<p><strong>数学是绝对正确的</strong>，物理学，化学，生物学，计算机科学，医学，经济学都是有条件正确的</p>
<h1>数字篇</h1>
<h2 id="第4章-方程：新方法和新思维">第4章-方程：新方法和新思维</h2>
<p>人类对数的认识和解方程息息相关</p>
<p>1️⃣ 一开始人类最先认识到正整数</p>
<p>2️⃣ 后来在解 $5x=7$的方程时，发现正整数不够用了，于是有了有理数</p>
<p>3️⃣ 毕达哥拉斯发现了勾股定理后，人们便无法回避无理数存在的问题，有了无理数，二次方程的解法得到了完善</p>
<p>4️⃣ 数学家门在试图解决三次方程的问题，就不得不面对负数开根号的问题，虚数的概念就被提出来了</p>
<h3 id="方程这个工具有什么用？">方程这个工具有什么用？</h3>
<p>从术的层面讲：方程是一种工具，能够将原来用自然语言描述的问题，变成数学上的等式。在数学发展的早期阶段，提出的那些问题（比如费马大定理，庞加莱猜想）同一时代的数学工具不足以解决它们，需要更高层次的工具才好解决。比如我们掌握了中学学的一些数学工具后，小学的各种学数学难题就变的非常容易，而我们掌握了微积分这个工具后，很多中学的数学难题就不值一提了</p>
<p>从道的层面讲：方程是一种思维方式，即逆向思维，比如问题</p>
<blockquote>
<p>什么数字加上3等于7？</p>
</blockquote>
<p>正向思维是：这个数字肯定比7小，小多少呢？小3，于是我们用 $7-3 = 4$ 得到答案。我从我的一个当数学老师的同学那里了解到：一个念小学的小学生是不具备 $X$思维的，小朋友不知道什么是未知数！</p>
<p>而使用方程是一种逆向思维，先不管这个数字是多少，假设为 $x$，然后将上面这句描述的语言转换为数学语言，即 $x + 3 = 7$，至于 $x$这个数等于多少，方程这个工具会给出系统地解决问题的步骤</p>
<p>不同类型的方程和不同的数是对应的：比如一次方程只要本身不包含无理数，方程的解也就不包含无理数，也就是说一次方程对于有理数是完备的</p>
<h3 id="一元三次方程的解法：数学史上著名的发明权之争">一元三次方程的解法：数学史上著名的发明权之争</h3>
<p>公元9世纪，<strong>数学家阿尔·花拉子米</strong>总结出一元二次方程的解法，他给出了 $ax^2+bx+c=0$在 $b^2-4ac&gt;=0$ 条件下的2个通解，从通解公式</p>
<p>$$<br>
x_1,x_2=\frac{-b \pm \sqrt{b^2-4ac}}{2a}<br>
$$</p>
<p>可以看出，当面对二次方程时，我们对数字的认识必须提升到无理数这个水平，比如 $x^2-3=0$ 的两个解是 $\sqrt3,-\sqrt3$ 是2个无理数。花拉子米回避了 $b^2-4ac&lt;0$ 的情况，因为我们找不到一个自己乘以自己是负数的数，比如 $x^2 + 1 = 0$，因为根据我们对实数的认知， $x^2\geq0$ ，$x^2$ 再加上1，自然不会等于0了。此时，我们宣布，<strong>该方程没有实数解</strong>。对负数求平方根的问题，在求解一元三次方程的通解时，就无法回避了</p>
<p>对于一个标准的三次方程</p>
<p>$$<br>
ax<sup>3+bx</sup>2+cx+d=0<br>
$$</p>
<p>计算其通解需要用到<strong>卡尔达诺-塔塔利亚</strong>公式，要计算它的第一个解，需要计算下面三个中间变量</p>
<p>$$<br>
\Delta_0=b^2-3ac \tag{1}<br>
$$</p>
<p>$$<br>
\Delta_1=2b<sup>3-9abc+27a</sup>2d \tag{2}<br>
$$</p>
<p>$$<br>
CR=\sqrt[3]{\frac{\Delta_1 \pm {\sqrt{\Delta_1<sup>2-4\Delta_0</sup>3}}}{2}} \tag{3}<br>
$$</p>
<p>然后根据上述三个中间变量求解出第一个解</p>
<p>$$<br>
x_1=-\frac{b+CR+\frac{\Delta_0}{CR}}{3a}<br>
$$</p>
<p>有了一个解，三次方程就可以简化为二次方程，然后就是求解二次方程，一元三次方程的求解比较复杂，可以借助<a href="https://www.wolfram.com/mathematica/">Mathematica</a>这款软件来解决（作者是StephenWolfram）</p>
<p><strong>一元三次方程一定是有实数解的</strong>，在计算中间变量 $CR$的过程中，涉及了平方根的运算，由于根号内有负数的存在，卡尔达诺在《大术》一书中引入了 $\sqrt{-1}$ 的概念，同时期的意大利数学家拉斐尔直接使用 $i$ 代表 $\sqrt{-1}$，<strong>此类负数的平方根被称之为虚数</strong></p>
<h3 id="虚数：虚构的工具有什么用？">虚数：虚构的工具有什么用？</h3>
<p>虚数的概念是在推导一元三次方程的时候引入的，根据卡尔塔诺-塔塔利亚公式，即便一个有实数解的一元三次方程，在求解的过程中也会遇到负数开根号的情况，如下面的的方程</p>
<p>$$<br>
x^3-15x-4=0<br>
$$</p>
<p>显然 $x=4$ 是它的一个实数解，我们带入求解公式，会得到下面的解</p>
<p>$$<br>
x=\sqrt[3]{2+\sqrt{-121}} + \sqrt[3]{2-\sqrt{-121}}<br>
$$</p>
<p>在没有虚数 $i$ ，上述的公式就演算不下去了，但当我们有了 $\sqrt-1 = i$</p>
<p>$$<br>
x=\sqrt[3]{2+\sqrt{-121}} + \sqrt[3]{2-\sqrt{-121}} \<br>
= \sqrt[3]{2+\sqrt{11^2 \cdot(-1)}} + \sqrt[3]{2-\sqrt{11^2 \cdot(-1)}} \<br>
=\sqrt[3]{2+11i} + \sqrt[3]{2-11i} \<br>
=\sqrt[3]{(2+i)^3} + \sqrt[3]{(2-i)^3}  \<br>
= 2+i+2-i \<br>
= 4<br>
$$</p>
<p>其中：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>$(a+b)^3 = (a+b) \times (a+b)^2 = a^3 + 3a<sup>2b+3ab</sup>2+b^3$</p>
</li>
<li class="lvl-2">
<p>$(a - b)^3 = (a -b) \times (a-b)^2 = a^3 -3a^2b + 3ab^2 -b^3$</p>
</li>
</ul>
<p>整个推导过程引入了虚数 $i$ 到最后正负抵消了，虚数是我们为了解决实际问找到的数学工具，很多的数学工具都是如此，并非我们真实世界存在的东西，而是完全由逻辑虚构出来的，如果缺了这些虚构的工具，有些问题还真的就解决不了，比如几何里常用的辅助线</p>
<p>引入虚数的概念，每一个一元N次方程会有不多不少N个解，极坐标是虚数的应用，极坐标在飞行和航海等场景中有很重要的应用。电磁学，量子力学、相对论，信号处理，流体力学和控制系统的发展都需要用到虚数。虚数的出现，是人类对数这个概念认识的一个大的飞跃，从形象具体真实的对象，上升到了<strong>纯粹理性的抽象</strong></p>
<p>人类对数的发展过程如下：</p>
<p>1️⃣ 最早的认识的数字都是<strong>正整数</strong>，1，2，3，4…对应着周围接触到的世界中的一个又一个真实存在的东西，除了古印度，其他文明早期的数字中都没有零这个数</p>
<p>2️⃣ 有了数字之后，就需要做运算，两个自然数，相加/乘还是自然数，减法和除法就会出现问题，比如 $2-3, 2/3$ 的结果在自然数中是找不到的，于是人们发明了<strong>负数和分数</strong>(有理数)，这两个概念就相对来说更加抽象</p>
<p>3️⃣ 当毕达哥拉斯定理被发现之后，就不得不面对开方这个事情，于是出现了<strong>无理数</strong></p>
<p>4️⃣ 在求解一元三次方程的时候，不得不面对对负数开方，于是就有了<strong>虚数</strong>，实数和虚数合在一起，就形成了<strong>复数</strong>。很多问题，复数这个工具要比实数加上三角函数解决来的容易的多，涉及电磁波的所有问题，几乎都要用复数的工具来解决</p>
<p align="center">
  <img src="/2023/10/02/math/3.png" width="80%" alt="Your image description">
  <br>
  <span style="color:gray"> 从自然数到复数 </span>
</p>
<p>我们的祖先现代智人超过其他动物的地方就在于，能够想象出那些实际不存在的东西，比如神，法律，国家，有限公司，货币，股票，债券等，其本质可以看成是和虚数一样是虚构出来的抽象</p>
<h2 id="第5章-无穷大和无穷小：从数值到趋势">第5章-无穷大和无穷小：从数值到趋势</h2>
<h3 id="无穷大：为什么我们难以理解无限大的世界">无穷大：为什么我们难以理解无限大的世界</h3>
<p>无穷大和无穷大加一完全是一回事，人类也是直到现代才正确认识无穷大的。<strong>希尔伯特旅馆悖论</strong>指出，有限世界里存在的规律，在无穷大的世界里，有着另外一套规律，需要重新用逻辑推导一遍，例如</p>
<p align="center">
  <img src="/2023/10/02/math/4.png" width="90%" alt="Your image description">
  <br>
  <span style="color:gray"> 无穷大的示例 </span>
</p>
<p>怎样理解无穷大/小的本质？巴赫曼和康托尔给出了答案：</p>
<blockquote>
<p>无穷大不是静态的，而是动态的，它反映了一种趋势，一种无限增加/减少的趋势，在增大/减小的过程中，有的无穷大/无穷小会比其他的无穷大/小发展的更快，即高阶无穷大/小，并且它们引入了大 $O$ 表示法来表示无穷大阶数，算法的复杂度也是从该处引申而来</p>
</blockquote>
<p>有理数和无理数的数量都是无穷大的，但是哪一个更多呢？19世纪后期，德国数学家康托尔证明<strong>无理数的数量要远远多于有理数</strong>，甚至在0和1之间的无理数都比要多于全部的有理数，前者的基数比后者大</p>
<h3 id="无穷小：芝诺悖论和它的破解">无穷小：芝诺悖论和它的破解</h3>
<p>无穷小不是一个确定的数，更不是零，而是一种趋势，一种不断趋近于零的趋势</p>
<p>在芝诺的阿喀琉斯悖论中(阿喀琉斯追不上乌龟)，无穷小趋近于零的速度（指数级的减少）比，分割次数趋近于无穷大的速度（线性增加）要快的多</p>
<p>牛顿和莱布尼茨分别引入了无穷小(和极限)的概念</p>
<h3 id="第二次数学危机：牛顿和贝克莱的争论">第二次数学危机：牛顿和贝克莱的争论</h3>
<p>牛顿在研究速度，加速度，位移之间的关系时，提出了流数(<strong>导数</strong>)的概念，速度就是位移的(一阶)导数<sub>位移在瞬时的变化率</sub>，加速度是速度的(一阶)导数<sub>速度在瞬时的变化率</sub>。导数概念的提出，使得人们能够从掌握平均规律，进入到掌握瞬时规律，从对变化本身的观察，上升为对变化速度的观察</p>
<p>牛顿在他的巨著，《自然哲学的数学原理》中，多次使用了无穷小的概念，但是并没有用数学的办法将其讲清楚，哲学家贝克莱挑战牛顿说：你说的无穷小的时间 $\Delta_t$ 到底是不是零，如果是 0，它不能做分母，如果不是零，你的公式依然是一个平均速度(虽然是一个很短的时间间隔)，而不是瞬时速度，贝克莱关于无穷小的悖论，是数学史上的第二次危机</p>
<p>无穷小是一种趋势的描述是100多年后的数学家柯西和特拉斯给出的</p>
<h3 id="极限：重新审视无穷小的世界">极限：重新审视无穷小的世界</h3>
<p>我们知道 $\frac{1}{2} + \frac{1}{4}+\frac{1}{8} + \frac{1}{16} + …$是不断增加的，但是肯定超不过1。我们今天学习的微积分是经过柯西等人的改造过的，严格的多的微积分，而不是牛顿和莱布尼茨描述的微积分</p>
<p>数列的极限的定义：设 ${x_n}$是一个数列， $a$是一个实数</p>
<blockquote>
<p>如果对于任意给定的正数 $\epsilon$ (无论它多小)，总存在正整数 $N$，使得 $n &gt; N$时，不等式 $|x_n - a| &lt; \epsilon$ 恒成立，则<br>
$$<br>
\lim _{n\to \infty} x_n = a<br>
$$</p>
<p>逻辑符号表示为：</p>
<p>$\lim _{n\to \infty} x_n = a$ 的定义是： $\forall \epsilon &gt;0$, $\exists n\in \mathbb N$ ,当 $n &gt; N$ 时，$|x_n-a| &lt; \epsilon$</p>
</blockquote>
<p>$\mathbb N$ 表示的是自然数，人话来说就是 $n$趋近于无穷大的时候，数列趋近于$a$</p>
<p>函数的极限定义：</p>
<blockquote>
<p>$\lim _{x \to c}  f(x) = L \in \mathbb R$</p>
<p>对于任意 $\epsilon &gt; 0$ ,存在 $\delta &gt; 0$ 使得只要$0 &lt; |x - c| &lt; \delta$ 都有$|f(x)-L| &lt; \delta$</p>
</blockquote>
<p align="center">
  <img src="/2023/10/02/math/5.png" width="80%" alt="Your image description">
  <br>
  <span style="color:gray"> 函数极限的定义 </span>
</p>
<p>极限是微积分中最重要/难懂的概念</p>
<h3 id="动态趋势：无穷大和无穷小能比较大小么？">动态趋势：无穷大和无穷小能比较大小么？</h3>
<p>无穷大和无穷小反映的是一种趋势，所以有高阶/低阶无穷大/小的概念，比如在火箭的精度调整中，更希望以高阶无穷小的速度趋近于0</p>
<p align="center">
  <img src="/2023/10/02/math/6.png" width="100%" alt="Your image description">
  <br>
  <span style="color:gray"> 不同阶数的无穷大/小 </span>
</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>无穷大和无穷大彼此相加，结果还是无穷大</p>
</li>
<li class="lvl-2">
<p>无穷小之间做加减乘，结果都是无穷小</p>
</li>
<li class="lvl-2">
<p>无穷大除以无穷大，无穷小除以无穷小，要看分子分母的阶数高低</p>
</li>
</ul>
<h1>几何篇</h1>
<p>相比于代数而言，几何是更难的，但在人类的早期文明中，生产和生活太需要几何学知识了，由此几何学得以优先发展起来，所以那时的人们会用几何学的方法来解决本该属于代数学的问题，而后来<strong>笛卡尔发明了解析几何，可以使用代数工具解决几何问题，极大地简化了几何问题</strong></p>
<p>几何学是最早被公理化的数学分支</p>
<h2 id="第6章-基础几何学：公理化体系的建立">第6章-基础几何学：公理化体系的建立</h2>
<p>几何学最早起源于古埃及文明，美索不达米亚人<sub>即两河文明，现今伊拉克位置</sub>发明了角度的度量，即 $360^o$ 和 $60^o$进位。两河文明中，苏美尔人统治时期，将天空划分为12份<sub>12星座的由来</sub>，古巴比伦人后将天空分为360份，每一份就是一度，并且按照 $60^o$进位，这种方式沿用至今</p>
<p>古埃及和美索不达米亚文明积累下的几何学知识，经由闪米特人<sub>今阿拉伯人和犹太人的祖先</sub>传播至古希腊，经由毕达哥拉斯学派的发展，几何学从一种实用性的数学测量和计算工具，逐渐成为单纯基于逻辑推理的数学分支，到了<strong>公元前4世纪-公元前3世纪</strong>，古希腊数学家欧几里得等人完成了对几何学公理化体系的构建，并写成了《几何原本》一书<sub>距今2000多年</sub></p>
<p>传统逻辑中，公理是没有经过证明，但被当作不证自明的一个命题（如 $b+a=a+b$），公理是推导其他命题的基础</p>
<p>🅰️ 欧几里得的《几何原本》中有5条一般性公理<sub>也叫一般性概念</sub></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果 $a=b, b=c$ ， 那么$a=c$</p>
</li>
<li class="lvl-2">
<p>如果$a=b,c=d$，那么$a+c=b+d$</p>
</li>
<li class="lvl-2">
<p>如果$a=b,c=d$，那么$a-c=b-d$</p>
</li>
<li class="lvl-2">
<p>彼此能够重合的物体（图形）是全等的</p>
</li>
<li class="lvl-2">
<p>整体大于部分</p>
</li>
</ul>
<p>🅱️ 还有5条几何学公理论<sub>也称为一般性公设</sub>，五条公理相互独立</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>从一点向另一点可以引一条直线（直线公理）</p>
</li>
<li class="lvl-2">
<p>任意线段能无限延伸成一条直线</p>
</li>
<li class="lvl-2">
<p>给定任意线段，可以以其一个端点作为圆心，该线段作为半径作一个圆（圆公理）</p>
</li>
<li class="lvl-2">
<p>所有直角都相等（垂直公理）</p>
</li>
<li class="lvl-2">
<p>通过一个不在直线上的点，有且仅有一条不与该直线相交的直线（平行公理）<sub>公理由意大利数学家贝尔特拉米证明是独立的</sub></p>
</li>
</ul>
<p>在5条一般性公理和5条几何学公理的基础上，欧几里得又定义了一些基本的几何学概念，比如点，线，夹角等，其构建公理化几何学的大致过程如下：</p>
<p>1️⃣ 首先，遇到一个具体的问题，要做相应的定义，比如什么事夹角，什么是圆</p>
<p>2️⃣ 其次，从定义和公理出发，得到相关的定理</p>
<p>3️⃣ 最后，在定义更多的概念，用公理和定理推导出更多的定理</p>
<p>如此层层递进，几何学大厦就一点点建立起来，在构建几何学的公理化体系中，<strong>逻辑是从一个结论通往另一个结论的唯一通道</strong></p>
<p>定理基于公理，定理的"祖先"是公理，公理无"祖先"</p>
<p>欧式几何不足之处在于：没有定义什么是平面，如果将满足平行公理的平面定义为平面，欧式几何的公理将会更加扎实</p>
<h2 id="第7章-几何学的发展：开创不同数学分支融合的先河">第7章-几何学的发展：开创不同数学分支融合的先河</h2>
<h3 id="非欧几何：换一条公理，几何学会崩塌么？">非欧几何：换一条公理，几何学会崩塌么？</h3>
<p>19世纪初，俄罗斯数学家尼古拉·罗巴切夫斯基发现，如果让几何学不受几何公理中平行公理的限制，即通过一个点作一条直线的任意多平行线，就会得到另一种几何学系统，即<strong>罗氏几何</strong>。再后来，著名数学家波恩哈德·黎曼又假定，经过直线外一点，一条平行线也做不出来，就会得到另外一种几何系统，即<strong>黎曼几何</strong>，罗氏几何和黎曼几何被统称为<strong>非欧几何</strong></p>
<p align="center">
  <img src="/2023/10/02/math/7.png" width="80%" alt="Your image description">
  <br>
  <span style="color:gray"> 罗式几何 和 黎曼几何 </span>
</p>
<p>在欧式几何中，一个球面的方程是$x<sup>2+y</sup>2+z^2=25$，在黎曼几何中就是$r=5$这样的表述，在黎曼几何诞生后的半个多世纪里都没有太多实际的用途，直到爱因斯坦在描述广义相对论时才用了黎曼几何这个数学工具，因为在广义相对论所说的扭曲空间里，光线的路径不再是直线，而是曲线。黎曼几何在计算机图形学和三维地图绘制等领域有着广泛的应用</p>
<p>可以发现三种几何90%的公理是一样的，只是差了一条平行公理</p>
<p>相对论：时间告诉物质如何运动，物质告诉时间如何弯曲。地球引力场让周围的时空弯曲</p>
<h3 id="圆周率：数学工具的意义">圆周率：数学工具的意义</h3>
<p>初等几何中，大概分为2类问题</p>
<p>1️⃣ 和直线图形有关的问题</p>
<p>2️⃣ 和圆相关的问题（和角度相关的问题其实和圆相关）</p>
<p>在人类文明的各个时期，都发现了圆的周长和和直径是成比例的，这个比例和圆的大小无关，公元18世纪，数学家们统一用 $\pi$来表示圆周率。早期文明一直在估算圆周率，但是都是通过实际经验进行估算<sub>第一阶段</sub>，直到欧式几何建立，人们发现圆周的长度介于它的内接多边形和外切多边形之间，可以通过增加多边行的边数不断逼近<sub>第二阶段</sub>，第三阶段是公元十四世纪，使用数列计算圆周率；等到牛顿和莱布尼茨发明了微积分后，圆周率的计算进入了第四阶段</p>
<p>靠机械运动能实现的重复运动只有直线运动和圆周运动， $y = \frac{1}{x^2+1}$ 的积分结果就是$\pi$， $\pi$ 在各个数学分支中扮演着非常重要的角色，而且他是一个超越数<sub>无理数的一种</sub>，另外一个著名的无理数 $e$ 也是超越数</p>
<h3 id="解析几何：如何用代数的方法解决几何问题">解析几何：如何用代数的方法解决几何问题</h3>
<p>法国数学家笛卡尔，建立了使用方程的方式解决几何问题的系统，即解析几何，也即笛卡尔几何。这种方式不仅能够用解方程的方式解决几何问题，而且能够利用几何学直观的特性赋予方程形象的解释。笛卡尔的解析几何在数学和认知上有三大贡献：</p>
<p>1️⃣ 它使用平面的任意一个点，根据水平和垂直2个维度进行定位；类似的，一根数轴上只有一个自由度，因此直线是一维空间，而一个空间中的点需要用三个变量$(x,y,z)$来表示，因此空间时三维的。还有其他高维空间</p>
<p>2️⃣ 笛卡尔把欧式几何的基本概念用代数的方法描绘了出来。各种几何图形是由点构成的，所以在笛卡尔坐标系中，可以通过确定点来确定任意几何图形，同时将几何图形之间的相对位置关系准确的表示出来</p>
<blockquote>
<p>平面上的一条直线对应代数中的二元一次方程；三维空间中一条直线对应代数中的三元一次方程；N维空间中对应着代数中的N元一次方程，正是由于直线和一次方程的对应关系，一次方程也称之为<strong>线性方程</strong></p>
<p align="center">
  <img src="/2023/10/02/math/8.png" width="100%" alt="Your image description">
  <br>
  <span style="color:gray"> N元一次方程和 N维空间的直线关系 </span>
</p>
</blockquote>
<p>3️⃣ 解析几何第一次将两个看似区别很大的数学分支统一起来，即代数和几何</p>
<p>解析几何也是一种工具，在宇宙中是不存在的</p>
<h1>代数篇</h1>
<p>早期的数学仅仅是对数字的运算，依赖算术就够了，运算可以分为两种：🅰️  正向运算，比如三只鸭子五条小狗，求腿和头的数量数量 ；🅱️  逆向运算，比如已知头和腿的数量，鸭子和狗的数量，正向运算很好解决，逆向运算就要难的多，就需要引入 <strong>未知数</strong>的概念，由此，算术逐渐发展成为代数</p>
<p>公元9世纪，阿拉伯学者<strong>花拉子米</strong>系统的提出了方程的解法，这让代数真正成为一个独立的分支，所以通常我们认为花拉子米是代数之父。文艺复兴时期之后，有塔塔利亚和卡尔达诺等人解决一元三次方程问题，再后来就是牛顿和莱布尼茨等人从变量和函数出发，逐步构建了近代代数的完整体系</p>
<h2 id="第8章-函数：重要的数学工具">第8章-函数：重要的数学工具</h2>
<h3 id="定义和本质：从静态到动态，从数量到趋势">定义和本质：从静态到动态，从数量到趋势</h3>
<p>数学家莱布尼茨在研究微积分时，提出函数的概念，初中教科书中函数的定义：</p>
<blockquote>
<p>在一个变化过程中有2个变量 $x,y$，如果对于 $x$在某一范围内的每一值，$y$都有唯一的值与它对应，那么就说 $y$是 $x$的函数， $x$是自变量， $y$是因变量</p>
</blockquote>
<p>函数的要素是：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>定义域</p>
</li>
<li class="lvl-2">
<p>映射关系（一对一的关系，或者多对一的关系）</p>
</li>
<li class="lvl-2">
<p>值域</p>
</li>
</ul>
<p>如果 $x$每增加一个单位， $y$增加1个或者 $k$个单位，那么这种函数关系就是线性的，其图像就是一条直线，如果 $x$每增加一个单位， $y$如果翻一番，这种函数关系就是指数的，其图像是一个上升非常快的曲线</p>
<p>函数的出现提升了人类的认知，将我们从单个数字、变量的关注，引向了趋势，从常数思维到变量思维，再到函数思维</p>
<h3 id="因果关系：决定性和相关性的差别">因果关系：决定性和相关性的差别</h3>
<p>一个函数和其反函数关于 $y=x$对称，如： $y=in_x$ 和 $y=e^x$，即<strong>对数函数和指数函数是互为反函数的</strong>，举个例子，假如购买10000元国债，$6%$的年复合增长率，12年后的本息是 :  $y= 10000*1.06^x$，代入 $x=12$，大约是20122元，也就是12年后，投资大约翻了一番；如果我们倒过来问：今天买入10000元国债，多少年后才能本息翻一番？若$x$ 是若干年后的本息总数，$y$是时间，那么：<br>
$$<br>
y=log_{1.06}^\frac{x}{10000}<br>
$$</p>
<p>带入$x=20000$， $y=11.89$，也就是12年左右。因为指数函数和对数函数的计算都不太直观，人们一般实用72定律，假设每年的投资回报率是$R%$，基本上经过$\frac{72}{R}$年，本息就可以翻一番</p>
<p>对于复杂的，由多个变量解决的函数来讲，每个变量和函数值只存在相关性，切忌把相关性和因果性混为一谈</p>
<h2 id="第9章-线性代数：超乎想象的实用工具">第9章-线性代数：超乎想象的实用工具</h2>
<p>高等数学的基础课是 🅰️ 线性代数，🅱️ 微积分</p>
<h3 id="向量：数据的方向与合力的形成">向量：数据的方向与合力的形成</h3>
<p>代数学除了给我们带来了方程和函数这2个工具，还揭示了数量的另外一个规律，即数量的方向性。数学上也需要有工具来描述带有方向的数量，这个工具就是向量，那些没有方向的数值称之为标量，一个向量可以用笛卡尔坐标系和极坐标2种方式表示，二者的公式如下：<br>
$$<br>
极坐标转笛卡尔坐标\<br>
a=r\times cos\theta \<br>
b=r\times sin\theta<br>
$$</p>
<p>$$<br>
笛卡尔坐标转极坐标\<br>
r=\sqrt{a<sup>2+b</sup>2} \<br>
tan\theta = b/a<br>
$$</p>
<p>1个向量的2种表述方式是等价的，有时候我们可能无法解决A问题，但是我们解决相对容易的A问题的等价问题。比如在笛卡尔坐标系中，多个向量的加法可以使用</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对应分量相加</p>
</li>
<li class="lvl-2">
<p>三角形法则：向量首尾相连，第一个向量的起点到最后一个向量的终点之间的线段</p>
</li>
<li class="lvl-2">
<p>平行四边形法则：平行四边行对角线</p>
</li>
</ul>
<p>如果我们使用极坐标表示向量，向量的加法就会变的很复杂</p>
<p>向量计算中，角度非常重要，在生活中，角度的测量是间接的，常见的测量角度的方法就是先确定三边边长，然后利用余弦定理计算出2个相邻边的夹角。余弦定理公式如下<br>
$$<br>
cosC=\frac{a<sup>2+b</sup>2-c^2}{2ab}<br>
$$<br>
或者<br>
$$<br>
c<sup>2=a</sup>2+b^2-2ab\ cosC<br>
$$</p>
<p>余弦定理的思想最早出现在欧几里得的《几何原本》中，公元15世纪，波斯数学家<strong>贾姆希德·卡西</strong>正式提出余弦定理，我们可以认为毕达哥拉斯定理（勾股定理）其实是余弦定理在直角情况下的特例，或者说余弦定理是毕达哥拉斯定理（勾股定理）的扩展，余弦定理的向量公式为：</p>
<p>$$<br>
cosC = \frac{\boldsymbol {a \cdot b}} {|a|\times|b|}<br>
$$<br>
多维向量 $\boldsymbol a =(a_1,a_2,…a_n)$ 和 $\boldsymbol b =(b_1,b_2,…b_n)$ 的点积<br>
$$<br>
\boldsymbol a · \boldsymbol b = a_1<em>b_1+a_2</em>b_2+…+a_n*b_n<br>
$$</p>
<p>$$<br>
|a| \times |b| = \sqrt{ {a_1}^2 + {a_2}^2 +…+{a_n}^2 } \times \sqrt{ {b_1}^2 + {b_2}^2 +…+{b_n}^2 }<br>
$$</p>
<p>在计算机应用中，常常使用余弦定理计算文本的分类，粗略的思想就是将一篇文章简化为一个向量，然后向量之间计算夹角，夹角相近的划分为一类</p>
<p>向量是线性代数的基础，在向量之上是更方便计算，也更复杂的矩阵</p>
<blockquote>
<p>点乘和数乘：点乘是2个向量相乘得到一个标量，数乘是一个数和向量相乘得到一个向量</p>
</blockquote>
<h3 id="矩阵：多元思维的应用">矩阵：多元思维的应用</h3>
<p>如下是一个矩阵，可以看成是同样维度的向量排在一起之后的结果，其中的每一行都被称为行向量；<strong>矩阵的加法即为对应位置上的数值相加</strong><br>
$$<br>
\begin{bmatrix} 3 &amp; 2 &amp; 5 &amp; 0\<br>
4 &amp; 2 &amp;3 &amp; 1\<br>
-1 &amp; 4 &amp; 5&amp; 6\<br>
\end{bmatrix}<br>
$$</p>
<blockquote>
<p>在实际的工作或者生活场景中，我们经常需要一个相对固定的大的原则，以及针对各种情况的小变动，此时就需要一个相对固定的核心矩阵，再加上一个增量矩阵，<strong>矩阵加法</strong>是一种思维方式</p>
</blockquote>
<p>矩阵乘法法则是：对应行和列相乘，$M \times N$ 的矩阵和$N \times K$的矩阵相乘，结果是一个$M \times K$的矩阵。矩阵和向量相乘可以理解为小批量处理，而矩阵彼此相乘则是大批量处理，后者更便于利用计算机自动完成大量的计算，现实中矩阵很多元素是0或者是非常小的值，他们对计算结果没有影响或者影响小到忽略不计，针对这类矩阵又特别的方法可以提高计算效率</p>
<p>举个例子，现在有2家投资银行，第一家投资银行投资3类金融产品(股票基金，债券基金，高风险基金)的回报率分别是$7%,3%,10%$ ,第二家投资银行的回报率分别是$8%,2%,9%$，我们将这两组数放到矩阵中<br>
$$<br>
\bold R =\begin{bmatrix}<br>
7% &amp; 3% &amp; 10% \<br>
8% &amp; 2% &amp;9%\<br>
\end{bmatrix}<br>
$$<br>
而投资总额是10000元，按照不同的资金分配方式，形成下列矩阵 $\bold P$<br>
$$<br>
\bold P =\begin{bmatrix}<br>
7000 &amp; 2000 &amp; \cdot\cdot\cdot \<br>
2000 &amp; 3000 &amp;\cdot\cdot\cdot\<br>
1000 &amp; 5000 &amp; \cdot\cdot\cdot<br>
\end{bmatrix}<br>
$$</p>
<p>然后让投资回报矩阵 $\bold R$和资金分配矩阵相乘 $\bold P$<br>
$$<br>
\bold R \cdot \bold P =\begin{bmatrix}<br>
7% &amp; 3% &amp; 10% \<br>
8% &amp; 2% &amp;9%\<br>
\end{bmatrix} \cdot \begin{bmatrix}<br>
7000 &amp; 2000 &amp; \cdot\cdot\cdot \<br>
2000 &amp; 3000 &amp;\cdot\cdot\cdot\<br>
1000 &amp; 5000 &amp; \cdot\cdot\cdot<br>
\end{bmatrix} = \begin{bmatrix}<br>
650 &amp; 770 &amp; \cdot\cdot\cdot \<br>
690 &amp; 730 &amp;\cdot\cdot\cdot\<br>
\end{bmatrix}<br>
$$</p>
<p>矩阵加法反映出核心数量值和微小增量的关系；矩阵的乘法，则体现出将很多维度信息综合考虑批处理的原则。<strong>矩阵的出现，使得我们今天能够利用计算机对大量的数据进行有效的处理</strong></p>
<h3 id="为什么向量和矩阵被称作是线性代数？">为什么向量和矩阵被称作是线性代数？</h3>
<p>这个我们可以观察到在进行矩阵相乘的运算中，左边矩阵中的数字可以被看成是一组常数系数，右边竖着的向量中的数则是未知数变量，如此矩阵和向量的乘法就变成了一组线性方程，如果将他们画在空间中，就是直线，平面或者立方体，他们都是线性的，不会有任何曲线，线性代数因此得名</p>
<h1>微积分篇</h1>
<p>微积分是初等数学和高等数学的分界线，微积分尝试用动态的眼光看待现实中的问题，在微积分出现之前，人们都是用相对静止的方式看待世界的，比如对于速度的概念，学习初等数学和早期的物理中，我们讨论的都是平均速度，但是有了微积分之后，我们就可以精准的把握瞬时速度，并且动态描述速度的变化</p>
<p>微积分有2位主要的发明人：牛顿和莱布尼茨</p>
<h2 id="第10章-微分：如何理解宏观和微观的变化">第10章-微分：如何理解宏观和微观的变化</h2>
<h3 id="导数：揭示事物变化的新规律">导数：揭示事物变化的新规律</h3>
<p>牛顿发明微积分的一个重要原因是他需要一个数学工具来解决力学问题，比如如何计算瞬时速度，牛顿从平均速度出发，利用极限的概念，推导出瞬时速度<br>
$$<br>
v(t_0) = \lim _{\Delta_t \to 0} \frac{\Delta_s}{\Delta_t} =  \lim _{\Delta_t \to 0} \frac{f(t_0+\Delta_t)-f(t_0)}{\Delta_t}<br>
$$<br>
$\Delta _t$ 趋近于0的时候，$ \frac {\Delta_s} {\Delta_t}$就是$t_0$时刻的瞬时速度，也即为曲线在$t _0$时刻的切线斜率。牛顿还认识到函数变化的速率（函数变化的速率即为函数曲线上每个点切线斜率），他称之为流数，即我们今天说的导数，<strong>导数是衡量一种函数本身变化快慢的工具，导数的本质就是对原函数变化快慢的规律性描述</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>原函数递增，导数大于0；原函数递减，导数小于0；反之亦然</p>
</li>
<li class="lvl-2">
<p>导数本身也是一种函数，其自身也有导数，称之为二阶导数。如速度是位移的导数，加速度是速度的导数，加速度是位移的二阶导数</p>
</li>
<li class="lvl-2">
<p>我们通常用$y = f(x)$表示原函数，$y’ = f’(x)$ 表示导函数 ，<sub>拉格朗日发明的方法</sub></p>
</li>
</ul>
<p align="center">
  <img src="/2023/10/02/math/9.png" width="100%" alt="Your image description">
  <br>
  <span style="color:gray"> 抛物线和直线图像 </span>
</p>
<p>现实世界中，很多概念不是简单的加减乘除的关系，而是导数的关系，如速度是位移的导数，加速度是速度的导数，动量是动能的导数，经济增长率是GDP的导数，导数的使得人类对变化快慢从感性提升到理性，从定性分析到定量分析</p>
<h3 id="微分：描述微观世界的工具">微分：描述微观世界的工具</h3>
<p>微分的定义，对函数空间$ F$ 中的任意函数 $ y: X \rightarrow \mathbb{R} $，它在 $x_0∈X$ 处的微分是<br>
$$<br>
dy=f’(x_0)dx<br>
$$</p>
<blockquote>
<figure class="highlight ex"><table><tbody><tr><td class="code"><pre><span class="line">导数<span class="symbol">:</span>是指函数在某一点处变化的快慢,是一种变化率</span><br><span class="line">微分<span class="symbol">:</span>是指函数在某一点处（趋近于无穷小）的变化量，是一种变化的量</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>导数也可以写成<br>
$$<br>
f’(x) = \frac{dy}{dx}<br>
$$<br>
假如我们现在计算圆柱体的体积，$\bold V = \pi\times r^2 \times h$，我们可以针对半径变化$dr$求微分$dV$，也可以针对高度变量$dh$ 求微分$dV$ ，在计算微分时候，只改变一个变量，我们称之为（针对某个特定变量的）偏微分，函数的偏微分和相应变量的比值是我们前面提到的导数，我们将这种导数称之为偏导数，如体积相对于半径的偏导数是$\frac{dV}{dr}$，体积相对于高度的偏导数是$\frac{dV}{dh}$</p>
<p>如果我们将2个微分以向量的形式放到一起，就是梯度，圆柱体积函数的梯度就是：<br>
$$<br>
\begin{bmatrix}<br>
\frac{dV}{dr} &amp; \frac{dV}{dh}<br>
\end{bmatrix} =<br>
\begin{bmatrix}<br>
2\pi rh &amp; \pi r^2<br>
\end{bmatrix}<br>
$$<br>
梯度的物理含义就是登山时路径最短路径/速度最快的方向就是梯度最大的方向，在我们做决策的时候，只要在任何时刻(或者是当前位置)知道了梯度，然后沿着最陡但是收益最大的路径前进就好了</p>
<p>一个函数在某一个点可导的必要条件是它在那个点至少是连续的，通俗来说，如果一个函数当变量$x$的增量$\Delta x$趋近于零时，函数$y$的增量 $\Delta y$ 也趋近于零，我们就说这个函数是连续的，即：<br>
$$<br>
\lim_{x \to a} f(x) = f(a)<br>
$$<br>
函数不连续的情况🅰️ 一种是跳跃状态，🅱️ 区间内除了一个点外都是连续的，第二种不连续的情况中，那个不连续的点被称之为奇点</p>
<p align="center">
  <img src="/2023/10/02/math/10.png" width="100%" alt="Your image description">
  <br>
  <span style="color:gray"> 函数不连续的情况 </span>
</p>
<p>一个函数连续，不一定可导，比如上图中从$a$的左边计算，导数是0.5，从$a$的右边计算，导数是0，一个点不可能有2个导数，因此，该函数在$a$点不可导；<strong>如果一条曲线在某一点是连续的，“光滑的”，该曲线在这个点就是可导的</strong></p>
<p>在企业的经营管理上，我们希望公司的营收是增长曲线是光滑的</p>
<p align="center">
  <img src="/2023/10/02/math/11.png" width="100%" alt="Your image description">
  <br>
  <span style="color:gray"> 函数连续 和公司经营之间的关系 </span>
</p>
<p>比如王老吉凉茶2008年，的营销策略中，”空中轰炸“做的很好，但是”地面挺进“没有做好</p>
<h2 id="第11章-积分：从微观变化了解宏观趋势">第11章-积分：从微观变化了解宏观趋势</h2>
<h3 id="积分：微分的逆运算">积分：微分的逆运算</h3>
<p>积分是微分的逆运算，<strong>给定一个曲线，求它下方到$x$轴之间的面积，就是积分</strong>，对于一般的速度曲线($x$ 轴是时间，$y$ 轴是速度) 它下方的面积就是这个速度的走过的距离，即距离是速度的积分，前面说过速度是距离的微分，由此可见，微分和积分是互为逆运算的</p>
<p>积分的其中一种计算方式是：将曲线划分的很细，用很多直方图加在一起近曲线下方的面积</p>
<p align="center">
  <img src="/2023/10/02/math/12.png" width="100%" alt="Your image description">
  <br>
  <span style="color:gray"> 积分的计算方式 </span>
</p>
<p>这么计算会有一定的误差，但是当我们把每一份分割的无穷小，这个误差就趋近于零了，此时 $\Delta x$ 就变成了 $dx$，我们将其写成积分的形式 $\int f(x) dx$</p>
<blockquote>
<p>积分符号$\int$ 就是 单词Sum拉长的 $S$，可以理解为多个小长方形的和</p>
</blockquote>
<p>为了表明积分是从 $x = a$ 一直累加到 $x = b$ 的，我们把起始点$a$ 和 $b$ 分别写到积分符号的上下方<br>
$$<br>
\int^b_a f(x) dx = \lim_{n \to \infty} \sum_{i=0}^{n-1} f(x_i) \cdot \Delta_x<br>
$$</p>
<p>通俗的讲，积分的运算就是整体等于部分之和，物理学中，积分反应很多物理量之间的关系，比如距离是速度的积分，速度是加速度的积分，体积是面积的积分</p>
<p>积分具有滞后效应，主要包含2点：</p>
<p>🅰️ 凡事需要通过积分获得数量，他的结果会滞后于瞬间变化，有时还要经过相当长的时间滞后才能看到</p>
<p>🅱️ 这种由积分获得的数量，一旦被大家都观察到之后，要逆转这个趋势是非常难的</p>
<p>比如飞轮效应，如果我们在飞轮上均匀用力，加速度恒定，而加速度是速度的积分，是一个累积后才能看到的量，因此具有滞后效应，所以飞轮效应是说刚开始变化转的很慢，但是随着时间的累积，转速越来越快，后来就像是飞一样，其实在工作生活中，我们可以自比飞轮，努力就和用力一样，今天晚上努力了，想要获得收获，需要一段时间的累积，这就是做积分，累积一段时间，我们的能力才会有明显提高，在提升成绩能力的同时，做出一件又一件漂亮的事情，逐渐树立良好的形象，所以某种程度上是<strong>能力是努力的积分，成绩是能力的积分，好形象是成绩的积分</strong></p>
<h3 id="最优化问题：用变化的眼光看最大值和最小值">最优化问题：用变化的眼光看最大值和最小值</h3>
<p>机器学习的过程其实就对目标函数的实现最优化的过程(求效用函数的最大值，或者是损失函数的最小值)，比如在求解二次方程最大值的过程中，前人的思路是基于比较的寻找，而牛顿的思路是将比较大小的问题转化为寻找函数拐点的问题，于是发明了导数（导数大于0递增），但是导数等于0并不代表这该点是最大值，只能说是函数的一个极大值</p>
<p>戴金德分割</p>
<p>动态的去看待数字，比如$0.99999 \cdot \cdot \cdot = 1$</p>
<p>狄利克雷函数，每个点都不连续，无法在笛卡尔坐标系中化出其图像<br>
$$<br>
f(x)=\left{<br>
\begin{aligned}<br>
1,x 是无理数 \<br>
0,x 是有理数<br>
\end{aligned}<br>
\right.<br>
$$<br>
测度的概念比常用的长度的概念更加的严密</p>
<p>建立在实数理论和测度理论上的微积分，也被称为实变函数论分析</p>
<h1>概率与数理统计篇</h1>
<p>概率论的创建人一般认为是：帕斯卡和费马</p>
<p>对概率论做出贡献的有：法国数学家，伯努利，拉普拉斯，泊松，德国的高斯，俄罗斯的切比雪夫，马尔可夫</p>
<h2 id="第12章-随机性和概率论：如何看待不确定性">第12章-随机性和概率论：如何看待不确定性</h2>
<h3 id="是谁定义了古典概率？">是谁定义了古典概率？</h3>
<p>最初给出概率论定义的是法国数学家<strong>拉普拉斯</strong>，拉普拉斯先定义了一种可能性相同的基本随机事件，也称为单位事件，基于单位事件的概念，拉普拉斯定义了古典概率，即一个随机事件A的概率$P(A)$可以按照下面的公式计算：<br>
$$<br>
P(A) = \frac{随机事件A 中所包含的单位事件的数量}{随机变量空间里的单位事件的数量}<br>
$$<br>
拿掷骰子来举例子的话，随机变量空间就是两个骰子点数的各种组合，有36种单位事件，即第一个骰子为1/2/3/4/5/6点时，第二骰子1~6点的6种情况。概率为1的事件称之为必然事件，概率为0的事件称之为不可能事件</p>
<h3 id="什么是伯努利实验？">什么是伯努利实验？</h3>
<blockquote>
<p>伯努利实验只有2种结果，非A即B，没有第三种状态，A和B发生的可能性不需要相同，但是在同样的情况下重复实验，A和B各自发生的概率需要一致</p>
</blockquote>
<p>比如一个口袋里有1个白球，三个红球，他们的大小重量都相同，从口袋里摸出来一个，看完颜色在放回去，这就是一个伯努利实验。如果每一次伯努利试验中事件A发生的概率为 $p$，进行 $N$次实验后，恰好发生了 $k$次的概率可以表示为<br>
$$<br>
P(N,k,p)= \frac{N!}{k!(N-k)!} p^{k} \cdot (1-p)^{N-k}<br>
$$<br>
伯努利实验只有2个结果，因此得到的概率分布也被称为2点分布(伯努分布/二项式分布)，二项式分布是一个钟形曲线，对称轴是$NP$ ，$N$ 越大，这个钟形曲线越窄，反之越宽扁</p>
<h3 id="均值，方差，标准差的意义在于什么？">均值，方差，标准差的意义在于什么？</h3>
<ol>
<li class="lvl-3">
<p>均值：数据的平均情况，用$\mu$ 表示，也叫做<strong>数学期望</strong></p>
</li>
<li class="lvl-3">
<p>方差：数据偏离均值的情况，用 $\sigma ^{2}$ 表示</p>
</li>
<li class="lvl-3">
<p>标准差：对方差开方，用 $\sigma$ 表示，可以用来直接和均值比较</p>
</li>
</ol>
<p>一般而言，一个随机变量的概率分布曲线越平，方差越大，越向中间集中，方差越小。或者这样理解：<strong>数据随机性越大，方差越大，反之亦然</strong></p>
<blockquote>
<p>拉普拉斯发明了拉普拉斯变换，拿破仑是他的学生</p>
</blockquote>
<h3 id="什么是大数定律？">什么是大数定律？</h3>
<p>大数定理指的是同样的随机试验，重复的次数越多，其结果的平均值就越接近该随机变量（或者随机事件）发生的数学期望，其中弱大数定理的定义为：同一概率分布的样本序列 $X_1,X_2,…,X_n$ 的均值 $\bar{X_n}$ 依概率趋近于它的数学期望 $\mu$，即给定一个正数 $\epsilon$ ，都有<br>
$$<br>
lim_{n\rightarrow \infty} P(|\bar  {X_n} - \mu| &gt; \epsilon) = 0<br>
$$</p>
<h2 id="第13章-小概率和大概率：如何资源共享和消除不确定性">第13章-小概率和大概率：如何资源共享和消除不确定性</h2>
<h3 id="什么是泊松分布？">什么是泊松分布？</h3>
<p>泊松分布是二项分布的一种特例，在伯努利实验中，如果随机时间A发生的概率通常很小，但是实验的次数很大，这种分布被称为 <strong>泊松分布</strong>，发生车祸的情况就是如此<br>
$$<br>
P(X = k) = e^{-λ} \cdot \frac{λ^k}{k!}<br>
$$<br>
其中：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>P(X = k) 是随机变量 X 等于 k 的概率</p>
</li>
<li class="lvl-2">
<p>e 是自然对数的底（约等于 2.71828）</p>
</li>
<li class="lvl-2">
<p>λ 是在一个给定的时间间隔或空间内事件的平均发生次数</p>
</li>
<li class="lvl-2">
<p>k 是事件发生的次数，k = 0, 1, 2, …</p>
</li>
</ul>
<p><strong>泊松分布揭示的是诸多小概率事件发生时的统计规律</strong></p>
<h3 id="什么是高斯分布？">什么是高斯分布？</h3>
<p>也称作是 正态分布（normal distribution），符合正态分布的随机变量呈现中间大，两头小的特性，数学家高斯将一个随机变量 $X$ 的概率分布和它平均值 $\mu$ ,方差 $ \sigma ^2$ 联系一下，均值和方差满足以下规律的概率分布称为 正态分布<br>
$$<br>
f(x)= {\frac{e^{- {\frac {(x-\mu)<sup>{2}}{2\sigma</sup>{2}}} }}{\sigma\sqrt{2\pi}}}<br>
$$<br>
$f(x)$	=	probability density function<br>
$\sigma$	=	standard deviation<br>
$\mu$	=	mean</p>
<p align="center">
  <img src="/2023/10/02/math/16.png" width="90%" alt="Your image description">
  <br>
  <span style="color:gray"> 高斯分布的图像 </span>
</p>
<p align="center">
  <img src="/2023/10/02/math/17.png" width="90%" alt="Your image description">
  <br>
  <span style="color:gray"> 高斯分布函数的概率： </span>
</p>
<ol>
<li class="lvl-3">
<p>在一个标准差内，我们对平均值的置信度为68%</p>
</li>
<li class="lvl-3">
<p>2个 $\sigma$ 的 置信度为95%</p>
</li>
<li class="lvl-3">
<p>3个 $\sigma$  置信度为99.7%</p>
</li>
</ol>
<h3 id="谁完成了概率公理化？">谁完成了概率公理化？</h3>
<p>柯尔莫哥洛夫（Andrey Nikolaevich Kolmogorov），他在概率论、湍流理论、数学物理学和信息论等多个领域作出了重要贡献。为现代概率论奠定了坚实的数学基础。柯尔莫哥洛夫在1933年发表的著作《概率论基础》中，提出了一套基于测度论的概率论体系，这一体系后来成为现代概率论的基础</p>
<h3 id="样本空间，随机事件空间，测度等概念">样本空间，随机事件空间，测度等概念</h3>
<p>样本空间 $\Omega$ ：它包含我们要讨论的随机事件所有可能得结果。例如，当你抛掷一枚硬币时，样本空间是 $\Omega =  {正面, 反面}$，掷骰子有6中情况 $\Omega =  {1,2,3,4,5,6}$，高斯分布的样本空间是实数 $\Omega =  \bold R$</p>
<p>随机事件空间 ，集合 $F$，包含我们要讨论的所有随机事件，比如掷骰子不超过4点的情况是一个随机事件，可以表示为 $A_1 ={1,2,3,4}$，掷骰子结果为偶数点的随机事件可以表示为 $A_2 = {2,4,6}$。<strong>这些随机事件可以构成一个集合</strong></p>
<p>对于无线概率空间里的随机事件，可以是一个范围，比如一个传感器接收到的电信号在 $0 \sim 5V$ 之间的任何电压，即便有无数情况，但是可以划定范围 $0\sim 1V$ 或者 $4.5\sim5V$ 之间</p>
<p>测度 $P$：也就是一个函数 $P$，他将集合中的任何一个随机事件对应为一个数值，也即$P:F \rightarrow \bold R$  。只要这个函数 $P$ 满足如下的3个公理，它就是概率函数</p>
<ol>
<li class="lvl-3">
<p>公理1，任何事件的概率是在0和1之间（包含0和1）的一个实数，也就是说 $P: F \rightarrow [0,1]$</p>
</li>
<li class="lvl-3">
<p>公理2，样本空间的概率为1，即 $P(\Omega) = 1$，比如掷骰子，从1点到6点加在一起构成样本空间，所有这6种情况放在一起的概率为1</p>
</li>
<li class="lvl-3">
<p>公理3，如果2个随机事件 $A$ 和 $B$ 是互斥的，也就是说 $A$发生的话，$B$ 一定不会发生，那么 $A$ 发生或者 $B$ 发生这件事发生的概率，就是 $A$ 单独发生的概率 ，加上 $B$单独发生的概率。即为互斥事件的加法法则：</p>
<p>如果 $ A \cap B  = \emptyset$, 那么 $P(A \cup B) = P(A) + P(B)$</p>
<p>举个例子：比如掷骰子1点朝上和2点朝上显然是互斥事件，1点或者2点任意一种情况发生的概率，就等于只有一点朝上的概率，加上只有2点朝上的概率</p>
</li>
</ol>
<p>由以上3条公理，可以推导出一些概率论定理：</p>
<ol>
<li class="lvl-3">
<p>互补时间的概率之和等于1</p>
</li>
<li class="lvl-3">
<p>不可能事件的概率为0</p>
</li>
</ol>
<h2 id="第14章-前提条件：度量随机性的新方法">第14章-前提条件：度量随机性的新方法</h2>
<p>世界上有很多随机事件的发生是彼此相关的，比如今天的天气和昨天的天气有关，在一句话中，某个词是否出现，和上一个词不仅相关，而且关系极大。同一个随机事件，在不同条件下发生的概率，差异很大，我们需要将随机事件发生的条件也考虑进去</p>
<h3 id="什么是大数定理？">什么是大数定理？</h3>
<p>当 $ C$ 足够大的时候， $ C(A) \rightarrow P(A)$ ，即用一个随机事件 $A$发生的次数 $ C(A)$ ，除以总的实验次数 $ C$</p>
<h3 id="条件概率">条件概率</h3>
<p>$$<br>
P(A|B) = f(A|B) = \frac{ C(A,B) }{C(B)} \tag{1}<br>
$$</p>
<p>$$<br>
P(A|B) = \frac{P(A,B)}{P(B)} \tag{2}<br>
$$</p>
<p>$$<br>
P(A,B) = P(A|B) \cdot P(B) \tag{3}<br>
$$</p>
<p>其中</p>
<ol>
<li class="lvl-3">
<p>$C$ 表示总的实验次数，即样本总数</p>
</li>
<li class="lvl-3">
<p>$C(A)$ 随机事件发生的次数</p>
</li>
<li class="lvl-3">
<p>$C(B)$ 条件发生的次数</p>
</li>
<li class="lvl-3">
<p>$C(A,B)$ 条件和随机事件同时发生的次数</p>
</li>
<li class="lvl-3">
<p>$P(A,B)$ 联合概率</p>
</li>
<li class="lvl-3">
<p>$P(A|B)$ 条件概率</p>
</li>
</ol>
<p>对于一个随机事件A，我们有三种概率</p>
<ol>
<li class="lvl-3">
<p>没有任何限制条件一般意义上的概率 $P(A )$</p>
</li>
<li class="lvl-3">
<p>它在条件 B发生后才发生的条件概率 $P(A|B)$</p>
</li>
<li class="lvl-3">
<p>它和B一同出现的联合概率 $P(A,B)$</p>
</li>
</ol>
<h3 id="一般的概率分布">一般的概率分布</h3>
<p align="center">
  <img src="/2023/10/02/math/18.png" width="90%" alt="Your image description">
  <br>
  <span style="color:gray"> 概率分布 </span>
</p>
$$
P(A)  = P(A,B) + P(A,\overline B) \tag{a}
$$
<p>$$<br>
P(A) = P(A|B) \cdot P(B) + P(A|\overline B) \cdot P(\overline B) \tag{b}<br>
$$</p>
<h3 id="概率和条件概率的差异在哪？">概率和条件概率的差异在哪？</h3>
<p>一个随机事件 $X$ 发生与否的条件 $Y$ 可能有 $k$ 中的情况<br>
$$<br>
P(A)= \sum _{i=1}^{k} P(A|B_i) P(B_i)<br>
$$<br>
其中 $B_1,B_2,…,B_k$ 构成了 $Y$ 的全部选项，在现实使用中，要注意不要只是累计其中的几项，而是全部。世界上最权威的杂志：《自然》，《科学》</p>
<h3 id="联合概率和条件概率的差异">联合概率和条件概率的差异</h3>
<p>这里举个🌰：有2中疾病 $C_1$ 和 $C_2$ ，他们的死亡率分别是 10% 和 3%，那么那种疾病更危险？</p>
<p>很多人看到这个问题，会认为死亡率 10%比3%高的多，这里很容易忽略的一个重要事实就是：一个人得上这2种病的概率，这里假设是 $P(C_1)$  和 $P(C_2)$ ，假设 $X$ 代表病死这个随机事件，那么就有 $10% = P(X|C_1)$ , $3% = P(X|C_2)$ ，直接对比2者，比对的是条件概率，即为已经发病条件下的危险性</p>
<p>但是比对2个病更危险的情况，衡量标准应该是联合概率，即 $P(C_1,X),P(C_2,X)$ 的大小，根据条件概率的公式：</p>
<ol>
<li class="lvl-4">
<p>$P(C_1,X) = P(X|C_1) P(C_1)$</p>
</li>
<li class="lvl-4">
<p>$P(C_2,X) = P(X|C_2) P(C_2)$</p>
</li>
</ol>
<p>假设 $P(C_1) = 0.1%$ , $P(C_2) = 2%$ ，那么计算出第二种疾病是第一种疾病危险性的 6倍</p>
<h3 id="条件概率和相关性有什么关系？">条件概率和相关性有什么关系？</h3>
<p>条件概率中的事件，本身也是一种随机事件，它可以有不同的取值，因此条件概率在本质上揭示的是2个随机事件的相关性。利用这种相关性，可以解决很多信息处理问题</p>
<h3 id="贝叶斯公式的用法">贝叶斯公式的用法</h3>
<p>计算 田七在“中药”这个条件下出现的概率时，是从中药喝田七的联合概率出发，利用条件概率公式得出：<br>
$$<br>
P(田七|中药) = \frac{P(中药，田七)}{P(中药)} \tag{a}<br>
$$<br>
我们尝试将条件和结果互换，计算如果后一词是田七时，前一个词是中药的概率，得到如下公式：<br>
$$<br>
P(中药|田七) = \frac{P(中药，田七)}{P(田七)} \tag{b}<br>
$$<br>
将 a,b2个公式合并，得到<br>
$$<br>
P(中药|田七) = \frac{P(田七|中药) P(中药)}{P(田七)}<br>
$$<br>
将该公式泛化，得到<br>
$$<br>
P(X|Y) = \frac{P(Y|X)P(X)}{P(X)}<br>
$$<br>
有时候，我们很难计算 $P(X|Y)$ ，但是知道 $P(Y|X)$，于是就可以用贝叶斯公司间接计算出 $P(X|Y)$</p>
<h3 id="准确率和召回率的关系">准确率和召回率的关系</h3>
<p>在疾病检测，信息检索，人脸识别等实际应用中，都会出现准确率和召回率的矛盾，其关系如下图，经过技术改进后后，整个函数的曲线会上移</p>
<p align="center">
  <img src="/2023/10/02/math/19.png" width="90%" alt="Your image description">
  <br>
  <span style="color:gray">准确率和召回率的关系 </span>
</p>
<h2 id="第15章-统计学和数据方法：准确估算概率的前提">第15章-统计学和数据方法：准确估算概率的前提</h2>
<h3 id="统计学是概率论是应用部分么？">统计学是概率论是应用部分么？</h3>
<p>统计学是一门独立的学科，他是收集，分析，解释，称述数据的科学，只是说统计学的数学基础是概率论的，统计学除了一些数学工作，还有一些非数学工作：</p>
<ol>
<li class="lvl-3">
<p>如何称述数学让大家接收我们的结论，比如各种图标</p>
</li>
<li class="lvl-3">
<p>保存和整理数据等</p>
</li>
</ol>
<h3 id="什么是霍桑效应？">什么是霍桑效应？</h3>
<blockquote>
<p>被观察者知道自己成为被观察对象而改变行为倾向的反应</p>
</blockquote>
<h3 id="什么是齐普夫定律？">什么是齐普夫定律？</h3>
<p>美国20世纪初的语言学家，经过对各种语言中词频的统计发现，</p>
<ol>
<li class="lvl-3">
<p>一个词的排位和它词频的乘积，几乎是一个常熟。比如在汉语中“的”是最常见的词，排位第一，它的词频大约是6%，于是 $1\times 6% = 6% $ 。第二高频的词为 “是”，词频大约是 $3%$ ， 于是  $2 \times 3% = 6%$ 。80:20定律是齐普夫定律的特例</p>
</li>
<li class="lvl-3">
<p>词频乘以相应的词的数量，得到的结果也近乎是一个常数。假设只出现1次的词有 $N_1$个，出现2次的词有 $N_2$个，那么 $1 \times N_1$ 和 $2 \times N_2$ 都差不多</p>
</li>
</ol>
<h3 id="什么是古德-图灵折扣估计？">什么是古德-图灵折扣估计？</h3>
<p>古德-图灵估计主要解决的问题是：在一个概率模型中，如果你有一个包含许多事件的样本数据集，其中某些事件可能没有在样本中出现，你如何估计这些未见事件的概率？即：<strong>处理零概率和小概率事件</strong></p>
<p>古德-图灵估计的核心思想是从高频的随机事件中拿出一点概率总量（probability mass） 分配到低频的随机事件头上，再从低频的随机事件中拿出一些概率总量，分配给统计时没见到的随机事件</p>
<h3 id="古德-图灵折扣估计的做法"><strong>古德-图灵折扣估计的做法</strong></h3>
<p>假设出现 $r$ 次的单词有 $N_r$个，那么一个语料库文本中所有单词的总次数就是 $N=1\times N_1 + 2 \times N_2 + 3\times N_3 + … + k \times N_k$ ，其中 $k$ 是最高的词频。在这个公式中，没有考虑那些原本没有被考虑进来的词，这些词在之前的统计中出现0次，这里假设 这次单词有 $N_0$个</p>
<p>古德根据经验，假设 $N_0 &gt; N_1$ 即：那些没有被统计出来的词，数量比在统计时出现了至少一次的词多很多，接下来古德是这样调整词频的：</p>
<ol>
<li class="lvl-3">
<p>一个单词如果原来出现了0次，就将出现的次数调整为 $\frac{N_1}{N_0}$ 次，这是一个0到1的数，不再是0了</p>
</li>
<li class="lvl-3">
<p>一个单词如果原来出现了1次，就将出现的次数调整为 $\frac{2N_2}{N_1}$ 次，通常是一个1到2之间的数</p>
</li>
<li class="lvl-3">
<p>一般情况，如果原来出现了 $r$ 次，就调整为 $\frac{(r+1)N_{r+1}}{N_r}$</p>
</li>
</ol>
<p>那么被通缉预料中所有词的总的次数变成了</p>
<ol>
<li class="lvl-3">
<p>0次的数量有$N_0$个，它们每个被分配了 $\frac{N_1}{N_0}$ 次，总共 $N_1$次</p>
</li>
<li class="lvl-3">
<p>1次的数量有$N_1$个，它们每个被分配了 $\frac{2N_2}{N_1}$ 次，总共 $2N_2$次</p>
</li>
<li class="lvl-3">
<p>$k-1$次的数量有$N_{k-1}$个，它们每个被分配了 $\frac{(k-1)N_k}{N_{k-1}}$ 次，总共 $kN_k$次</p>
</li>
</ol>
<p>至此，被分配的总次数加起来是 $N=1\times N_1 + 2 \times N_2 + 3\times N_3 + … + k \times N_k$ 。古德，将出现 $i$ 次的词总的次数，分配给了出现 $i-1$ 次的那些词。对上出现次数为0到$k-1$ 的词，按照以上方式分配概率，当一个词的出现次数大于 $t$ 次之后，就认定他们出现了t次，不在调整。这样一来，被分配的总次数加起来就可能大于 $N $，因此在计算概率时，需要做归一化，保证所有的概率加起来依然等于1。这种做法被称之为 <strong>古德-图灵折扣估计法</strong></p>
<h3 id="什么是删除插值法？">什么是删除插值法？</h3>
<p>核心思想是遇到同级数量不足时，就设法在更大范围中找到一个可靠性较高的统计结果来近似。比如想要了解每一个城市居民特性，一个办法就是在每个城市抽样统计一下，但福州市就找到3个样本，此时我们将福建省的统计结果最显著的特性，补充到福州市的统计结果中</p>
<p>将 $f(X|Y)$ 和 $f(X)$ 的线性组合作为 条件概率 $P(X|Y)$ 的估计<br>
$$<br>
P(X|Y) = \lambda_1 f(X|Y) + \lambda_2 f(X) \tag{a}<br>
$$</p>
<p>$$<br>
\lambda_1 + \lambda_2 = 1 \tag{b}<br>
$$</p>
<h3 id="概率是一种世界观，统计是一种方法论">概率是一种世界观，统计是一种方法论</h3>
<p>很多时候，世界没有简单的黑与白，只有灰度</p>
<h2 id="第16章-数学在人类知识体系中的位置">第16章-数学在人类知识体系中的位置</h2>
<p>笛卡尔告诉人类要通过理性过了直接经验，然后才能获得知识。即通过理性的推理，实现去伪存真</p>
<p>如果我们仅仅像古希腊奴隶那样为了谋生而学习，掌握一点技能就够了，但是如果我们想苏格拉底那样把自己看成主任，以这个态度来学习，来做事情，就需要再认知层面有所提高了</p>
<p>拉瓦锡说：“没有天平就没有真理”，他提出了氧化说</p>
<p>在集合论中为什么所有元素都必须是独一无二的？比如整数的集合中只能有一个3，因为<strong>同一律，即一个事物只能是其本身</strong>。同一律，确认我们说的是的确是同一个东西</p>
<p>矛盾律：在某个十五的某个一方面（在同一时刻）不可能既是 A又不是 A，反证法就是基于矛盾律</p>
<h1>增加</h1>
<h2 id="排列组合">排列组合<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></h2>
<p>排列名名称为：Arrangement，组合英文名叫 Combination。<strong>A 和 C 的本质区别在于：决策的顺序对结果有没有影响</strong></p>
<h3 id="排列">排列</h3>
<p><strong>如果要想在 n 个物品中，按顺序的选择 k 个物品，那么选择的方式总共有这么多种</strong><br>
$$<br>
A(n,k) = \frac{n!}{(n-k)!}<br>
$$</p>
<p>比如 $A(4,1) = \frac{4!}{3!}= \frac{24}{6}=4$</p>
<h3 id="组合">组合</h3>
<p><strong>如果要想在 n 个物品中，选择 k 个物品出来，选择的顺序无所谓，那么选择的方式总共有这么多种</strong><br>
$$<br>
C(n,k) = \frac{n!}{(n-k)! \times k!}<br>
$$</p>
<p>比如 $C(4,3) = \frac{4!}{1! \times 3!} = 4$，同时 $C(4,3) = C(4,1)$</p>
<h2 id="傅里叶变化">傅里叶变化</h2>
<p>Fourier transform<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup>，十九世纪法国的数学家傅立叶，发现任何周期性的函数(信号)都等同于一些三角函数的线性组合</p>
<p>计算机上的声音和图像信号、工程上的任何波动信息、数学上的解微分方程、天文学上对遥远星体的观测，到处都要用到傅里叶变换。你用手机播放MP3音乐、看图片、语音识别，这些都是傅里叶变换的日常应用，下面是wiki的解释：</p>
<blockquote>
<p>傅里叶变换是一种线性积分变换，用于信号在时域(或空域)和频域之间的变换</p>
</blockquote>
<p>以上的定义是从数学的角度对傅立叶变换做出的解释，从本质上来说，</p>
<blockquote>
<p>傅里叶变换，是把一个复杂事物拆解成一堆标准化的简单事物的方法</p>
</blockquote>
<p>声音其实是空气的震动。拨动一下琴弦，耳边传来一个纯净的、而且在短时间内是持续的声音。比如一个A 音符，大约每秒钟要震动440 次，所以除非是重低音，你通常不一定能感觉到震动，但是你能感到音量和音调，<strong>音量就是震动的幅度，音调就是震动的频率</strong></p>
<p>下图是一个</p>
<p align="center">
  <img src="/2023/10/02/math/13.png" width="90%" alt="Your image description">
  <br>
  <span style="color:gray"> 频率固定的简单音调的图像，横坐标是时间，纵坐标是震动的幅度 </span>
</p>
<blockquote>
<p><strong>所谓傅里叶变换就是说，如果我们先规定好一系列的简单波动，那么任何一个复杂的波动，就都可以用这些简单波动拆解</strong></p>
</blockquote>
<p align="center">
  <img src="/2023/10/02/math/14.png" width="90%" alt="Your image description">
  <br>
  <span style="color:gray"> 傅里叶变换 </span>
</p>
<p>一条复杂的曲线，可是我们只需要用几个数字就可以描写它</p>
<h2 id="卷积">卷积</h2>
<h3 id="卷积的公式和定义是什么？">卷积<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>的公式和定义是什么？</h3>
<p>卷积是数据分析一种重要的运算。设 $f(x)$、$g(x)$，是 $\mathbb {R} $上的两个<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%AF%E5%87%BD%E6%95%B0">可积函数</a>，作<a href="https://zh.wikipedia.org/wiki/%E7%A7%AF%E5%88%86">积分</a>：<br>
$$<br>
\int _{-\infty }^{\infty }f(\tau )g(x-\tau ),\mathrm {d} \tau<br>
$$<br>
随着 $x$ 的不同取值，这个积分就定义了一个新函数 $h(x)$，称为函数 $f$与 $g$的卷积，记为$h(x)=(f*g)(x)$</p>
<h3 id="给定2个数组，如何计算卷积-离散卷积-？">给定2个数组，如何计算卷积(离散卷积)？</h3>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: np.convolve((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">Out[<span class="number">2</span>]: array([ <span class="number">4</span>, <span class="number">13</span>, <span class="number">28</span>, <span class="number">27</span>, <span class="number">18</span>])</span><br></pre></td></tr></tbody></table></figure>
<p>$(1,2,3)$  和 $(4,5,6)$ 的卷积为 ( $1\times 4,1\times 5 + 2\times 4,1\times 6 + 2 \times 5 + 3\times 4,2\times 6 + 3 \times 5 ,3\times 6 )$。这里注意要将，数组2先逆序</p>
<p>下面展示展示多项式+合并同类项 和 卷积是一样的<br>
$$<br>
(1,2,3) * (4,5,6) = (4,13,28,27,18) \<br>
(1 + 2x + 3x^2)(4 + 5x + 6x^2) = 4 + 13x + 28x^2 + 27x^3 + 18x^4<br>
$$</p>
<p align="center">
  <img src="/2023/10/02/math/15.png" width="90%" alt="Your image description">
  <br>
  <span style="color:gray"> 卷积 </span>
</p>
<h3 id="卷积与傅里叶变换有着密切的关系？">卷积与傅里叶变换有着密切的关系？</h3>
<p>两函数的傅里叶变换的乘积等于，它们卷积后的傅里叶变换</p>
<h3 id="卷积有哪些应用？">卷积有哪些应用？</h3>
<p>对于原始数据 A$[1,2,3,4,5,6,7,8,…]$， 我们可以引如 B，计算A和B的卷积，这样就可以得到原始数据的平滑版本，</p>
<p>🅰️ 当 $B = [0.2,0.2,0.2,0.2,0.2]$ ，那么相当于对原始数据求均值</p>
<p>🅱️ 当 $B = [0.1,0.2,0.4,0.2,0.1]$ ，那么相当于对原始数据中间的数据一个较大的权重</p>
<ol>
<li class="lvl-3">
<p>图像处理，可以模糊化图片（比如高斯模糊），应用于卷积神经网络</p>
</li>
<li class="lvl-3">
<p>求解微分方程</p>
</li>
<li class="lvl-3">
<p>概率论</p>
</li>
<li class="lvl-3">
<p>多项式乘法，可以加速卷积计算方式，思路是采点相乘，之后求解系数(方程系数)，即 <strong>FFT算法</strong></p>
</li>
</ol>
<h2 id="马尔可夫">马尔可夫</h2>
<p>假设 S是一个有意义的句子 $S = w_1,w_2,…,w_n $，那么 S 在文本中出现的概率表示为<br>
$$<br>
P(S) = P(w_1,w_2,…,w_n)<br>
$$</p>
<p>使用条件概率的公式，将 $P(w_1,w_2,…,w_n)$ 展开为：<br>
$$<br>
P(w_1,w_2,…,w_n) =\<br>
P(w_1) P(w_2|w_1)P(w_3|w1,w2)…P(w_n|w_1,w2,…w_{n-1})<br>
$$<br>
19世纪到20世纪初，俄国数学家马尔科可夫(Andrey Markov)，提出一个假设：</p>
<blockquote>
<p>任意一个词 $w_i$ 出现的概率只和它前面的词 $w_{i-1}$ 有关</p>
</blockquote>
<p>于是<br>
$$<br>
\begin{align*}<br>
P(S) &amp;=  P(w_1) P(w_2|w_1)P(w_3|w_2)…P(w_i|w_{i-1})…P(w_n|w_{n-1})<br>
\end{align*}<br>
$$</p>
<p>如此对应的统计语言模型，叫做二元模型（Bigram Model）,同样，我们可以假设 任意一个词 $w_i$ 出现的概率和它前面 n个词有关，那就是 $N$ 元模型</p>
<p>接下来就是如何估计条件概率  $P(w_i|w_{i-1})$ 的值，<br>
$$<br>
P(w_i|w_{i-1}) = \frac{P(w_{i-1},w_i)}{P(w_{i -1})}  \=<br>
\frac{\C(w_{i-1},w_i)}{\C} /  \frac{\C(w_{i-1})}{\C} \=<br>
\frac{\C(w_{i-1},w_i)}{\C(w_{i-1})} \<br>
$$</p>
<p>其中，$\C$ 表示语料库（corpus）的大小，$\C(w_{i-1},w_i)$ 表示 $w_{i-1},w_i$这对词在语料库前后出现了多少次，$\C(w_{i-1})$ 表示 $w_{i-1}$ 在语料库中出现了多少次</p>
<p>那我们这里假设</p>
<blockquote>
<p>文本中的每个词 $w_i$ 和只和前面 $N -1$ 个词有关，</p>
</blockquote>
<p>这样当前词 $w_i$ 的概率只取决于前面 $N-1$个词<br>
$$<br>
P(w_i|w_1,w_2,…,w_{i-2},w_{i-1}) \=<br>
P(w_i|w_{i-N+1},w_{i-N+2},…,w_{i-1} )<br>
$$<br>
$N = 1$ 即为一元模型，实际上是一个和上下文无关的模型；$N=2$ 即为二元模型，$N=3$，三元模型，更高阶的模型就使用的少了。即为 <strong>N-1阶马尔可夫假设</strong></p>
<h3 id="马尔可夫假设的局限性是什么？">马尔可夫假设的局限性是什么？</h3>
<p>在自然语言中，上下文之间相关性的跨度可能非常大，甚至从一个段落到另一个段落，无论如何提升模型的阶数，都没办法获取这种相关性</p>
<h3 id="如何处理概率不平滑的问题（即概率为0或者为1）？">如何处理概率不平滑的问题（即概率为0或者为1）？</h3>
<p>使用语言模型，需要知道模型中所有的条件概率，我们称之为模型的参数，通过对语料库的统计，得到这些参数的过程，就是对语言模型的训练，拿二元模型来说，可能会遇到 $\C (w_{i-1},w_i) = 0 $ 或者 $\C(w_{i-1},w_i)$ 和 ${\C(w_{i-1})}$ 都只出现了1次。怎么处理这种问题？使用古德-图灵估计（Good-Turning Estimate）</p>
<p>马尔科夫假设在计算机自然语言处理领域有着重要的应用</p>
<h2 id="张量">张量</h2>
<p>首先理解三维组数。为了形象化三维数组，你可以把它想象成一叠放在一起的二维表格。每个表格都是一个二维数组，拥有自己的行和列</p>
<p>张量（Tensor）是一个数学对象，用于表示一组数据和这些数据之间的规则。张量的核心思想是一种扩展，它将标量、向量和矩阵扩展到更高维度</p>
<ol>
<li class="lvl-3">
<p><strong>标量 (0维张量)</strong>: 标量是一个单独的数字，没有方向，例如：5, -3.2, 0 等</p>
</li>
<li class="lvl-3">
<p><strong>向量 (1维张量)</strong>: 向量是一维数组，即数字的有序列表。它有方向。例如：[1, 2, 3], [-1, 0, 1] 等</p>
</li>
<li class="lvl-3">
<p><strong>矩阵 (2维张量)</strong>: 矩阵是一个二维数组，具有行和列。例如：<code>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code> 是一个3x3的矩阵</p>
</li>
<li class="lvl-3">
<p><strong>高维张量 (3维及以上)</strong>: 当超过2个维度时，我们通常称其为张量。例如，3维张量可以视为“矩阵的数组”。一个典型的例子是图像数据，可以表示为(高度, 宽度, 颜色通道)的3维张量</p>
</li>
</ol>
<p>在深度学习和机器学习中，张量是一个核心概念，因为它们是用于表示数据和模型参数的主要数据结构。</p>
<p>举例，在Python中，我们可以使用NumPy库来创建和操作张量：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个0维张量（标量）</span></span><br><span class="line">scalar = np.array(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个1维张量（向量）</span></span><br><span class="line">vector = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个2维张量（矩阵）</span></span><br><span class="line">matrix = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个3维张量</span></span><br><span class="line">tensor_3d = np.array([[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看张量的形状</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Scalar shape:"</span>, scalar.shape</span><br></pre></td></tr></tbody></table></figure>
<p>创建一个三维数组</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">-- 创建一个三维数组，尺寸为 2x3x4 (深度 x 行 x 列)</span><br><span class="line">three_dim_array = [</span><br><span class="line">    [  <span class="comment"># 第一个二维数组</span></span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],  <span class="comment"># 第一行</span></span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],  <span class="comment"># 第二行</span></span><br><span class="line">        [<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>] <span class="comment"># 第三行</span></span><br><span class="line">    ],</span><br><span class="line">    [  <span class="comment"># 第二个二维数组</span></span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>], <span class="comment"># 第一行</span></span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>], <span class="comment"># 第二行</span></span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]  <span class="comment"># 第三行</span></span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="向量化计算">向量化计算</h2>
<p>在编程和数据分析中，向量化通常指的是利用现代CPU的SIMD（Single Instruction Multiple Data，单指令多数据流）指令集，使一条指令能同时对一组（向量）数据进行操作</p>
<p>举个例子。假设你有两个数组，你需要将这两个数组对应位置的元素相加。传统的做法中，你可能需要一个for循环来逐个地处理这些元素：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">c = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    c.append(a[i] + b[i])</span><br></pre></td></tr></tbody></table></figure>
<p>但如果使用向量化的方法，你可以一次处理所有的元素：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">b = np.array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">c = a + b</span><br></pre></td></tr></tbody></table></figure>
<p>机器学习和数据分析，向量化技术非常关键，可以显著提升计算性能</p>
<h1>终篇</h1>
<p>人想要成为精英，首先得在精神层面成为精英，这样才能在精英的方式思考，以主人的心态做事，才能超出常人</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>碳14：<a href="https://zh.wikipedia.org/wiki/%E7%A2%B3-14">https://zh.wikipedia.org/wiki/碳-14</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>排列组合参考：<a href="https://zhuanlan.zhihu.com/p/41855459">https://zhuanlan.zhihu.com/p/41855459</a> <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>傅里叶变化参考：<a href="https://www.dedao.cn/course/article?id=dA5eO3NDrGk8KP0djQK2oxp9MRBzQP&amp;source=search%EF%BC%8Chttps://www.dedao.cn/course/article?id=3bezDG7wBonmJwgQr3JvQkAg5PyO1x&amp;source=search%EF%BC%8Chttps://www.dedao.cn/course/article?id=oezW9aA7r8pGX8BlxoVlY4jRMdvmbE&amp;source=search%EF%BC%8Chttps://www.dedao.cn/course/article?id=3bezDG7wBonmJwgQr3JvQkAg5PyO1x&amp;source=search">https://www.dedao.cn/course/article?id=dA5eO3NDrGk8KP0djQK2oxp9MRBzQP&amp;source=search，https://www.dedao.cn/course/article?id=3bezDG7wBonmJwgQr3JvQkAg5PyO1x&amp;source=search，https://www.dedao.cn/course/article?id=oezW9aA7r8pGX8BlxoVlY4jRMdvmbE&amp;source=search，https://www.dedao.cn/course/article?id=3bezDG7wBonmJwgQr3JvQkAg5PyO1x&amp;source=search</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>基础科学</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>光荣与梦想</title>
    <url>/2023/10/10/%E5%85%89%E8%8D%A3%E4%B8%8E%E6%A2%A6%E6%83%B3/</url>
    <content><![CDATA[<p>这是一本皇皇巨著，有4本，超过150万字，差不多和《明朝的那些事》同样的量级，是大萧条到水门事件的美国叙事史，以下的内容是原书内容的摘抄：</p>
<span id="more"></span>
<p>国家不安定，人民就难以安稳</p>
<p>大多数种植园主明白，要得到最好的回报，靠的不是鞭子，而是重视、善待、奖励奴隶，赢得他们的一片忠心</p>
<p>一个日本士兵从卢沟桥偷溜过去逛中国窑子，他的长官就以此为借口，诽谤中国人绑架了他，并对北京和天津发起进攻</p>
<p>罗斯福你努力引导人们向前，回头却发现无人跟随，这是件多么糟糕的事情啊！</p>
<p>林肯说，若顺应民意，万事皆可成</p>
<p>好生活的秘诀就是要有正确的信仰，并且用正确的价值标准来衡量这些信仰。异议和异议者让我们重新评估这些价值并坚持真理至上。起义本身并不是一种美德</p>
<p>我们绝不会退让、失败。我们将坚持到底。我们将在法国战斗，在近海和远洋战斗。我们的空军将愈战愈勇、愈战愈强。我们将不惜一切代价保卫我们的本岛。我们将在海滩战斗。我们在哪里登陆，就在哪里战斗。我们将在大街小巷战斗，在田野山岭战斗。总之，我们绝不屈服。</p>
<p>性爱是摇滚的一部分。如果有个女孩听到她魅力不凡的约会对象一直对她唱请你给我一些让我能够记住你的东西吧，便准确地知道他想要的是什么。林德夫妇调查发现，平均每10个采访者中有7个承认自己有过婚前性关系。无疑，大学生中这类人相对较少，但名义上的处女比例确实比较高</p>
<p>美国海军开战时所用地图为18世纪所绘，直接导致盟军因不知航线深浅而在许多海战中失利。海军陆战队必须一边行军，一边测绘所罗门群岛。他们甚至没搞清楚与敌军第一次交战的地点——他们以为是特纳鲁河，后来发现是伊鲁河</p>
<p>即便裕仁天皇下令，还是有顽固分子躲进山洞，拒绝投降。有人在山洞里待到20世纪50年代，甚至更久</p>
<p>约翰·肯尼迪，指挥鱼雷快艇。与肯尼迪不同，尼克松在战争期间大都不在前线，而在南太平洋航空运输组织工作，没完没了地打扑克，并精于向靠港船只索要各种美味甚至威士忌酒。不久他的营房就被称为尼克松小卖部</p>
<p>城市里流行电车。路程不远的话，走路也是不错的选择，不过即便是步行也面临着问题，平民一年只能买两双鞋。J·埃德加·胡佛报告说，抢劫犯的目标中，鞋子位列第三，仅次于酒和人造纤维。</p>
<p>凯泽在工业上取得的成功使其成为传奇。以前，从打龙骨到最终交付，造一艘船需耗时超过200天。凯泽把自由轮的平均生产时间缩短到40天。</p>
<p>美国国内性别比例失衡严重，很多女性找不到伴侣</p>
<p>军人妻子做得最不得人心的事，就是给在海外作战的丈夫戴绿帽子，反正她也没有什么机会</p>
<p>比起上一次选举，他的头发又稀疏花白了许多，现在全都湿淋淋地贴在头皮上，他的夹鼻眼镜也起雾了，几乎什么也看不见。成千上万的美国人民为了有幸一睹这个全美最有名的微笑，有伞的撑伞，没伞的就顶着湿淋淋的报纸，在大雨里哆嗦着等待罗斯福的车队。而他宁愿咬紧牙关坚持行完全程，也要让全美人民看到他的微笑。6天后，他又在费城巡演，同样冒着冷雨在敞篷里，一站就是好几个钟头</p>
<p>总统的另一名助手说得更形象：他回到白宫时，你能听到两个睾丸碰撞的声音。</p>
<p>每位父亲、每位母亲、每个孩子都希望自己所爱的人回到身边</p>
<p>住满了有权有势的男人和他们年少无知时娶下的妻子。这话暗示战后婚姻无非是这些执掌权势的男人在远大征途中一时误入歧途，这话说得刻薄而又不确切</p>
<p>结婚，就是为对方奉献自己的一切，就是互赠礼物使彼此更加高兴快乐。婚姻像一只纤巧的万花筒，年轻人的激情把数以百万零星散乱的声、色、香、味融合着叮砰巷流行音乐的片段拼接起来，像坐在行驶于第五大道的双层巴士上，越过陌生人翻起的衣领一瞥而过的广告；像塑料袋中白色的人造黄油，需挤压黄色的染料丸上色；像粉末状的水性乳胶漆，要自己调配才能使用。婚姻也是一起躺在床上抽着一根又一根香烟的无穷乐趣，但下个年代却将其变得索然无味</p>
<p>迪奥并不愿意屈服于现状。1945年年底，这个出色的女装设计师设计出离地不足12英寸的宽裙，没有垫肩却有加厚的胸罩衬垫（一般称为假乳房），还有使男人心跳加速的鞋和帽子。迪奥想要达到的目的就是，一旦女性接受了他的设计风格，她们就不得不花一笔钱给自己的衣橱大换血。这次重拳出击一举赢得年营业额高达30亿美元的服装行业和女性杂志的追捧。女性杂志 Harpers Bazoar、Vogue 和 Glamour 简直欣喜若狂。一位作家大声喊出：你的胸部、肩膀和臀部都圆圆的，你的腰部纤细，宽大的裙摆意味着你有一双娇嫩的美腿。这才是你呢 !他们在印刷精美的杂志上大吹大擂，反对过去那些无趣、难看、单调的式样，而宣扬迪奥这种裙摆宽大、用料奢华、丰富多彩（即价格昂贵）的新式样</p>
<p>据说，阿拉曼战役之后，一位路透社的记者问第八集团军的一个士兵：战争结束后，你要干的第一件事是什么？</p>
<p>干我老婆。士兵不假思索地回答</p>
<p>20世纪40年代里，美式爱情具有三个显著特点：第一，战时结婚飞快；第二，战后离婚频繁；第三，托儿所迅速人满为患</p>
<p>我们聚在一起，完全就是一群奶牛嘛，或者说是一队叽叽喳喳叫个不停的母鸡</p>
<p>在这里的沙滩上，加利福尼亚州女人们穿上半裸接着是全裸的泳衣，开美国风气之先。她们穿着宽松长裤上街，用彩灯装饰灌木丛，住在错层式房屋中，在公共场合抽烟，引领美国的流行风尚。总而言之，他们充满想象力，换言之，恣意随便。咖啡当然也就是速溶的了</p>
<p>卡罗琳·伯德写道：他们想要什么，马上就要得到——房子、车子、洗碗机、孩子……他们生下一个又一个，根本不去考虑给孩子整牙或送孩子去读大学的花销。生孩子易如反掌，而且乐趣多多。如果将战后第三年印第安纳大学的阿尔弗雷德·金赛博士公布的数据与20世纪40年代后期的人口普查数据相比，简单的计算就能显示出55 311 617名美国已婚男性每周有136 666 060次性高潮，换句话说，即每0.0048秒就有一个人射精。在那个年代，每7秒钟就有一位妻子怀上身孕，这个数字算出来连美国人口普查局都会感到脸红</p>
<p>美国大兵是一群可怜的年轻小伙子，他们完全不知道自己在为什么而战，也不知道胜利意味着什么，他们只对三件事感兴趣：睡女人、偷白兰地酒和坐下一班船回家。在伦威克·C·肯尼迪牧师笔下，美国职业军人的典型形象是：穿着鼓鼓的制服、肥胖、饮食过量、孤独、怅惆、观察力差、肤浅。他们是征服者——一边口袋里装着一根巧克力棒，另一边装着一包香烟</p>
<p>英国人在地球上昂首阔步，一副主人的样子；美国人则在地球上昂首阔步，根本不管谁是主人</p>
<p>人们也许会忘掉他21岁生日那天发生过什么，女人们也许不记得她是怎样失去童贞的，但他们每个人都能回忆起自己是在什么情况下听说这4件事的</p>
<p>自慰、梦遗、性幻想、爱抚、婚前和婚后的性交史、通奸、换位、射精频率、口交、肛交、兽交以及独特的性癖好。交谈后，他的朋友们是否离他而去不得而知，但在布鲁明顿校区和其他地方谣言四起，说他正在其他任何人都不敢接近的雷区掘地三尺。没有哪一方面会被遗漏，他用特殊仪器测量婴儿们之后发现，他们在四五个月大时就会经历性高潮；大龄单身女性吐露，穿制服的男士会让她们达到性高潮；某个青春期的孩子在一天内经历了26次高潮；一位博学老练的律师则在30多年里每星期平均射精30多次</p>
<p>那些受过良好教育的男孩会把自己留给那些仍然保持纯洁（因此，新娘穿着白色婚纱）的有教养的女孩，而婚后，他们都会对彼此忠贞不贰，白头偕老</p>
<p>但拥有自由身的诺玛·琼·贝克改名为玛丽莲·梦露后，依靠拍摄裸体照片也能勉强维持生计。她最具挑逗性的一幅照片还以鲜艳色彩被印在了安全套前端（当整个世界大战期间，同盟国的四大巨头就是丘吉尔、罗斯福、斯大林和蒋介石。艾奇逊意图遏制共产党的战略似乎完全破产了。他在自己撰写的白皮书中承认，中国新政权也许会有助于实现苏联的目标</p>
<p>蒋介石的无能，是每个看着他力量步步瓦解的人都清楚明白的</p>
<p>第二天，又有报告说在长津和赴战水库附近发现了一个团的麦克阿瑟认为是志愿军的中国士兵。俘虏们说，他们在两个星期前就坐着一辆押送军火的列车渡过了鸭绿江</p>
<p>20世纪50年代的妓女在皮大衣和珠宝的装饰下，卖淫的方法可不再像20世纪30年代的野女孩那样沿着铁路拉客，10美分一次，也不像二战时60美分一次的胜利女郎。应召女郎们不会等在街边或公交终点站，她们躺在舒服的房间，通过电话预约，就像医生那样。许多人是选美比赛冠军或大学毕业生，一些人曾主修经济学，她们在法庭上为自己辩护，称自己为国民生产总值做出了巨大的贡献。实际上，她们提供的服务对经济确实起到了一定作用</p>
<p>胡佛用重力球锻炼身体，罗斯福游泳，杜鲁门散步，艾克则打高尔夫</p>
<p>奥本海默太缺乏自信，太过羞怯，而且在摧毁广岛后思考过多。他这样认为也是这样告诉朋友的： 我们做了魔鬼的工作</p>
<p>由于生活富足，青少年亚文化在20世纪50年代继续发展，带着自己独立的风俗、特征、身份象征、仪式和时尚：男孩剪个鸭屁股发型，将袖子高高卷起；女孩则是卷毛狗式发型，佩戴松紧项链（紧可紧到脖子，松可松到腰部）。长发和古怪的穿衣风</p>
<p>格还要10年才会出现，但与他们相伴的新的语言已经开始发展。像他们敬佩的波普爵士乐音乐家一样，青少年经常使用cool（酷）这个词，尽管他们的重点有所不同，它的含义很多，与20年前的敏捷的、整洁的、了不起的、时髦的或流畅的有类似意思。like（喜欢）则成了通用的节奏词和修饰词</p>
<p>这是为闪电恋爱准备的，当时还不意味着安非他命（一种中枢兴奋剂）。越来越多的青少年对性交技巧感兴趣。除非他被禁止使用家里的车，否则一个少年会将他的约会对象带到充满激情的地方，在黑暗的遮掩下与她做爱（等同于过去的求爱方式）。玩弄女性之人的灾难和所有女性普遍抱怨的就是月经，尽管新英格兰女子寄宿学校制定了更为合适和吸引人的条款，说月经期间可不参与体育运动</p>
<p>要带她去电影院而去墓地</p>
<pre><code>告诉她狼人的浴缸和叉状的单簧

管然后对她下手，吻她，如此这般

我知道她为何没生气，她甚至会说：

你摸吧！摸起来真舒服
</code></pre>
<p>有一次在阿马里洛，一位记者问他是否打算结婚。他回答说：既然你可以隔着栅栏取到牛奶，为什么还要买奶牛呢 ?</p>
<p>肯尼迪在胜利近在咫尺之时突然遭遇失败，给人们留下了一个干净利落的年轻人的印象。他先尽力求胜，又微笑着接受失败，这一切都让全美国人为之折服</p>
<p>即使你买的是你并不需要的东西，你至少促进了经济繁荣</p>
<p>20世纪40年代初开始的美国国内大规模人口迁移，曾在战后时期以缓慢的步调继续。在整个20世纪50年代，每年都有超过百万名农民离开农场，到20世纪60年代，总共有1 700万农民离开了农场</p>
<p>夜晚的郊区吸干了市区的人口，只剩下守夜人和无家可归的人。它成了一座兼职城市，像潮水一样涨落……当汽车、通勤列车到达时，它为人潮所淹没；入夜，它被遗弃在黄昏中——人潮退去，为小偷、警察和老鼠腾出了空间。</p>
<p>在20世纪50年代，美国女性结婚的年龄从22岁下降到20岁甚至十几岁。高中结婚已经逐渐被认可。孩子们在初中就开始谈恋爱</p>
<p>要成功地诱惑男人，就必须很诱人。用怀利的话说，要够条件，最好是很够条件。为了实现这一幸福的高度，所有年龄段的女性都在衣服、化妆品和制造商声称会产生诱惑的奇妙香水上投入大量金钱</p>
<p>到了20世纪50年代后期，美国的出生率已逼近印度。在20年里，生育三个及以上孩子的美国妈妈的数量翻了一番。这种现象在女性大学生里越来越多，也最为突出：她们不惜放弃事业，养育4个、5个、6个或更多的孩子。美国大学生中的女生较少（只有35%），明显低于欧洲国家，也低于美国战前比例（40%）。注册入学的大学女生中近2/3没毕业就退学了，而超过半数的男生完成了学业。许多女生离开学校，去做卑微的工作以资助她们还在读书的另一半。这就是所谓的Ph.T.（让丈夫读完大学）学位。另一些女生退学是因为她们没有找到伴侣。各校教务处发现，女生在大一、大二时离开学校，是因为她们发现这里可以选择的对象已经不多，想去别处碰碰运气</p>
<p>，两名来自加利福尼亚州加布里埃尔的年轻玩具商出色地弥补了这一遗憾，他们合伙创立了惠姆 – 奥玩具制造公司，这两个人的名字分别是理查德·科内尔和阿瑟·梅林。二战后，他们以不到1 000美元的资金开始制造弹弓。1957年，他们靠制造飞盘赚得了人生第一桶金。飞盘是一种很轻的塑料碟子，一个人将其抛向空中，它会缓慢地掠过天空并由另一人接住</p>
<p>艾森豪威尔非常喜欢派遣尼克松夫妇进行国外访问。为建立国际友好关系，副总统先后访问了印度尼西亚、阿富汗以及埃塞俄比亚，在途中一直忍受腹泻之苦，在缅甸又遭受围堵，在卡萨布兰卡遭遇羞辱，之后还在墨西哥城一个出现故障的电梯中被困了一小时，全身大汗淋漓</p>
<p>很少有比这件事更令人开心的了，那就是发现一个正人君子正做着他极力反对别人做的事，虽然这样的事情少之又少，但就在尼克松从委内瑞拉回国后的那个月发生了，真是让人惊讶万分</p>
<p>我是一名政治上的‘处女’，现在却在市政厅的台阶上遭到‘强奸</p>
<p>担心怀孕就限制了她们的性生活。现在，似乎她们可以和男人一样随便上床了。上百万妇女将诊所和药房围得水泄不通，就为求得此药。除了防控疾病以外，从未看过如此多的人定期服用特效药</p>
<p>失败比成功更能考验一个人的品格</p>
<p>失败对于一些人来讲就好比是毒药。伟大的人常因无法接受并承受失败而变为平庸之人。也有许多人因为能够接受并承受失败而变得伟大。能否获得成功并磨炼出过人的品质，都取决于你对待失败的态度。而你将面临的失败，也是每个人都要经历的</p>
<p>詹姆斯·赖斯顿这样描述肯尼迪执政早期的典型状态：除了没爬上华盛顿纪念碑外，他任何事都没落下</p>
<p>肯尼迪苦闷地说：我的作风很像艾森豪威尔，干得越糟糕，反而越受欢迎。</p>
<p>所以后面的几届政府都无法创造性地采取措施，或采取有长远意义的策略处理震惊全国的种族骚乱，这些骚乱席卷沃兹及哈勒姆黑人区。这些骚乱加上抗议美国干涉越南事务的示威游行，大大地损害着美国的社会结构，损害程度是自19世纪南北战争以来最严重的一次</p>
<p>若你曾在晴朗无月的夜晚待在沙漠里，星星好像朝你蹦蹦跳跳而来，这正是我现在看到的</p>
<p>5 000年前，摩西曾对以色列的孩子们说：握着你们的铁锹，骑着你们的驴和骆驼，我将带领你们走向幸福的乐土。又过了将近5 000年，罗斯福说道：放下你们的铁锹，一屁股坐下来，点燃骆驼牌香烟，这里就是幸福的乐土。现在，肯尼迪在盗取你们的铁锹，踢你们的屁股，提高骆驼牌香烟的价格，占领这片幸福的乐土</p>
<p>马丁·路德·金在林肯纪念堂前发表演说成为最值得美国人铭记的历史时刻：</p>
<pre><code>我梦想有一天，这个国家会站立起来，真正实现其信条的真谛：我们认为真理不言而喻，人人生而平等。我梦想有一天，在佐治亚的红山上，昔日奴隶的儿子将能够和昔日奴隶主的儿子坐在一起，共叙兄弟情谊。我梦想有一天，甚至连密西西比州这个正义匿迹，压迫成风，如同沙漠般的地方，也将变成自由和正义的绿洲。我梦想有一天，我的4个孩子将在一个不是以他们的肤色，而是以其品格优劣来评价他们的国度里生活。
</code></pre>
<p>在格林小姐的书里有一段意味深长的话令当时的人们十分震惊，她描述了一个大学女生联谊会的女孩一边疯狂地哭叫，一边故作表情痛苦假装爬墙，喊道：你们根本不知道我有多久没有做爱了。）</p>
<p>美国的一些女大学生经常与人上床，但她们的母亲很少知道自己的女儿对性那么随便。后来，家长们愤怒地反对男女混住式宿舍楼，却差点被校园生活中更为惊人的事实吓回去了。柏克利市的加利福尼亚大学医务室的报告显示，性病已对本科女生的健康造成了严重损害，这样的事实不禁让人目瞪口呆。一个问题的解决方法有很多，停用混住式宿舍就是其中一种。但在1963年，这还不是当务之急。《花花公子》那时每星期平均会收到50封年轻女孩寄来的申请书，这些女孩都热切盼望着自己的裸照能出现在该杂志的折叠插页里，而且在编辑们看来，她们的[…]</p>
<p>肮脏的东西包装得再漂亮也还是改变不了其肮脏的本质。琳达·拉芙蕾丝在当时还只是个生活在得克萨斯州布赖恩区爱吃棒棒糖的12岁女孩，谁料到10年后她凭借在电影《深喉》中的色情演出一跃成为超级巨星，这着实让人唏嘘。</p>
<p>伊安·弗莱明的书《爱我的间谍》发行了平装本，下面是书中的一段话：</p>
<pre><code>女人都喜欢半强奸式的爱，或抢夺式的爱。这种爱甜蜜又紧张刺激，使女人对男人的感情在一种紧张危险的情绪中产生。感激心理和女性天生对勇士的向往之感叠加，使得女人一点都不觉得羞耻……他是我的救命恩人，我心中的偶像，我一辈子对他都怀着感激
</code></pre>
<p>对大多数美国人来说，第二次世界大战已不再是他们最重要的经历了。二战之后的婴儿潮让美国人年龄值的中位数降到了29.5岁</p>
<p>事实上，上学已成为美国最大的产业，学生变成美国最大的单一利益集团。</p>
<p>美国人口中的其他人都以此为荣——教育几乎已成为一种世俗的宗教，成为包治一切社会问题的良药，然而，大学生变得越加对社会不满并且情绪焦躁</p>
<p>在美国可能会找出导致年轻人躁动不安的狂热氛围。正如托克维尔所说，美国总是对青年持一种与众不同的、近乎卢梭式的看法，因而他们自然会用教育来解决一切问题，无论问题是个人的还是有普遍代表性的。</p>
<p>而现在他们却被要求扼杀这种怀疑态度，进而成为企业和政治官僚制度中的齿轮。数百万的父母并未觉察出这有什么不对；然而，他们的子女却开始产生另一种想法。</p>
<p>亨特学院的校长说：昨日的象牙塔已变成今天的散兵坑。</p>
<p>他们富裕、缺乏真正的责任感、处于失业人群之外的位置，这些使他们具有休闲阶层的所有属性。</p>
<p>男人们认为一旦女人得到解放，男人就不再会有性生活了。但他们并未认识到，如果女人获得解放，意味着性生活的增多和品质的改善</p>
<p>纽约大学的女生中，有1/3坦承曾和完全陌生的人有过一夜情。根据60年代的调查数据，全美有过婚前性行为的女孩人数翻了不止一倍，5年间，该数字又增加到了65%。在欧洲，调查员发现，会自愿描述性经验的女孩是男孩的两倍之多；在美国则刚好相反</p>
<p>巧妙的特写镜头展示男性生殖器以奇特的角度和女人性交的场景——有时是从下面开始，女演员抚摸男演员让其达到高潮。当时最惊人的色情电影《深喉》因片中有大量舔阴和口交场面成为当时的大热影片。电影结尾处，女主角为男人口交，一直到阴茎根部，这项奇特的技艺被《纽约客》杂志比作民间的吞剑术。摄影机就在离演员几英尺的地方，当男人达到性高潮时，女孩也是如此。电影使用彩色技术，使女孩全身闪着红晕。</p>
<p>美国文化深受性爱的侵染，这无疑是美国人婚前和婚外性行为大量增加的根源。</p>
<p>1968年4月，金在孟菲斯，支持由1 300名垃圾工人发起的为期两个月的罢工，他们中的大多数是黑人。报纸嘲笑他住在一个豪华的假日酒店，房间价格是29美元一晚，于是他搬到黑人开的每晚13美元的洛林汽车旅馆。4月4日晚饭前，他靠着二楼306房间外面的铁围栏，对下面的工人讲话。在街对面的一个极不起眼的房间里，一个狙击手正蜷伏着用30.06口径的雷明顿气步枪的瞄准镜盯着他。他开了一枪，子弹穿过金的脖子，深嵌进他的下巴，伤到了他的脊柱。金从围栏边上跌了下去，坠落在旅馆的墙壁边，僵硬的手伸向他的头部</p>
<p>大麻就是一个例子。大麻跟其他的毒品不同，它不会让人上瘾；它又不像烟草那样对吸食者有害；也不像酒精一样会给社会带来危害。对于年轻人来说，它常常是一种社会地位的象征；富裕家庭的孩子通常会吸食大麻。1969年的某个时期，警察会定期对出身名门的年轻人进行缉毒（又一个新词语）。</p>
<p>阿姆斯特朗说：不管身在何处，回家总是好事</p>
<p>各项重罪发生比率比去年增加10.6%，盗窃案上涨19%，强暴案飙升了16.8%，抢劫案上升了12.5%。</p>
<p>航空公司还向公众集思广益，最终收到的奇葩建议包括：训练乘务员色诱劫机犯；要求乘客裸体登机；在劫机者可能站立的位置安装活门板；利用公用广播系统播放古巴国歌，然后逮捕所有站起来的人</p>
<p>色情商品的包装各式各样，令人眼花缭乱。主街上的电影院上映X级影片，1970年的热门影片有《丹麦性自由》《风情女人》（让《我好奇》都相形见绌——《纽约每日新闻》）及艾伦·芬特的《对裸体女士说什么？》（电影的宣传语是你说什么？我们说‘哇哦’。）该片在旧金山的一家电影院全天不间断地播出，周盈利7 000美元。曼哈顿第7大街和第8大街之间有200家成人书店，它们像24小时营业的超市一样展示着商品，货架上挂着分门别类的广告牌——异性交、同性交（男）、人兽性交、滥交、女同性交、乱伦交、口交和舌交。路旁的放映机提供0.25美元一场的色情影片。《8种曼妙姿势！》的图片包只要2美元！纽约戏院上映由9个裸体女演员出演的《一笑置之》。美联社戏剧评论员威廉·格洛弗说，《乐队男孩》 是这个艺术宽容度越来越高的年代里，对同性恋最不知耻、最直白的描述；</p>
<p>正如威廉·格洛弗所言，社会风气的变化应归因于这个时代，这个充斥着性解放和渴望袒胸露背的时代。人们对性的好奇似乎永远无法满足</p>
<p>个米德菲尔德居民都能讲出嗑药的年轻人干下的荒唐事儿。最荒唐的场景发生在邻近其中一片住宅的小树林里。赤身裸体的一男一女从不同方向走来，在树下相会。心血来潮之下，两人抱在一起，女生双膝跪地，男生则采用后入式的体位。在男方达到高潮后两人分开，其间未说只言片语。</p>
<p>中国正效仿苏联，以运动为名行外交之实</p>
<p>坪上的一个警示牌上写着：全世界人民团结起来，打倒美国侵略者及其走狗。</p>
<p>北京广播电台不再播放美国官员是a强盗走狗的言论。在基辛格访华5天后，尼克松在圣克利门蒂搭直升机飞到洛杉矶郊外的伯班克电视演播厅，发表了举世震惊的4分钟讲话。他宣布自己受邀访问中国，并且已欣然接受</p>
<p>每当有国家与美国贸易出现顺差时（对美出口大于进口），这个国家的剩余美元就可用作储备，支持发行新货币。</p>
<p>968年诺贝尔文学奖获得者日本作家川端康成自杀</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>我在北京送快递</title>
    <url>/2023/10/10/%E6%88%91%E5%9C%A8%E5%8C%97%E4%BA%AC%E9%80%81%E5%BF%AB%E9%80%92/</url>
    <content><![CDATA[<p>本文是阅读《我自己北京送快递》一书的摘录，这是一本对相对底层的人民生活的纪实，我很佩服作者的那份坦然和真诚。只要是靠着双手生活，无论什么工作，没有尊卑可言。以下的内容都是从书中摘录的内容：</p>
<span id="more"></span>
<p>为此我很焦虑。实际上我已经感到脑子不好使了，主要是反应变得迟钝，记忆力开始衰退。为了延缓大脑的退化，我就开始吃坚果，也不管有用没用。考虑到价格，我主要吃核桃、花生和瓜子。</p>
<p>S公司的那栋楼就立在路边，样子有点儿破旧，看得出是个从事体力劳动的地方。不过奇怪的是楼里没有什么人</p>
<p>我问他的问题他多数不回答，甚至连看都不看我。和他沟通就像小学生和老师说话，明明自己没做错什么，也有种在挨训的感觉</p>
<p>这个女财务和同事有说有笑，但一看见我们就板起脸，丝毫不想掩饰对我们的嫌恶</p>
<p>勉强挑了一辆，感觉就像在一包掉到地上的饼干里挑出一片没弄脏的</p>
<p>他们说快了快了，其实只是缓兵之计，并不是真的快了。有时我都走了一个多小时，他们才回我电话：我已经出来了呀，怎么没看见你？</p>
<p>我发现小区有的好送有的不好送，谁送了好送的别人就得送不好送的，同事之间就像零和博弈——要不就你好，要不就我好，但不能大家都</p>
<p>假如我每天下班比别人晚、挣钱比别人少，我就会烦躁和不满，然后变得不太在乎这份工作了。就像深海里的鱼都是瞎子、沙漠里的动物都很耐渴一样，我是一个怎样的人，很大程度上是由我所处的环境，而不是由我的所谓本性决定的。其实在当时我就已经察觉到，工作中的处境正在一点点地改变我，令我变得更急躁、易怒，更没有责任心，总之做不到原本我对自己的要求，而且也不想做到了。这些改变有时会让我觉得痛快，我痛快的时候就不太能感觉到烦躁和不满</p>
<p>从头到尾我都没见到她，却被她讹了几十块钱，而她还觉得门外都是坏人，要想方设法保护自己。对于这种人，我不知道该说些什么了</p>
<p>是上帝应该只有一个，我每天却要伺候很多个啊。他听到后笑了，原来他并没有生气，只是假装生气逗我玩而已。老人家也挺幽默的，只见他摇摇手里的快递盒，压低声音对我说：我爱人不让我买，所以才不让你送到家里去。</p>
<p>大概在琢磨我的用意。我接着解释：我觉得这机器人不值两千多。老阿姨说：我也觉得不值，但我不想让你白跑一趟。我说：没关系的，我只负责送货，你买了这钱也不是我挣的。假如她买下的话，我会有千分之二的提成，但我不想很多年后还为这件事耿耿于怀</p>
<p>她冷冷地瞟了我一眼，意思大概是：看你样子也不小了，怎么还这样愚昧。然后她告诉我不行。不过，她又心软地补充道，你可以拿处方到小诊所去输液。是啊，我只是输个液而已，到哪里都一样，何必挤兑三甲医院的资源呢。于是我骑了一辆共享单车，在高德地图里找到了一家在群芳中一街上，离我住处很近的社区医院——没人能够小觑我在省钱这件事上的决心，</p>
<p>如果是的话，可以把情况向S公司反馈，公司会争取给我相同或更好的待遇。我当然知道这只是话术，不过这条短信的措辞很得体</p>
<p>并不是说我们心里有多么不满，只是这些话能拉近我们的距离，赢得彼此的好感和信任，建立一种同仇敌忾的阶级情谊</p>
<p>S公司作为行业的领头羊，其实享受了人力资源的红利，它在劳资关系里也极其强势。无论它平时怎么宣传企业理想、社会责任，但它的基层管理者却要面对现实，利用公司的强势地位更好地达成绩效考核。这就导致我在L经理和Z主管等人面前，很难得到平等的权利和尊重。而品骏快递因为实力较弱，在劳动力市场上面对美团、饿了么、S公司、京东等巨头时，没有什么优势条件足以打动我们。所以相比而言，资方的态度更谦卑，换言之我们劳方有了更大的话语权，工作氛围也相对自由，收入还不比S公司低。我向来是一个自觉的人，不是一头牲口，不喜欢在鞭子下干活儿</p>
<p>一般来说，只有在发工资的时候，我才会感觉自己付出的劳动值得，而不是在比如说客户露出感激的表情或口头表达谢意的时候——虽说那种时候我也很欣慰</p>
<p>因此那些不好送的地方的客户，应该感谢好送的地方的客户</p>
<p>。我决定不买他的账，我不会惯着他那从这么一丁点儿职权中滋生的虚荣心</p>
<p>虽说X哥挤出一脸眉飞色舞的表情，仿佛来向大家报告天大的喜讯，但在我们无产阶级的心里，对于资本家的种种行径，始终保持着万年不变的冷淡和警惕</p>
<p>我经常在送完所有快件后，坐到京通罗斯福广场里，打量逛街的人流和店铺里的售货员，看不同的送餐员跑过来跑过去。我打量他们的举止，揣摩他们的心情，我猜他们中的大多数人在被我观察时都是麻木的，脑子里什么都没想，什么都没感受到，只是机械地动着，就和我之前一样。我还发现当我获知我很快就要脱离这份工作后，我的大多数感受都是正面的、美好的，我变成了一个比原来的我更好的人——最起码比在之前工作中的那个我更好——更温和，更平实，对人也更有耐心。这说明我其实讨厌这份工作，甚至讨厌所有我做过的工作。当我被迫去工作的时候，我很容易烦躁、怨恨、满腹牢骚，而且总是不公正地把我每天伺候的客户看得比真实的他们更自私自利、蛮不讲理和贪得无厌</p>
<p>因为我身上的一些特质，我的绝大多数雇主都特别喜欢我，然后一步步地令我不堪重负，直到最后离开</p>
<p>人生是螺旋上升的这句话，不知道是谁最先说的，确实是很形象，只是没有提到上升的幅度很小、速度很慢。过往的人生总是重重复复，交往过的人也重重复复，只是每次换了名字和样子而已。实际上人们没有个性这种东西，只有和你的关系。比如你交了一个女友，然后渐渐发现，她竟然越来越像你的上一个女友。当你为此震惊的时候，你可能只是误会了：你的两个女友并不相似，只不过她们都扮演了你的女友，而这个角色塑造了她们，把她们共同的方面呈现给你，就像不同的演员在不同的影视作品里扮演同一个人物时，他们的表现肯定有很大的共同之处。当你意识到这点之后，你就可以蛮有把握地声称，你的下一个女友也将和现在的女友相差无几。从你交上第一个女友时起，你其实已经在和最后一个女友交往[…]</p>
<p>我已经不像年轻时那样，总是惶惶地想向别人证明自己，甚至故意去吃亏，生怕别人怀疑我表里不一。因为我意识到自己想讨好所有人的冲动是盲目和徒劳的。每个人都会以己度人，你永远无法让一个不真诚的人相信你的真诚。反之，你根本没必要向一个真诚的人证明你的真诚。</p>
<p>L形小推车</p>
<p>当年也没有智能手机，甚至连功能手机都没有普及，口碑是真真正正的口口相传，而不是在App里刷出来的评分</p>
<p>他只是个小小的餐厅经理，手上没什么权力——顶多在安排工作时有限地关照一下，甚至可能都不会关照。但那些同学似乎把这当成进入社会的必修课，也就是去巴结比自己位置高的人</p>
<p>于是店长选上了我，一个工作能力吊车尾的人，这令我受宠若惊。但我敏感地察觉到有些同事对此心怀不满</p>
<p>我始终不明白他们是怎么从一个学生摇身一变成为成人的。我怀疑他们早在还是个学生时，身体里就已经藏了一个成人。于是踏入社会后，他们只要轻松地把学生的表皮撕下来，变化就立刻完成。而我还是个学生的时候，身体里同样也是一个学生。就像洋葱无论撕去多少层皮，也仍然是一颗洋葱，永远不会像柑橘一样掰出鲜甜多汁的果瓤来</p>
<p>不过可能在她看来，能力强的人到处能请到，她自己就很有能力，但可以托付信任的人却可遇不可求</p>
<p>卑贱的人如果心怀不满，就只会欺负别的卑贱的人，因为反抗权势是要吃苦头的</p>
<p>在很多人眼里，加油工是一份低下的职业。大家虽然嘴上会说职业无分贵贱，心里却并不真的这么认为。不过我父母倒确实相信这句话。而且他们反正没有同城的亲戚朋友，所以不必顾虑什么面子。当初他们听说我去加油站上班，是真的为我感到高兴</p>
<p>发现当一个人表现得无私时，别人回报他的往往不是友善，而是加倍的贪婪</p>
<p>他们说工作是社会机器对人的奴役。这么说似乎也没错，可是人活在世上，很难不受到奴役——要么受这个的，要么受那个的——无论工不工作</p>
<p>完全为了谋生而工作，就和坐牢一样可悲，所以很少人声称自己是完全为谋生而工作的</p>
<p>就如毛姆所说，并不是每个人在不用为温饱奔忙后，依然知道自己该干些什么</p>
<p>他们把葵花籽壳吐得满地都是，好像并没有看到旁边的一只垃圾篓。司机在开车前只是冷淡地扫了他们一眼，什么话也没有说。看来他早已被这些随性惯了的人折磨得麻木了，再也不愿在教训他们这件事情上浪费哪怕一分力气。</p>
<p>不过我知道还有一些更优秀的人，他们懂得很多的道理，可又从不把那些道理放在眼里。他们熟悉道理就像老练的舵手熟悉水下的暗礁一样，他们掌握这些道理是为了提防它们有天</p>
<p>猝不及防地露出水面挡住他们的去路，妨碍他们获得生活中那些原本唾手可得的快乐。正是因为有了这些优秀的人，社会的快乐总量大幅度地提高了</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>传记</tag>
      </tags>
  </entry>
  <entry>
    <title>血色浪漫</title>
    <url>/2023/10/01/%E8%A1%80%E8%89%B2%E6%B5%AA%E6%BC%AB/</url>
    <content><![CDATA[<p>观2004年电视剧《血色浪漫》 摘录，其中有大量精彩的句子</p>
<span id="more"></span>
<p>郑桐：知识是个好东西，它能使人清醒，使人大彻大悟，就像漫漫长夜中的火把，给你光明给你温暖，当你进入一种境界的时候，现实中的一切都显得不重要了，你无暇去考虑物质生活中的富足与贫困，你学习知识就是为了进行一种思考，一种自我完善。</p>
<p>蒋碧云：那你在思考什么？完善什么？</p>
<p>郑桐，你到底想做一个什么样的人？你做人的最终目标是什么？</p>
<p>郑桐：当年陈寅恪先生在悼念王国维的悼词中这样写道：独立之精神、自由之思想。这真是一种极高的境界，令人高山仰止。</p>
<p>蒋碧云：怪不得他们说你怪，怎么我都觉得我快不认识你了，在你思考的问题当中到底有没有什么具体的？</p>
<p>郑桐：以史为鉴。历史是一面镜子，现实社会中的一切现象，都能在历史当中找到参照。我在想人类是最不长记性的一种动物了吧。</p>
<p>蒋碧云：郑桐同志，你该不会是故意的想表达一种深奥吧？</p>
<p>郑桐：我是肉体的诗人，也是灵魂的诗人，我占有天堂的愉快，也占有地域的痛苦。前者我把它嫁接在自己的身上，使它生殖。后者我把他翻译成一种新的语言。</p>
<p>蒋碧云：惠特曼的诗，饱含着理性。</p>
<p>郑桐：啊，我的灵魂，我们在破晓的宁静的清凉中，找到了我们自己的归宿，我的声音追踪着我目力所不及的地方，我的舌头一卷，就接触了大千世界</p>
<p>《血色浪漫》里钟跃民问秦岭理想的男人是什么样的，秦岭答：能经天纬地，能富甲一方。</p>
<p>周晓白：“流氓”</p>
<p>钟跃民：“你怎么知道我的名字”</p>
<p>周晓白：“你混蛋”</p>
<p>钟跃民：“嘿！真神了，连我小名也知道”</p>
<p>我们这里七男三女，狼多肉少</p>
<p>这世上还有比人更坏的动物吗？</p>
<p>全世界的无产阶级革命者，因为国际歌，就可以成为亲人</p>
<p>就你还当流氓呢，真给流氓丢人，出去以后好好练练，别净给流氓丢脸</p>
<p>马主任,千万别对钟跃民这小子手软,先灌辣椒水,再上老虎凳,一下垫八块砖,千万别使美人计,这孙子肯定将计就计.</p>
<p>胜不妄喜,败不妄馁,胸有惊雷而面如平湖者,可拜上将军</p>
<p>那照你这样说，我们机械化部队全改步兵连得了。等你当上了师长，咱的坦克大炮全开到练钢厂回炉，以后一人发一大刀片子。实在打不过，用我们的铁脚板踹敌人的坦克!</p>
<p>递牙者，掰之啊</p>
<p>秦岭:上次你们在县城帮了我,我该怎么感谢你们啊?</p>
<p>钟跃民:只要不以身相许,怎么感谢我们都接受.</p>
<p>靠劳动吃饭，永远不丢人</p>
<p>您别客气想要什么尽管说 我是真心实意想贿赂你！</p>
<p>谁都有走背字的时候 ，但是哥爷们儿就咬咬牙挺过来</p>
<p>你爸好歹也是个局长，你们家连户口本副食本一块儿算上，总共不到十本书吧？</p>
<p>晓白：“我要一直看着你。看你将来的妻子到底是怎么样的。要是还不如我。就别怪我当第三者。”</p>
<p>任何承诺在时间面前都是苍白的</p>
<p>一个没有未来的人很难想象他会忠于爱情</p>
<p>有天天拿着菜刀出门的诗人吗？</p>
<p>周晓白:姓名？哪个部队的？哪不舒服？</p>
<p>钟跃民:就是满肚子牙疼</p>
<p>钟跃民：行,我明白了,以后就是有人往我嘴里撒尿，我也得张嘴接着，还得说跟他妈啤酒似的味道好极了</p>
<p>马主任：你小子我从小看你长大，你什么样我不知道．就拿你六岁那年往猪圈里撒图钉，是不是你小子干的</p>
<p>马主任：七岁那年你用李奶奶的炉子烧开水，李奶奶还说呢＂呀！这孩子长大了懂事了，还知道烧开水了＂结果怎么着．那水一开你拎起水壶直接浇花去了．这是你小子干的吧（付彪对袁军的话）</p>
<p>高玥：你流氓！</p>
<p>钟跃民：早跟你说了<sub>你又不信</sub>~</p>
<p>这就是契约精神，天下太平时，国家养着我们，国家有事时，我们就要为国家流血牺牲，这是我们的责任和义务！</p>
<p>袁军:我说你们怎么跟浇了粪的庄稼一样,蹭蹭往上蹿哪</p>
<p>钟跃民他们初下乡时,断粮了,郑桐一个劲儿地喊饿,跃民说：我知道你饿，我知道你比谁都饿,但你得学会忍耐.不仅忍过今晚,还得忍到明天去县城.明天到了县城,还不一定能找到吃的;就算找到那么一点吃的,咱们也不能吃.为什么?因为得给村里的老人和小孩吃.为什么呀?不为别的,就因为咱是男人.</p>
<p>我们班可是个大染缸,别说是个宁伟了,就是蒋介石来了,我们也把他给改造咯</p>
<p>袁军:警察叔叔</p>
<p>警察:别别别,我可没你这种侄子!</p>
<p>四海翻腾云水怒 五洲震荡风雷激 一万年太久 只争朝夕</p>
<p>高玥说:等你老了玩不动了.回来跟我老老实实过日子, 好吗?</p>
<p>（镜头１：钟和海洋面前有只母鸡在琢米）</p>
<p>钟：海洋，你看那是什么鸡</p>
<p>海洋：母鸡啊</p>
<p>钟：不对，烤鸡</p>
<p>（接下来的镜头就是他们在烤那只鸡）</p>
<p>郑桐对蒋碧云:我们配一对,红它一辈子.</p>
<p>钟越民和郑桐在陕北要饭时卖唱:</p>
<p>​    “么哈么哈”</p>
<p>​    “正晌午说话谁也没有家”</p>
<p>​    “脸黄什么?”</p>
<p>​    “防冷涂的蜡”</p>
<p>​    “怎么又红了”</p>
<p>​    “精神焕发”</p>
<p>​    “怎么又黄了”</p>
<p>​    “我又涂了一层蜡”</p>
<p>周晓白：没有我不能活了？</p>
<p>张海洋：能活，就是活的没滋味。</p>
<p>张海洋：钟跃民爱你</p>
<p>周晓白：饺子吃撑了把？</p>
<p>张海洋：我比他爱你十倍~</p>
<p>回头咱们两村匀匀，别旱得旱死，涝得涝死！</p>
<p>拖毛主席的福，俺也当上八路啦，俺娘说啦，不打死几个日本鬼子，不让回家。</p>
<p>毒贩子：你们在部队好好的，干吗来这里？</p>
<p>钟跃民：我说来采蘑菇的，你信吗？</p>
<p>军人不是混饭吃的职业</p>
<p>秦岭对钟跃民说：钟跃民你听好，我同意做你的女朋友，因为你寂寞，我也寂寞。</p>
<p>世界上所有的劝慰之言，无外乎两种。一种是发自内心的期盼，另一种是不得已而为之的敷衍。</p>
<p>你看这片黄土地能长出玫瑰来么？我看不能。</p>
<p>我们浪费掉了太多的青春，那是一段如此自以为是、又如此狼狈不堪的青春岁月，有欢笑，也有泪水；</p>
<p>有朝气，也有颓废；有甜蜜，也有荒唐；有自信，也有迷茫。我们敏感，我们偏执，我们顽固到底地故</p>
<p>作坚强；我们轻易的伤害别人，也轻易的被别人所伤，我们追逐于颓废的快乐，陶醉于寂寞的美丽；我</p>
<p>们坚信自己与众不同，坚信世界会因我而改变；我们觉醒其实我们已经不再年轻，我们前途或许也不再</p>
<p>是无限的，其实它又何曾是无限的？曾经在某一瞬间，我们都以为自己长大了。但是有一天，我们终于</p>
<p>发现，长大的含义除了欲望，还有勇气、责任、坚强以及某种必须的牺牲。在生活面前我们还都是孩子</p>
<p>，其实我们从未长大，还不懂爱和被爱</p>
<p>远看金鸡独立,近看骏马缺蹄,跑似风摆荷叶,躺在炕上不一般齐</p>
<p>我们要从思想上教育他们，精神上感化他们</p>
<p>我不知道自己喜欢过什么样儿的生活，但我清楚自己不喜欢过什么样子的生活，那就是老婆孩子热炕头。</p>
<p>这是俗人的想法，一个人来到这个世界上，可不是为了建功立业。首先他是不得不来，因为他没有选择的权利。既然来了，那就要选择一种自己喜欢的生活方式，快乐地度过一生。如果你二哥认为当官快乐，那是他自己的事，但谁也没有权利要求别人认同自己的价值观。</p>
<p>周：爱一个人把她藏在心里，然后接受另一个人的爱</p>
<p>钟：娃，你放羊干啥？</p>
<p>陕北娃：攒钱</p>
<p>攒钱干啥？</p>
<p>娶媳妇</p>
<p>娶媳妇之后呢？</p>
<p>生娃</p>
<p>生娃之后呢？</p>
<p>攒钱 给娃娶媳妇</p>
<p>人一辈子，没有什么东西是绝对属于你的，除了一样，那就是“本事”</p>
<p>一个人走夜路太孤单了 两个人走会不会好一点</p>
<p>小酒喝着，小美人搂着，小温暖享受着，美啊！</p>
<p>男：小的时候我爸告诉我，这个世界上没有什么东西是永远属于你的，但有一个东西例外，那就是本领，谁也抢不走。</p>
<p>女：你这话也太绝对了，感情也抢不走啊！</p>
<p>男：你没听说过那么一个故事吗：一个浪迹天涯的游子回到故乡的时候，发现第一件事情总是自己的恋人变成别人的老婆</p>
<p>女：照你这么说，那这世界上就没有真情了啦？</p>
<p>男：美丽的花朵需要适当的温度跟水份，感情也是一样，需要一个好的环境，别人不忘旧情，那是人家觉悟高，你自个就不要太当真了。</p>
<p>爱情就像手中的流沙，抓得越紧失得越快</p>
<p>钟跃民和周晓白曾经有过这样一段对话：“在我看来，当年插队时要饭和现在当兵只是两种不同的生活方式而已，无所谓哪种好哪种不好，这两种生活方式我都会高高兴兴地投入进去，我把它当成游戏。如果这两种游戏都玩烦了，我会再换一-种游戏玩，总之，要玩得高兴。晓白，如果我和你生活在一起，你能理解我这种玩法吗?你能和我一起玩吗?”</p>
<p>周晓白听了以后，认真思考后回答：我不能，尽管我很爱你，我只能过一个正常人的生活。</p>
]]></content>
      <categories>
        <category>影剧</category>
      </categories>
      <tags>
        <tag>电视剧</tag>
      </tags>
  </entry>
  <entry>
    <title>设计数据密集型应用</title>
    <url>/2023/09/21/ddia/</url>
    <content><![CDATA[<p>这是第二次读DDIA，全名叫做《Design Data-Intensive Application》 直译为：设计数据密集型应用或数据密集型应用的设计；更多精彩内容，欢迎关注微信公众号：stackoverflow</p>
<p>🎈<strong>为什么分享这本书</strong>🎈</p>
<p>我相信各位一定历经过这样的场景：春节档档期一下子上映了很多场电影，一场电影要不要去看呢？对于我来说，通常都是先看一下豆瓣评分，如果高的话，就买票入场，所以为什么选择分享这本书，那就不得不说下这本书的溢美之词</p>
<span id="more"></span>
<h3 id="关于ddia的溢美之词">关于ddia的溢美之词</h3>
<p>可以看到，这本书的评价惊人的高，居然达到了 9.7分的高分，有的同学可能觉得9.7分并不是一个很高的分数，来看下面这部是个码农都知道的书《算法导论》，这本书的评分是多少呢？ 9.2分，当然这是一个很高的分数，但是ddia 比这个高度还要高 0.5分；有的同学可能还是不能很直接的get到这本书的魅力，OK，我们来和豆瓣电影评分类比一下，要知道豆瓣中电影评分最高的也就是9.7分，也就是大名鼎鼎的，我相信各位应该都看过《肖申克的救赎》</p>
<p align="center">
  <img src="/2023/09/21/ddia/01.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 设计数据密集型应用的赞美之词 </span>
</p>
<p>甚至ByteDance 这家公司将这本书写进入interview doc。<strong>所以结论来了，DDIA , 你值得拥有</strong></p>
<h3 id="关于作者">关于作者</h3>
<p><a href="https://martin.kleppmann.com/">Martin Kleppmann</a></p>
<h1>整书大纲</h1>
<p>下面是整书的一个脉络：分为<strong>3</strong>个部分12个章节</p>
<p align="center">
  <img src="/2023/09/21/ddia/37.jpg" width="80%" alt="Your image description">
  <br>
  <span style="color:gray"> 书籍结构目录 </span>
</p>
<h2 id="哪3部分">哪3部分</h2>
<h3 id="1️⃣-数据系统的基石">1️⃣ 数据系统的基石</h3>
<p>主要讲述了数据系统底层的一些概念，无论是单机上的单点数据系统，还是分布在多机器上的分布式数据系统。这个讨论的范围是 <em>单机或者多机器，区别于第二部分仅谈论多机器上的分布式系统</em></p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>1：可靠性、可扩展性、可维护性</strong>  在开发一个应用的时候，必须要满足各种功能需求才能称之为有用，除了功能需求（也就是能够实现什么功能）还需要一些非功能需求，也就是通用属性，比如说可靠性<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，可扩展性<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，可维护性<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>
<blockquote></blockquote>
<ul class="lvl-2">
<li class="lvl-4">
<p><strong>2：数据模型与查询语言</strong>  这个是从使用者的角度出发（⚠️<em>注意这个视角很重要</em>） 。描述数据录入数据系统的格式，已及如何将存入的数据取出来。涉及<strong>关系模型，文档模型，图模型</strong>。比如说对于关系型数据库来说，数据模型 = DML(Data Manipulation Language)；查询语言 = DQL(Data Query Language 一种声明式的查询语句) 。阐述了关系模型的各个挑战者挑战关系模型的霸主地位，最终落败的过程，数据模型发展至今关系模型依然王者</p>
</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>3：存储与检索</strong>  这个是<strong>从数据系统的角度出发</strong>，描述数据系统如何存储我们录入的数据，以及在我们需要这部分数据，存储系统如何精准、快速的定位到目标数据。这里注意区分<em>2章节和3章节的角度</em></p>
</li>
<li class="lvl-2">
<p><strong>4：编码与演化</strong>  随着时间推移，数据系统由于功能的迭代，需要对初始涉及的数据模型(schema)进行更改，那么如何处理数据模型的前后兼容问题，就是这个章节要讨论的问题</p>
</li>
</ul>
<h3 id="2️⃣-分布式数据">2️⃣ 分布式数据</h3>
<p>本章主要讲述在多机器的分布式数据系统中，将会有多台机器参与数据的存储和检索，数据系统所面临挑战，包括</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>5：复制</strong> ： 同一份数据，多个拷贝/副本。这将为系统的可用性提供支撑</p>
</li>
<li class="lvl-2">
<p><strong>6：分区</strong> ： 同一份数据，分割成多块</p>
</li>
<li class="lvl-2">
<p><strong>7：事务</strong> ： 主要介绍 事务，ACID，隔离级别等内容，这部分内容是重点也是难点</p>
</li>
<li class="lvl-2">
<p><strong>8：分布式系统的麻烦</strong> ： 在极端情况下，分布式系统黑暗的诸多问题，看完这一章节，你会觉得你所处于的环境真的是太幸福了</p>
</li>
<li class="lvl-2">
<p><strong>9：一致性与共识</strong> ：分布式数据系统如何去实现一致性和达成共识，从而避免类似于 brain split  的问题，这一章节会讨论在构建容错分布式系统的时候使用到的 算法和协议(比如Raft、Paxos、ZAB)</p>
</li>
</ul>
<h3 id="3️⃣-派生数据">3️⃣ 派生数据</h3>
<p>第一/二部分系统的考量了分布式数据库的方方面面，真实世界的大型应用程序经常需要以多种方式访问和处理数据，没有一个数据库可以同时满足所有这些不同的需求。因此应用程序通常组合使用多种组件：数据存储，索引，缓存，分析系统，等等，并实现在这些组件中移动数据的机制</p>
<p>该书的最后一部分，研究将多个不同数据系统（可能有着不同数据模型，并针对不同的访问模式进行优化）集成为一个协调一致的应用架构时，会遇到的问题</p>
<p>主要讨论衍生(派生)数据：所谓<em>衍生数据</em> 是以输入数据输出新的数据，输出是衍生数据（derived data）的一种形式 ，流处理和批处理都会产生衍生数据</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>10：批处理</strong>  ： 有界数据的处理</p>
</li>
<li class="lvl-2">
<p><strong>11：流处理</strong>  ： 无界数据的处理</p>
</li>
<li class="lvl-2">
<p><strong>12：数据系统的未来</strong> 🤣</p>
</li>
</ul>
<p>🎈<strong>以上呢</strong>🎈，就是整本书的一个简短的概括，下面的内容就是我基于书中的内容做的一些总结，已及自己的一些启发</p>
<h2 id="计算密集vs数据密集">计算密集vs数据密集</h2>
<p>下图是应用程序的简要分类：</p>
<p align="center">
  <img src="/2023/09/21/ddia/15.jpg" width="80%" alt="Your image description">
  <br>
  <span style="color:gray"> 数据密集型应用和计算密集型应用的区别 </span>
</p>
<p>🅰️ 首先是计算密集型应用，这类应用的瓶颈是算力，比如进行气象预测，对于这类应用我们处理的方式就是不断的提升计算机的算力，比如增加CPU的核数，增加内存等</p>
<p>🅱️ 再有就是数据密集型，这类应用的瓶颈是：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据量，Volume</p>
</li>
<li class="lvl-2">
<p>数据的复杂性，Variety</p>
</li>
<li class="lvl-2">
<p>数据的变更速度，Velocity</p>
</li>
</ul>
<p>对于数据密集型应用，我们通常会使用标准的组件来处理：</p>
<p>1️⃣ 存储数据，以便自己或其他应用程序之后能再次找到(数据库 database)</p>
<p>2️⃣ 记住开销昂贵操作的结果，加快读取速度(缓存 cache)</p>
<p>3️⃣ 允许用户按关键字搜索数据，或以各种方式对数据进行过滤(搜索索引 search indexes)</p>
<p>4️⃣ 向其他进程发送消息，进行异步处理(流处理 stream processing)</p>
<p>5️⃣ 定期处理累积的大批量数据(批处理 batch processing)</p>
<h3 id="如何描述负载？">如何描述负载？</h3>
<p>可以使用<strong>负载参数（load parameters）</strong> 的数字来描述负载。参数可能是</p>
<ol>
<li class="lvl-3">
<p>每秒向Web服务器发出的请求</p>
</li>
<li class="lvl-3">
<p>数据库中的读写比率</p>
</li>
<li class="lvl-3">
<p>聊天室中同时活跃的用户数量</p>
</li>
<li class="lvl-3">
<p>缓存命中率</p>
</li>
</ol>
<p>除此之外，需要关注<strong>平均情况</strong>或者<strong>峰值情况</strong>。有写负载和读负载，如果写负载远远低于读负载，此时我们可以让写入时做更多的工作，便于我们在读取的时候做更少的工作</p>
<p>推特在推文写入和推文读取时，使用了两种不同的策略</p>
<h3 id="如何描述性能？">如何描述性能？</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>批处理系统，每秒可以处理的记录数量，即吞吐量（throughput），或者在特定规模数据集上运行作业的总时间</p>
</li>
<li class="lvl-2">
<p>在线系统，通常更重要的是服务的<strong>响应时间（response time）</strong>，即客户端发送请求到接收响应之间的时间</p>
</li>
</ul>
<p>一般而言，将响应时间视为一个可以测量的数值<strong>分布（distribution）</strong>，而不是单个数值，比如<strong>100次请求响应时间的均值与百分位数</strong>。第95、99和99.9百分位点（缩写为p95，p99和p999），如果第95百分位点响应时间是1.5秒，则意味着100个请求中的95个响应时间快于1.5秒，而100个请求中的5个响应时间超过1.5秒</p>
<p>百分位点通常用于<strong>服务级别目标（SLO, service level objectives）<strong>和</strong>服务级别协议（SLA, service level agreements）</strong>，即定义服务预期性能和可用性的合同，如果没达到服务目标，客户可以不付款</p>
<p>什么是头部阻塞？</p>
<blockquote>
<p>由于服务器只能并行处理少量的事务（如受其CPU核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为 <strong>头部阻塞（head-of-line blocking）</strong>，也叫做<strong>排队延迟（queueing delay）</strong>，通常占了高百分位点处响应时间的很大一部分</p>
<p><strong>当一个请求需要多个后端请求时，单个后端慢请求就会拖慢整个终端用户的请求</strong>，效果称为尾部延迟放大</p>
</blockquote>
<p>负载参数和性能参数是讨论可扩展性的前提，可扩展性即为当负载参数增加时，如何保持良好的性能？</p>
<h3 id="什么是弹性的？">什么是弹性的？</h3>
<p>如果说系统是 <strong>弹性（elastic）</strong> 的，这意味着可以在检测到负载增加时自动增加计算资源，而其他系统则是手动扩展（人工分析容量并决定向系统添加更多的机器）</p>
<h1>第2章节-数据模型与查询语言</h1>
<h2 id="文档模型和关系模型的优劣势？">文档模型和关系模型的优劣势？</h2>
<p>文档模型如JSON的优势在于结构灵活，你可以将任意的键和值添加到文档中，而在关系模型中你必须提前预设这样的字段或者进行 <code>alter table</code> 操作，文档模型在连接上的劣势，导致数据如果有多份，必须要存储多次，有较高的数据不一致风险。如果每次读取文档的全部或者大部分内容，查询局部性会有很大优势，而关系模型将数据分割多块的行为，不得不进行连接</p>
<p>关系模型一般是规范化的，能够保证数据的一致性（外键），但是其中的结构变化，是一个较耗时的操作如果表很大的话，执行 <code>alter table  &amp; update </code> 需要很久，此时会有锁表行为</p>
<h2 id="声明式查询vs命令式查询">声明式查询vs命令式查询</h2>
<p>声明式查询告诉存储引擎：我需要<code>Sharks</code>类数据，而命令式查询给出找到A类数据的方法，存储引擎按照这个方法执行即可,而众多编程语言就是命令式的</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">function <span class="title function_">getSharks</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">var</span> <span class="variable">sharks</span> <span class="operator">=</span> [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; animals.length; i++) {</span><br><span class="line">        <span class="keyword">if</span> (animals[i].family === <span class="string">"Sharks"</span>) {</span><br><span class="line">            sharks.push(animals[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sharks;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>SQL是一种声明式的查询语句，声明式查询不提供方法，仅指定结果的模式，接收声明的数据库可以自行选择高校的方法</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> animals <span class="keyword">WHERE</span> family <span class="operator">=</span><span class="string">'Sharks'</span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="MapReduce是什么">MapReduce是什么</h2>
<p>MapReduce是一个由Google推广的编程模型，它基于<code>map</code>（也称为<code>collect</code>）和<code>reduce</code>（也称为<code>fold</code>或<code>inject</code>）函数。它既不是一个声明式的查询语言，也不是一个完全命令式的查询API，而是处于两者之间：查询的逻辑用代码片断来表示，这些代码片段会被处理框架重复性调用</p>
<h2 id="图">图</h2>
<p>如果你的应用程序大多数的关系是一对多关系（树状结构化数据），或者大多数记录之间不存在关系，那么使用文档模型是合适的。关系模型可以处理多对多关系的简单情况，但是随着数据之间的连接变得更加复杂，将数据建模为图形显得更加自然</p>
<p>一个图由两种对象组成：<strong>顶点（vertices）</strong> 和 <strong>边（edges）</strong>，典型的例子包括：社交图谱,网络图谱,公路或铁路网络</p>
<h3 id="A-什么是属性图模型？">A-什么是属性图模型？</h3>
<p>在属性图模型中，包含顶点和边，在属性图模型中，顶点和边分别包括</p>
<table>
<thead>
<tr>
<th>顶点（vertex）</th>
<th>边（edge）</th>
</tr>
</thead>
<tbody>
<tr>
<td>唯一的标识符</td>
<td>唯一的标识符</td>
</tr>
<tr>
<td>一组 <strong>出边（outgoing edges）</strong></td>
<td>边的起点（tail vertex）</td>
</tr>
<tr>
<td>一组 <strong>入边（ingoing edges）</strong></td>
<td>边的终点（head vertex）</td>
</tr>
<tr>
<td></td>
<td>描述两个顶点之间关系类型的标签</td>
</tr>
<tr>
<td>一组属性（键值对）</td>
<td>一组属性（键值对）</td>
</tr>
</tbody>
</table>
<p>可以将图存储看作由两个关系表组成：一个存储顶点，另一个存储边</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> vertices (</span><br><span class="line">  vertex_id  <span class="type">INTEGER</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  properties JSON</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> edges (</span><br><span class="line">  edge_id     <span class="type">INTEGER</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  tail_vertex <span class="type">INTEGER</span> <span class="keyword">REFERENCES</span> vertices (vertex_id),</span><br><span class="line">  head_vertex <span class="type">INTEGER</span> <span class="keyword">REFERENCES</span> vertices (vertex_id),</span><br><span class="line">  label       TEXT,</span><br><span class="line">  properties  JSON</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给定任何顶点，可以高效地找到它的入边和出边，从而遍历图，即沿着一系列顶点的路径前后移动，建以下索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX edges_tails <span class="keyword">ON</span> edges (tail_vertex);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX edges_heads <span class="keyword">ON</span> edges (head_vertex);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="B-Cypher-属性图模型声明式查询语句">B-Cypher 属性图模型声明式查询语句</h3>
<p>Cypher是属性图的声明式查询语言，为Neo4j图形数据库而发明</p>
<p align="center">
  <img src="/2023/09/21/ddia/57.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 图模型&amp;图数据写入&amp;图数据查询 </span>
</p>
<h2 id="读时模式vs写时模式">读时模式vs写时模式</h2>
<p><strong>读时模式（schema-on-read）</strong>：数据的结构是隐含的，只有在数据被读取时才被解释，比如文档数据库</p>
<p><strong>写时模式（schema-on-write）</strong>：传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式</p>
<p>读时模式类似于编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查，就像静态和动态类型检查的相对优点具有很大的争议性一样，数据库中模式的强制性是一个具有争议的话题，一般来说没有正确或错误的答案</p>
<h2 id="总结">总结</h2>
<p>在历史上，数据最开始被表示为一棵大树（层次数据模型），由于不适合表示多对多的关系，发明了关系模型来解决这个问题。后来，人们发现一些应用程序也不适合采用关系模型，于是新的非关系型“NoSQL”数据</p>
<ol>
<li class="lvl-3">
<p>文档数据库的应用场景是：数据通常是自我包含的，而且文档之间的关系非常稀少。</p>
</li>
<li class="lvl-3">
<p>图形数据库用于相反的场景：任意事物都可能与任何事物相关联。</p>
</li>
</ol>
<p>这三种模型（文档，关系和图形）在今天都被广泛使用</p>
<h1>第3章节-存储与检索</h1>
<p>存储与检索的内容，即：数据库在最基础的层次上完成的2件事情：</p>
<p>🅰️ 当你把数据交付给它的时候，它如何将数据存储起来</p>
<p>🅱️ 当你向数据库索要数据时，它如何将数据返回给你</p>
<p>由于<strong>事务性负载</strong>和<strong>分析性负载</strong>的存储引擎之间存在着很大的差异，这两类的存储引擎我们分开来描述</p>
<p><strong>在事务处理方面</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>日志结构存储引擎  ；从最简单的数据库实现append-log(无索引日志)到 LSM(日志结构合并树) 树的演化历程</p>
</li>
<li class="lvl-2">
<p>面向页面的存储引擎 ，典型的比如B-Tree</p>
</li>
</ul>
<p>在<strong>分析性存储引擎方面</strong>，我们谈谈</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>数据仓库</p>
</li>
<li class="lvl-2">
<p>星型模型&amp;雪花模型</p>
</li>
<li class="lvl-2">
<p>列存储</p>
</li>
</ul>
<h2 id="无索引日志">无索引日志</h2>
<p>我们来看下 <strong>世界上最简单的数据库</strong> 是如何实现的</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>插入操作（<code>db_set</code>）</p>
</li>
<li class="lvl-2">
<p>更新操作（<code>db_set</code>）</p>
</li>
<li class="lvl-2">
<p>查询操作（<code>db_get</code>）</p>
</li>
</ul>
<p align="center">
  <img src="/2023/09/21/ddia/16.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 无索引日志 &amp; 最简单的数据库 </span>
</p>
那么这个最简单的数据库底层是如何进行数据的摆放的呢？可以看到`db_set()`就是一个非常简单的追加[^4]，这**简直不是简单，甚至可以说是简陋**但正是由于这种设计使得写入变的非常的高效，代价就查找的开销是 $O(n)$ ， $O(n)$ 的复杂度，这意味着如果数据量增加一倍，查询响应时间将会增加一倍。也就是说查询时间和数据量之间的关系是线性相关的。所以我们需要**更快的得到目标结果**，那么如何去提升数据的查找效率？
<blockquote></blockquote>
<h2 id="如何提升查找效率？">如何提升查找效率？</h2>
<p align="center">
  <img src="/2023/09/21/ddia/17.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 康熙字段VS新华字典 </span>
</p>
<p>当我们还是一个小学生的时候，可能面临过类似的问题，假设说现在有2个小学生，忘记了<strong>囧</strong>字怎么写，想要用新华字典查询一下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>小明同学使用的是一本没有目录的字典(比如说康熙字典)</p>
</li>
<li class="lvl-2">
<p>小红同学 使用的是一本有目录的字典(现代新华字典)</p>
<p>那么谁最后能更快的获知 <code>jiong</code> 字的写法呢？直觉告诉我们小红同学有较大的概率最快获取到 <code>joing</code>字的写法</p>
</li>
</ul>
<p>现代字典的特征就是都会有一个目录，这个目录是在<strong>原始数据之外维护的额外的数据</strong>，正是由于目录的存在，使得小红同学能够更快的获取到目标数据。其实这个目录，其实就相当于英文中的 <code>index</code> , 而 <code>index</code>英译就是索引，至此我们可以得到一个结论：</p>
<blockquote>
<p>索引 是在原始数据之外维护的额外的数据，索引 可以加速数据访问</p>
</blockquote>
<p>🎈<strong>Post Script</strong>🎈</p>
<p>由于需要在原始数据之外额外维护一份数据，这就无形增加了空间复杂度，在计算机领域中，时间和空间就像鱼和熊掌一样，不可兼得，降低时间复杂度的方式就<strong>用空间换取时间</strong>； 可以说这个问题在计算机领域是一个绕不开的话题，如何去提升查找效率这个问题的另外一种问法是：<strong>给我一个更低的时间复杂度</strong>的实现，那么常见的比 $O(n)$  还低的时间复杂度就是 $O(1)$， $O (log_n)$  两个，$O(1)$ 的时间复杂度，我们很容易就会想到哈希表，因为哈希表的时间复杂度默认是 $O(1)$，接下来我们尝试构建哈希索引来提升查询效率</p>
<h2 id="内存中构建hash索引">内存中构建hash索引</h2>
<p align="center">
  <img src="/2023/09/21/ddia/18.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 为日志构建哈希索引 </span>
</p>
<p>那么对于存储于磁盘中的数据，我们在内存中维护一个<code>HashMap</code>，维护<code>key</code>和<code>value</code> 的偏移量，这样一来，我们就能够迅速的定位到目标数据，比如我们想要找到 <code>key = 42</code> 的数据，通过查询内存中的HashMap表，获得偏移量64 ，所以可以直接定位到数据，而不在需要从头开始遍历</p>
<p>随着我们不断的在文件末尾追加文件，磁盘中的单个文件也会越来越大，甚至单个文件可能吃掉整个磁盘的存储。所以，<strong>如何用有限的存储存储更多的数据？</strong> 即，如何避免磁盘的空间的消耗？</p>
<h2 id="分段存储-压缩-分段合并-hash索引的局限性">分段存储&amp;压缩&amp;分段合并 &amp; hash索引的局限性</h2>
<p align="center">
  <img src="/2023/09/21/ddia/19.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 日志分段 &amp; 分段日志压缩 </span>
</p>
<p>我们解决的方案是：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>分段存储：也就是说当追加文件的 <code>size</code>（通常是几兆字节） 达到了一定的阈值之后，我们重新写入新的文件（每个段维护自己的索引）</p>
</li>
<li class="lvl-2">
<p>压缩：丢弃重复的键，保留每个键的最新值</p>
</li>
</ul>
<p>如上图中原本12个键 压缩之后之后3个键，整个文件的<code>size</code>降低。<strong>如何进一步改进？</strong></p>
<p align="center">
  <img src="/2023/09/21/ddia/20.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 日志分段 &amp; 分段日志压缩 &amp; 压缩日志合并 </span>
</p>
<p>在执行压缩的同时，可以将压缩之后的<strong>段合并</strong>。如 Data file segment 1 和 Data file Segment 2 在压缩了之后，进行了一个合并操作，得到了 Merged Segment(比如mew 这个键压缩合并的过程)。压缩和合并对用户是没有感知的，由后台进程完成，在合并的时候由旧的段文件提供读写请求，在合并完成之后，读写请求转化为新的合并后的段</p>
<p>那么由于hash表本身的特性，也会导致我们构建的哈希索引有一定的局限性，比如：</p>
<p>🅰️ 哈希表是存在于内存中的</p>
<p>🅱️ 范围查询是软肋</p>
<p>那么如何突破哈希表的局限性，寻找更好的索引结构？</p>
<h2 id="SSTable-排序字符串表">SSTable 排序字符串表</h2>
<p>这个问题的答案是：排序字符串表，也就是<strong>SSTable<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></strong>, 也就是：在段文件中，对键值对的序列排序</p>
<p align="center">
  <img src="/2023/09/21/ddia/21.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> SStable </span>
</p>
<p>比如上图中，对于已经排好序段文件1，段文件2 ，段文件3 ，进行压缩和合并，而且，在合并之后，仍然需要保证合并之后的段文件有序，所以我们需要一个合适的排序算法：<strong>那么这个排序算法是什么呢？</strong> 是冯诺依曼发明的归并排序算法；merge sort 的优势就在于：内存在小于被排序文件大小的时候，仍然可以将排序完成</p>
<blockquote></blockquote>
<p>使用SSTable可以有效的突破内存限制和解决范围查询的问题。如下图中我们查找，<code>handiwork</code> 的过程，可以发现不是在内存中保存所有键的索引，由于SSTable维护了顺序关系，我们的索引以稀疏索引的方式存在于内存中。同时，可以支持范围查询</p>
<p align="center">
  <img src="/2023/09/21/ddia/22.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 稀疏索引，比如每几千个字节一个键 </span>
</p>
<h2 id="LSM-日志结构合并树">LSM 日志结构合并树</h2>
<p>在前面的讲述中，我们默认了落盘段文件是有序的，在落盘写入段文件之前，<strong>如何按键排序</strong>？考虑到效率问题，最初的的写入一定是在内存中的，到达一定的时间阈值或者是内存阈值的时候，在进行落盘形成 SSTable，那么内存中<strong>选择什么样的数据结构？</strong></p>
<p>1️⃣ 内存表，<strong>为什么是AVL-Tree ？</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>首先平衡二叉树本身就是二叉搜索树，而二叉搜索树中序遍历就是顺序结构，可以直接落盘形成SSTable</p>
</li>
<li class="lvl-2">
<p>由于平衡特性，可以保持树的结构，而不是退化成链表，使得查询的时间复杂度维持在 $O(logN)$, 而且对于新加入的数据，平衡二叉树通过左旋，或者右旋的方式保持平衡性</p>
</li>
</ul>
<p>2️⃣ 落盘，也就是平衡二叉树的中序遍历方式落盘</p>
<p>3️⃣ 读取请求，先请求内存，然后查询磁盘段</p>
<p>4️⃣ 压缩和合并： 后台压缩合并段文件，并丢弃覆盖/删除旧值</p>
<p>5️⃣ 防止数据库崩溃（保存在AVL-Tree，但是未落盘到SStable）：磁盘保留一份单独的日志，每个写入都追加到磁盘上，防止数据库崩溃，内存数据丢失</p>
<p align="center">
  <img src="/2023/09/21/ddia/23.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 那么使用这种LSM结构的组件有哪些 </span>
</p>
<p>Cassandra<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>、Bigtable、HBase、Elasticsearch、Solr<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>、Hologres<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></p>
<blockquote></blockquote>
<p><strong>这种先内存排序，再落盘排序的结构，就是LSM(Log-Structure Merge Tree 日志结构合并树)结构</strong>，<strong>LSM结构和B±Tree相比，减少了随机IO，极大的提高的写性能</strong></p>
<h2 id="面向页存储引擎">面向页存储引擎</h2>
<p>接下来我们介绍另外一种存储引擎：面向页面的存储引擎，比如B 树，B树会将数据库分解为固定大小的块或者是页面<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>，传统大小为4K而且一次只能读取或者写入一个页面，和LSM对比一下</p>
<p align="center">
  <img src="/2023/09/21/ddia/24.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> B树和LSM比对 </span>
</p>
<blockquote></blockquote>
<p>下图展示了面向页面的存储引擎是如何查询数据的</p>
<p align="center">
  <img src="/2023/09/21/ddia/25.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 面向页面的存储引擎是如何查询数据的 </span>
</p>
<p>分支因子：<strong>在B树中一个页面中对子页面的引用数量</strong>。伴随着上世纪70年代关系型数据库的发展至今，面向页面的存储引擎发展至今已经非常成熟了</p>
<h2 id="向页面添加元素">向页面添加元素</h2>
<p>如何向B树中增加一个数据，如下图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/26.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 如何向B树中增加一个数据 </span>
</p>
<blockquote>
<p>WAL即在数据写数据页之前，先记录到"小黑板"<sub>WAL</sub>上，对于一个更新操作来说，如果每次更新都需要立刻写磁盘，存储引擎需要找到被更新的记录，然后更新，这个先定位再更新的机制必然有一定的成本（查找成本+IO成本），如果<strong>引擎会将记录写到 文件 里，并且更新内存</strong>，在适当（系统比较空）的时候，将操作记录刷写到磁盘， 如此便可以提升更新效率。事实上MySQL的InnDB 引擎就是这么做的</p>
</blockquote>
<h2 id="比对LSM树-和-B树">比对LSM树 和 B树</h2>
<p>最后我们来一起对比一下LSM树和B树，也即面向日志的存储引擎和面向B树的存储引擎的优劣势</p>
<p align="center">
  <img src="/2023/09/21/ddia/27.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 比对LSM树 和 B树 </span>
</p>
<h2 id="OLTP-OLAP-和-数据仓库">OLTP&amp;OLAP 和 数据仓库</h2>
<p>数据库在历史中主要为两种系统提供支持</p>
<p>🅰️ 在线事务处理系统，即 OLTP</p>
<p>🅱️ 在线分析系统，即 OLAP</p>
<p>下表中对比了两者之间的区别，</p>
<p align="center">
  <img src="/2023/09/21/ddia/28.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> OLTP 对比 OLAP </span>
</p>
<p>起初的数据库，能够同时应对以上两种查询的情况，无论是OLTP类型的查询，还是OLAP类型的查询，单一的数据库的表现的都很好，也就是说：<strong><u>也就是说两者是一家的</u></strong>。 OLAP通常会要求 <strong>高可用</strong>与<strong>低延迟</strong>，为了保证业务系统的稳定运行，所以DBA会密切关注他们的OLTP数据库，他们通常不愿意让业务分析人员在OLTP数据库上运行临时分析查询，因为这些查询通常开销巨大，会扫描大部分数据集，这会损害同时执行的事务的性能。可以见得，OALP和OLTP 这对亲兄弟发生了矛盾，矛盾会最佳解决方案就是分家</p>
<p>在20世纪80年代末和90年代初期，渐渐地很多公司有停止使用OLTP系统进行分析，而是在单独的数据库上运行分析。这个单独的数据库被称为<strong>数据仓库(data warehouse)</strong>。因为最初的数据仓库是从关系型数据库中独立出来，只存储关系数据，而且是面向数据分析，BI(商业智能)的，只是到了后来随着大数据时代的到来，数据仓库才慢慢变的越来越像<strong>数据湖<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup></strong> (就是各种数据都跑往数据仓库里面塞)</p>
<blockquote>
<p>数据沼泽：<strong>数据沼泽</strong> 是一个劣化的数据湖，用户无法访问，或是没什么价值</p>
</blockquote>
<p>又或者说，<strong>数据湖是下一代数据仓库</strong>，从OLTP数据库中提取数据，转换成适合分析的模式，清理并加载到数据仓库中，因此数据仓库包含公司各种OLTP系统中所有的只读数据副本。下图是一个简要的示意图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/29.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> ETL过程 </span>
</p>
<h2 id="数据仓库系统组件">数据仓库系统组件</h2>
<p>我们来看一些比较出名的商业数据仓库系统，尽管他们是冠以出名的商业数据仓库系统，但是其中"商业"两个字可能是太贵，导致大多数从事数据仓库相关工作的人，其实并不知道：</p>
<img src="/2023/09/21/ddia/30.jpg" width="100%" height="70%" alt="图片名称" align="center">
<ul class="lvl-0">
<li class="lvl-2">
<p>SQL - Server   使用两套不同的存储和查询引擎来应对OALP和OLTP环境</p>
</li>
<li class="lvl-2">
<p>Teradata       天睿</p>
</li>
<li class="lvl-2">
<p>Vertica          维蒂卡</p>
</li>
<li class="lvl-2">
<p>SAP HANA    SAP  汉那</p>
</li>
<li class="lvl-2">
<p>ParAccel        帕加速</p>
</li>
</ul>
<p>相对而言，我们更喜欢免费的开源产品，下面是一些SQL-on-Hadoop 项目：</p>
<p>Hive-SQL、Spark-SQL、Flink-SQL、Presto、Druid、Kylin、Impala</p>
<h2 id="雪花模型">雪花模型</h2>
<p>在OLTP系统中，可用的数据模型很丰富，比如大类上分为</p>
<p>🅰️ 关系模型</p>
<p>🅱️ 新的非关系模型，No-SQL模型</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>文档数据库模型</p>
</li>
<li class="lvl-2">
<p>图形数据库模型</p>
</li>
</ul>
<p>相对于OATP系统来说，OLAP系统的数据模型多样性就少的多，数据仓库大多使用一样的公式化模型：<strong><u>星型模式|星型模型(也叫维度建模)</u></strong> 如下图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/31.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 星型模式示意图 </span>
</p>
<p>1️⃣ 模式的中心是一个所谓的事实表，事实表的每一行代表在特定时间发生的事件(这里，每一行代表客户购买的产品)</p>
<p>2️⃣ 事实表中的一些列是属性，例如产品销售的价格和从供应商那里购买的成本(允许计算利润余额)，通常是数字等可统计指标</p>
<p>3️⃣ 事实表中的其他列是对其他表(称为维表)的外键引用，由于事实表中的每一行都表示一个事件，因此这些维度代表事件的发生地点，时间，方式和原因</p>
<p>4️⃣ 事实表格有100列以上，有时甚至有数百列，快手宽表列长达1000+列</p>
<p>5️⃣ 星型模型进一步的扩展是雪花模型，也就是基于维度表进一步拆分</p>
<p>当表关系可视化时，事实表在中间，由维表包围；与这些表的连接就像星星的光芒，所以这模式被命名为：“星型模式”</p>
<h2 id="列式存储">列式存储</h2>
<p>在前面的存储结构中，我们介绍了</p>
<p>🅰️ 基于日志的存储：日志结构学派</p>
<p>🅱️ 基于页面的存储：就地更新学派</p>
<p>然而，典型的数据仓库查询一次只访问较少的列，如果使用行存储的话，面向行的存储引擎仍然需要将所有这些行(每个包含超过100个属性)从磁盘加载到内存中，解析它们，并过滤掉那些不符合要求的条件。这可能需要很长时间。面向列的存储背后的想法很简单：<strong>不要将所有来自一行的值存储在一起，而是将来自每一列的所有值存储在一起</strong>。如下图</p>
<p align="center">
  <img src="/2023/09/21/ddia/32.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 列式存储示意图 </span>
</p>
<p>可以观察到红色框选出来的值序列，他们是重复数据，而<strong>重复数据是压缩的好兆头</strong>。我们根据列中的数据，可以使用不同的压缩技术来进一步降低对磁盘吞吐量的需求，在数据仓库中特别有效的一种技术是<em>位图编码</em>(类似哈夫曼编码)，如下图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/33.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 位图编码和压缩 </span>
</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> () <span class="comment">--  对应着位图的 或</span></span><br><span class="line"><span class="keyword">and</span>   <span class="comment">--  对应着位图的 与</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>比如hive支持的存储格式包括textfile,parquet, rcfile,orc, 其中orc是rcfile的优化版(Optimize Rcfile，Rcfile基于Lazy Decompression)，相较于rcfile有更好的表现，列存和压缩通常会结合，压缩比ORC(ZLIB压缩) &gt;  Parquet (Uncompress即默认不压缩)&gt;  textFile（textfile不压缩），注意点是压缩在有效降低IO的同时会提升CPU的消耗</p>
</blockquote>
<p>列存储中的排列顺序也非常有意义。需要注意的是：即使按列存储数据，也需要一次对整行进行排序，一般对最常见的查询字段做为第一排序的列，第二列可以确定第一列中具有相同值的任何行的排序顺序，这将加快查询速度。同时，排序顺序可以帮助压缩列，第一个排序键的压缩效果最强，一个简单的运行长度编码（比如位图）可以将该列压缩到几千字节 —— 即使表中有数十亿行（不同的值很少，基数少）</p>
<p>写入列存储的困难</p>
<p>如果你想在列存排序表的中间插入一行，你很可能不得不重写所有的列文件。由于行由列中的位置标识，因此插入必须始终更新所有列（这大概就是Hive仅仅支持 <code>overwrite</code>操作的缘故）</p>
<p>另外的解决方案是，LSM树的这种结构，所有的写操作首先进入一个内存中的存储，在这里它们被添加到一个已排序的结构中，并准备写入磁盘。内存中的存储是面向行还是列的，这并不重要。当已经积累了足够的写入数据时，它们将与磁盘上的列文件合并，并批量写入新文件</p>
<p>什么是物化视图？</p>
<p>据仓库查询通常涉及一个聚合函数，如SQL中的COUNT，SUM，AVG，MIN或MAX。如果相同的聚合被许多不同的查询使用，那么每次都可以通过原始数据来处理。为什么不缓存一些查询使用最频繁的计数或总和？创建这种缓存的一种方式是物化视图。物化视图的常见特例称为数据立方体或OLAP立方</p>
<p>物化视图 和 虚拟视图的区别？</p>
<p>不同的是，物化视图是查询结果的实际副本，写入磁盘，而虚拟视图只是写入查询的捷径。从虚拟视图读取时，SQL引擎会将其展开到视图的底层查询中，然后处理展开的查询</p>
<p align="center">
  <img src="/2023/09/21/ddia/58.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 数据立方的两个维度，通过求和聚合 </span>
</p>
<h1>第四章节-编码和演化</h1>
<h2 id="什么是可演化性？">什么是可演化性？</h2>
<p>能灵活适应变化的系统， 修改数据系统并使其适应不断变化需求的容易程度，是与<strong>简单性</strong>和<strong>抽象性</strong>密切相关的：简单易懂的系统通常比复杂系统更容易修改</p>
<h2 id="向后兼容，向前兼容">向后兼容，向前兼容</h2>
<p>向后兼容(backward compatibility)：新代码可以读旧数据</p>
<p>向前兼容（forward compatibility）：旧代码可以读新数据</p>
<h2 id="编码数据的格式有哪些？">编码数据的格式有哪些？</h2>
<ol>
<li class="lvl-3">
<p>在内存中，数据保存在对象，结构体，列表，数组，哈希表，树等中。 这些数据结构针对CPU的高效访问和操作进行了优化（通常使用指针）</p>
</li>
<li class="lvl-3">
<p>如果要将数据写入文件，或通过网络发送，则必须将其编码为某种自包含的字节序列（例如，JSON文档）</p>
<blockquote>
<p>从内存中表示到字节序列的转换称为编码（也称为序列化（serialization）或编组（marshalling）），反过来称为解码（Decoding）（解析（Parsing），反序列化（deserialization）**，**反编组( unmarshalling））</p>
<p>编码过程也成为序列化Serialization，其中事务的隔离级别中也出现了该词，请区分2者</p>
<p>在一些编程语言中，都内建了将内存对象编码为字节序列的支持，Java有<code>java.io.Serializable</code> ，Python有<code>pickle</code></p>
</blockquote>
</li>
</ol>
<h2 id="文本编码和二进制编码">文本编码和二进制编码</h2>
<table>
<thead>
<tr>
<th>比对方面</th>
<th>文本编码</th>
<th>二进制编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>可读性</td>
<td>人类易读</td>
<td>人类不可读</td>
</tr>
<tr>
<td>数据类型</td>
<td>表示文本字符，如字母、数字、符号</td>
<td>表示各种类型的数据，包括整数、浮点数、图像、音频、程序指令等</td>
</tr>
<tr>
<td>编码方式</td>
<td>采用字符集（如ASCII、UTF-8、ISO-8859-1等）来将字符映射到数字或二进制，每个字符都有一个唯一的编码值</td>
<td>将数据直接表示为由 0 和 1 组成的二进制序列的方式。它不需要字符集</td>
</tr>
<tr>
<td>应用领域</td>
<td>处理文本数据，如文档、网页、电子邮件等</td>
<td>用于计算机内部数据表示、存储和通信，包括整数、浮点数、图像、音频、视频等。它处理的是更底层的数据表示</td>
</tr>
</tbody>
</table>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 二进制编码示例，删除了空格换行后，81个字节</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"userName"</span><span class="punctuation">:</span> <span class="string">"Martin"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"favoriteNumber"</span><span class="punctuation">:</span> <span class="number">1337</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"interests"</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">"daydreaming"</span><span class="punctuation">,</span> <span class="string">"hacking"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>接下来我们使用不同的二进制编码组件/库对上述的JSON文档进行编码</p>
<p align="center">
  <img src="/2023/09/21/ddia/59.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 使用不同的二进制组件编码同一个JSON文档 </span>
</p>
<p>Avro也使用模式来指定正在编码的数据的结构， 它有两种模式语言：一种（Avro IDL）用于人工编辑，一种（基于JSON），更易于机器读取</p>
<p align="center">
  <img src="/2023/09/21/ddia/61.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> Avro 二进制编码 &amp; Avro Reader 解决读写模式的差异 </span>
</p>
<h2 id="数据流的类型">数据流的类型</h2>
<p>如果要将某些数据发送到不共享内存的另一个进程，例如，通过网络发送数据或将其写入文件，就需要将它编码为一个字节序列</p>
<p>数据在流程之间流动的一些最常见的方式：</p>
<ol>
<li class="lvl-3">
<p>通过数据库：写入编码，读取解码</p>
</li>
<li class="lvl-3">
<p>通过服务调用：REST和RPC</p>
</li>
<li class="lvl-3">
<p>通过异步消息传递：消息队列</p>
</li>
</ol>
<h3 id="A-Web服务">A-Web服务</h3>
<p>有两种流行的Web服务方法：REST和SOAP</p>
<p>将大型应用程序按照功能区域分解为较小的服务，一个服务请求另外一个服务的功能或者数据，这种构建应用程序的方式传统上被称为 <strong>面向服务的体系结构（service-oriented architecture，SOA）</strong> ，也称之为 <strong>微服务架构</strong></p>
<p>REST是一个基于HTTP原则的设计哲学。它强调简单的数据格式，使用URL来标识资源，并使用HTTP功能进行缓存控制，身份验证和内容类型协商。与SOAP相比，REST已经越来越受欢迎，至少在跨组织服务集成的背景下【36】，并经常与微服务相关[31]。根据REST原则设计的API称为RESTful。</p>
<h3 id="B-RPC">B-RPC</h3>
<p>RPC是一种协议无关的通信方式，通常使用二进制协议（如Protobuf、Thrift）或文本协议（如XML-RPC、JSON-RPC）来传输数据。它允许客户端调用远程服务器上的函数，就像本地函数一样。RPC通常是无状态的，通常使用二进制格式以提高效率</p>
<p><strong>RESTful</strong>：RESTful是基于HTTP协议的通信方式，使用HTTP动词（GET、POST、PUT、DELETE等）来执行操作，并使用URL来定位资源。它使用标准的HTTP状态码来表示操作的结果。RESTful通常使用文本格式，如JSON或XML，以便数据可以被轻松解析和理解</p>
<p>RPC框架的主要重点在于同一组织拥有的服务之间的请求，通常在同一数据中心内</p>
<h1>第5章节-复制</h1>
<p>接下来是第5章的内容，这章节的内容主要是复制，所谓复制就是<strong>同一份数据保留多个副本</strong>。 复制数据的原因呢？</p>
<p>1️⃣ 使得数据与用户在地理上接近(减少延迟)</p>
<p>2️⃣ 即使系统的一部分出现故障，系统也能继续工作(提高可用性)</p>
<p>3️⃣ 扩展可以接受读请求的机器数量(提高读取吞吐量)</p>
<p>本章主要讨论三种变更<strong>复制算法</strong>（区别于复制方法/策略）：单主复制、多主复制、无主复制。当存在多个副本时，会不可避免的出现一个问题：如何确保所有数据都落在了所有的副本上？所以，复本机制真正的麻烦在于如何<strong>处理复制数据的变更</strong> 。我们来看一个非常普遍且常用解决方案：<strong>单主复制</strong></p>
<h2 id="单主复制">单主复制</h2>
<p>来具体看一个场景，更换新的用户头像的实例：</p>
<p align="center">
  <img src="/2023/09/21/ddia/34.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 单主复制 </span>
</p>
<p>总结一下单主复制符合以下的特点：</p>
<p>1️⃣ 多个副本中只有一个设置为leader,其他是flower</p>
<p>2️⃣ leader接受读请求和写请求，follower只接受读请求</p>
<p>3️⃣ follower从leader拉取日志，更新本地数据库副本</p>
<p>这种复制模式是很多关系型数据库内置的功能，比如PostgreSQL(9.0之后)，MySQL，SQL Server，文档型数据库 MongoDB。基于领导者的复制不局限于数据库，像一些高可用的分布式MQ也在用，比如Kafka、RabbitMQ</p>
<blockquote>
<p>关于主从和主备，主从中，“从”是向外提供服务的，而主备中的备不是对外提供的，备的作用是待“主”crash的时候成为主</p>
</blockquote>
<p>🎈🎈接下来呢，我们讨论复制系统的一个重要细节（复制策略）：复制是 <strong>同步(synchronously)</strong> 发生还是<strong>异步(asynchronously)</strong> 发生</p>
<h2 id="同步-异步">同步/异步</h2>
<p>如下图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/35.jpg" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 同步 &amp; 异步 </span>
</p>
<p>1️⃣ 用户 $id=1234$ 的用户向主库提交数据变更请求</p>
<p>2️⃣ 主库将数据变更同步给从库1（Follower1） ，并且等待从库1（Follower1）的响应，这里从库1（Follower1）复制的方式是同步</p>
<p>3️⃣ 主库将数据变更同步给从库2（Follower），但是不等待从库2（Follower2）的确认，这里从库2（Follower2）的复制方式是异步</p>
<p>整体的配置方式也被称作是半同步。我们来一起看下同步和异步复制的优劣势：</p>
<p>🅰️ 同步复制能够保证数据可靠性，但是如果从库迟迟不能响应主库，主库就不能接收新的读写请求</p>
<p>🅱️ 异步复制的优点是，即便从库落后了，主库也可以继续处理写入请求，劣势是无法保证数据一致性</p>
<p>我们再来看一下设置新从库的步骤：</p>
<p>1️⃣ 获取某个时刻主库的一致性快照</p>
<p>2️⃣ 将快照复制到从库节点</p>
<p>3️⃣ 从库连接主库，拉取快照之后发生的数据变更。拉取快照之后的变更，往往快照和主库复制日志关联，不同的数据库对于<em>这个关联关系</em>实现有着不同的名称：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>PostgreSQL 的叫做<strong>日志序列号(log sequence number, LSN)</strong></p>
</li>
<li class="lvl-2">
<p>MySQL将其称为 <strong>二进制日志坐标(binlog coordinates)</strong></p>
</li>
</ul>
<p>🎈🎈 从库失效的问题很好解决，从库在重新和主库建立连接之后，可以从日志知道最后一个失败的事务。然后开始追赶主库。如果主库失效了，该如何处理呢？</p>
<h2 id="处理故障节点">处理故障节点</h2>
<p><strong>主库失效如何处理？</strong></p>
<p>1️⃣ 确认主库失效</p>
<p>2️⃣ 选择一个新的主库，<strong><u>让所有的副本达成一致意见(共识<sub>consensus</sub>问题)</u></strong></p>
<p>3️⃣ 重新配置新的主库，并且启用新的主库</p>
<p>一些挑战：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果使用异步复制，发生的数据丢失问题，GitHub，MySQL从库切换为主库事故</p>
</li>
<li class="lvl-2">
<p>脑裂的情况，设置新的主库之后，老的主库又一次活过来了，可能会存在两个主库的情况，同时接受写入，可能会导致数据损坏，解决的方案可能是，发送<code>kill</code> comand 去干掉一个主库</p>
</li>
<li class="lvl-2">
<p>宣告主库死亡的阈值，主库在宣告死亡前，超时时间的设置，设置太长意味着恢复时间长，太短就会发生不必要的切换</p>
</li>
</ul>
<p><strong>基于主库的复制底层是如何工作的？</strong></p>
<p>1️⃣ 基于语句的复制，有非确定性函数、自增列的问题</p>
<p>2️⃣ 传输，预写式日志(WAL，Write Ahead Log)，日志包含所有数据库写入的仅追加字节序列，可以将其发给从库，比如说PostgreSQL 、Oracle。<strong>缺点是数据过于底层，WAL包含哪些磁盘块中的哪些字节发生了更改</strong>。这使复制与存储引擎紧密耦合，对数据库版本不友好，会对运维升级数据库造成困难</p>
<blockquote>
<p>MySQL数据库中有2种日志：redo log 和 binlog ，其中的redo log的实现方式即为WAL，先写日志，在罗盘</p>
</blockquote>
<p>3️⃣ 逻辑日志复制(基于行)，也即复制日志和存储引擎存储的日志采用不同的格式，这种复制日志被称为逻辑日志，逻辑日志有一下特点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于插入的行，日志包含所有列的新值</p>
</li>
<li class="lvl-2">
<p>对于删除的行，日志包含足够的信息来唯一标识已删除的行。通常是主键，但是如果表上没有主键，则需要记录所有列的旧值</p>
</li>
<li class="lvl-2">
<p>对于更新的行，日志包含足够的信息来唯一标识更新的行，以及所有列的新值(至少所有已更改的列的新值)</p>
</li>
</ul>
<blockquote>
<p>逻辑日志，可使领导者和跟随者能够运行不同版本的数据库软件甚至不同的存储引擎。MySQL的binlog日志有三种格式，分别是statement、row、mixed，现通常使用row模式，即逻辑日志的形式，MySQL binlog 使用row模式就是当前描述的这种方式</p>
<p>模式下数据库的变更流可以应用在MySQL从库，或者Debezium/Cancel解析后推送至三方系统(消息代理Kafka、存储系统)</p>
</blockquote>
<p>4️⃣ 基于触发器的复制，触发器能够实现，在数据库系统中发生数据更改(写入事务)时，自动执行的自定义应用程序代码，不同于数据库系统实现的复制</p>
<h2 id="复制延迟问题">复制延迟问题</h2>
<h3 id="A-什么是最终一致性？">A-什么是最终一致性？</h3>
<p>从库有可能落后于主库，此时同一个查询打到主库和从库，会得到不一样的结果，这种不一致只是一个暂时的状态，如果停止写入数据库并等待一段时间，从库最终会赶上并与主库保持一致。这种效应被称为 <strong>最终一致性（eventually consistency）</strong></p>
<h3 id="B-什么是写后读一致性？">B-什么是写后读一致性？</h3>
<p>在异步复制策略中，用户向主提交了新数据，但是该用户的查询打到了从库，这种情况下，我们需要写后读一致性（read-after-write consistency），即：自己刚刚更新的内容，再去查询的时候，可以获取到更新</p>
<p>具体实现的方式有：</p>
<ol>
<li class="lvl-3">
<p>读用户<strong>可能已经修改过</strong>的内容时，都从主库读。一个简单的规则是：从主库读取用户自己的档案，在从库读取其他用户的档案</p>
</li>
<li class="lvl-3">
<p>客户端记住最近一次写入的时间戳（可以是逻辑时间戳），如果该时间戳已经传播到了从库，从从库读取没问题，否则从主库读</p>
</li>
</ol>
<p align="center">
  <img src="/2023/09/21/ddia/60.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 写后读一致性保证 &amp; 单调读一致性保证 </span>
</p>
<h3 id="C-什么是单调读？">C-什么是单调读？</h3>
<p>用户首先从新副本读取，然后从旧副本读取。时光倒流，我们需要单调读一致性</p>
<p>实现单调读取的一种方式是，确保每个用户总是从同一个副本进行读取（不同的用户可以从不同的副本读取）。例如，可以基于用户ID的散列来选择副本，而不是随机选择副本。但是，如果该副本失败，用户的查询将需要重新路由到另一个副本</p>
<h3 id="D-什么是一致前缀读？">D-什么是一致前缀读？</h3>
<p>如果某些分区的复制速度慢于其他分区，那么观察者在看到问题之前可能会看到答案，我们需要提供某种保证，如果一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现</p>
<p align="center">
  <img src="/2023/09/21/ddia/62.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 一致前缀度保证 </span>
</p>
<p>许多分布式数据库中，不同的分区独立运行，因此不存在<strong>全局写入顺序</strong>：当用户从数据库中读取数据时，可能会看到数据库的某些部分处于较旧的状态，而某些处于较新的状态。</p>
<p>一种解决方案是，确保任何因果相关的写入都写入相同的分区。对于某些无法高效完成这种操作的应用，还有一些显式跟踪因果依赖关系的算法，本书将在“一致性与共识”一节中再次聊聊这个问题</p>
<h2 id="多主复制的问题">多主复制的问题</h2>
<p>多领导者复制的最大问题是可能发生写冲突，这意味着需要 <strong>解决冲突</strong></p>
<p align="center">
  <img src="/2023/09/21/ddia/63.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> 两个主库同时更新同一记录引起的写入冲突 </span>
</p>
<h2 id="无主复制">无主复制</h2>
<p>在无主复制，客户端的写入和读取，都请求到所有的副本，副本的写入有可能失败，有可能成功；读取时，选择按照法定人数（5个节点，3个节点返回数据相同）的数据回写到写入失败的节点。同时后台进程追踪节点之间的差异，趋势数据的收敛（因为有一些键没有读请求）</p>
<h3 id="A-什么是并发？">A-什么是并发？</h3>
<p>为了定义并发性，确切的时间并不重要：如果两个操作都意识不到对方的存在，就称这两个操作<strong>并发</strong></p>
<h1>第6章-分区</h1>
<p><strong>分区<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>是一种切分大数据集的方法，即一份数据切成多块</strong>，分区的目的是为了可扩展性，从而提高吞吐量。在实践中，分区通常和复制结合使用，每个分区的副本将处在多个节点上，以此获得容错能力。下图是主从复制模型下，分区和复制相结合的示意图：</p>
<blockquote></blockquote>
<p align="center">
  <img src="/2023/09/21/ddia/47.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 分区和复制的实例 </span>
</p>
<h2 id="键值数据的分区方式">键值数据的分区方式</h2>
<p>分区最核心的问题是</p>
<p>🅰️ 避免倾斜(skew)，即热点数据处理，放的角度</p>
<p>🅱️ 处理访问路由问题，即查询性能的保证，取的角度</p>
<p>下面我们介绍几种常见的分区方式：</p>
<p>1️⃣ 按照key的范围分区，这种方式天生可以解决访问路由的问题，对于热点数据，可根据数据状况进行拆分，Hbase,BigTable使用这种策略。在处理时间范围分区时，为避免一直写当前时间对应分区的 <strong>写入过载</strong> 问题，可引入其他列值+时间做分区</p>
<p align="center">
  <img src="/2023/09/21/ddia/48.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 按照范围分区，可以手动调整分区范围，使得分区尽量均衡</span>
</p>
<p>2️⃣ 散列<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>分区。散列分区可以很好的处理热点问题，弊端是查询能力无法保证，因为曾经相邻的密钥分散在所有分区中，这意味着如果执行范围查询，则该查询将被发送到所有分区中</p>
<p align="center">
  <img src="/2023/09/21/ddia/49.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 哈希的方式处理热点问题 </span>
</p>
改进的办法是多个列组成的复合主键，键中只有第一列会作为散列的依据，而其他列则被用作SSTables中排序数据的索引，此时如果第一列（如`user_id`）已经指定了固定值，则可以对该键的其他列（`timestamp`）执行有效的范围扫描。例如，在社交媒体网站上，一个用户可能会发布很多更新。若更新的主键被选择为`(user_id, update_timestamp)`，那么可以有效地检索，特定用户在某个时间间隔内按时间戳排序的所有更新。Casssandra使用了这种优化方式
<blockquote></blockquote>
<h2 id="分区和二级索引">分区和二级索引</h2>
<p>上文中我们讨论了 &lt;键值数据模型&gt; 的分区方案，次级索引是关系型数据库/文档型数据库的基础，也是<code>Solr</code>和<code>ElasticSearch</code>等搜索服务器的基石，次级索引由于不具备主键唯一的特性，导致我们并不能整齐的映射到各自的分区，有2种用二级索引对数据进行分区的方法：</p>
<p>🅰️ 基于文档的分区(docment-based)，如下图在汽车表/文档上建立颜色和厂商的次级索引，这种索引方法中，<strong>每个分区是完全独立，每个分区维护自己的次级索引</strong>，因此，文档分区索引也叫做本地索引(local index)。在执行特定的颜色的搜索(look for red)的时候，需要将查询发送到所有分区，并合并所有返回的结果。故，这种分区查询数据库的方式有时被称为<strong>分散/聚集(scatter/gather)</strong>，这种基于二级索引上的查询可能会相当昂贵</p>
<p align="center">
  <img src="/2023/09/21/ddia/50.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 基于文档的二级索引分区 </span>
</p>
<p>🅱️ 基于关键词(term-based)的分区，对所有分区的数据构建全局索引的同时，对全局索引进行分区。这种索引称为<strong>关键词分区(term-partitioned)</strong> <sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>，关键词分区的全局索引的优势在于不需要<strong>分散/收集</strong>所有分区，客户端只需要向包含关键词的分区发出请求。全局索引的缺点在于写入速度较慢且较为复杂，因为写入单个文档现在可能会影响索引的多个分区。在实践中，全局二级索引的更新通常是<strong>异步</strong>的</p>
<blockquote>
<p>(在任何时候)使用关键词本身进行分区适用于范围扫描，而对关键词的哈希分区提供更好的负载均衡能力</p>
</blockquote>
<p align="center">
  <img src="/2023/09/21/ddia/51.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 基于关键词的二级索引分区 </span>
</p>
<blockquote></blockquote>
<h2 id="分区再平衡">分区再平衡</h2>
<p>将负载(数据存储和读写请求)从集群中的一个节点，向另一个节点移动的过程称为<strong>再平衡(reblancing)</strong>，再平衡应该满足一下几个要求：</p>
<ol>
<li class="lvl-3">
<p>再平衡之后，负载(数据存储，读取和写入请求)应该，在集群中的节点之间公平地共享</p>
</li>
<li class="lvl-3">
<p>再平衡发生时，数据库应该继续接受读取和写入</p>
</li>
<li class="lvl-3">
<p>节点之间只移动必须的数据<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>，以便快速再平衡，并减少网络和磁盘I/O负载</p>
</li>
</ol>
<blockquote></blockquote>
<p>相应的，我们有三种分区方式，来进行处理</p>
<p>1️⃣ 固定数量的分区，创建比节点更多的分区，并为每个节点分配多个分区，如果一个节点被添加到集群中，新节点可以从当前每个节点中<strong>窃取</strong>一些分区，直到分区再次公平分配，如下图。Riak，Elasticsearch使用了这种再平衡的分区方式</p>
<p align="center">
  <img src="/2023/09/21/ddia/52.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 新节点从旧节点中窃取一些分区 </span>
</p>
<p>2️⃣ 动态分区，当分区增长到超过配置的大小时(在HBase上，默认值是10GB)，会被分成两个分区，每个分区约占一半的数据，反之进行合并，类似B树的页分裂/合并的过程</p>
<p>3️⃣ 分区数与节点数成正比，节点数量不变时，每个分区的大小与数据集大小成比例地增长，节点数增加时，分区数也增加，分区数据变少</p>
<h2 id="请求路由">请求路由</h2>
<p>数据集已经分割到多个机器上运行的多个节点上，那么当客户想要发出请求时，如何知道要连接哪个节点呢？即请求应该路由给谁？这个问题也可以概括为<strong>服务发现(service discovery)</strong>，有目前以下三种方案：</p>
<p>1️⃣ 允许客户联系任何节点(例如，通过<strong>循环策略的负载均衡(Round-Robin Load Balancer)</strong>)。如果该节点恰巧拥有请求的分区，则它可以直接处理该请求，否则，它将请求转发到适当的节点，接收回复并传递给客户端</p>
<p>2️⃣ 首先将所有来自客户端的请求发送到路由层，它决定了应该处理请求的节点，并相应地转发。此路由层本身不处理任何请求，它仅负责分区的负载均衡</p>
<p>3️⃣ 要求客户端知道分区和节点的分配。在这种情况下，客户端可以直接连接到适当的节点，而不需要任何中介</p>
<p align="center">
  <img src="/2023/09/21/ddia/53.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 客户端连接到分区的3种方式 </span>
</p>
<p>以上三种方式都会面临一个问题：作出路由决策的组件(节点之一/路由层/客户端)，如何了解分区-节点之间的分配关系变化？许多分布式数据系统都依赖于一个独立的协调服务(如ZooKeeper)来跟踪集群元数据，每个节点在ZooKeeper中注册自己，ZooKeeper维护分区到节点的可靠映射</p>
<p>其他参与者(如路由层或分区感知客户端)可以在ZooKeeper中订阅此信息。 只要分区分配发生的改变，或者集群中添加或删除了一个节点，ZooKeeper就会通知路由层使路由信息保持最新状态。HBase，SolrCloud和Kafka，使用ZooKeeper来跟踪分区分配</p>
<p>MongoDB具有类似的体系结构，但它依赖于自己的<strong>配置服务器（config server）</strong> 实现和mongos守护进程作为路由层</p>
<p align="center">
  <img src="/2023/09/21/ddia/56.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 路由层如何感知分区和节点之间的关系 </span>
</p>
<h1>第7章节-事务</h1>
<h2 id="事务的起源">事务的起源</h2>
<p>很早就接触事务这个概念，关于事务网上的文章动不动就把转账的的例子拿出来讲，坑的时候有的压根就没有讲明白，事务的概念<strong>事务要不就执行成功，要不执行失败，只有这2种状态</strong>也背的烂熟，也知道事务的4大特性ACID (原子性、一致性、隔离性、持久性)，但是这么些年从来没有思考过：为什么要有事务？他解决了什么样子的问题/痛点？那么我们带着这个问题来回顾一下事务起源：</p>
<p align="center">
  <img src="/2023/09/21/ddia/36.jpg" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> 事务的起源 </span>
</p>
<p>上图中有一个名为猪小明的程序员，抱着电脑正在疯狂的写代码(开发应用程序)，其中应用程序需要透过网络在数据库中存放数据/获取数据，数据库软件依托于是操作系统，操作系统的底层是一些计算机硬件(存储介质/磁盘/缓存/Cache/RAM /ROM/CPU/主板等)。整个过程中，各个环节都有可能出错，比如：</p>
<p>1️⃣ 网络中断，客户端和应用程序服务之间，服务和数据库之间</p>
<p>2️⃣ 数据库软件本身挂掉了，硬件发生故障<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup></p>
<blockquote></blockquote>
<p>3️⃣ 应用程序在进行写入的时候，写到一半，自己崩溃了</p>
<p>4️⃣ 多个客户端同时操作数据库，覆盖彼此的更新</p>
<p>5️⃣ 客户写到一半的数据，被另外一个客户读取到</p>
<p>6️⃣ 客户之间的竞争导致的令人惊讶的错误</p>
<p>所有的这一些都需要应用程序的开发者，猪小明去解决，但是这个工作量是巨大的，应用开发应该专注于业务，而不是通用问题的处理，这些问题应该留给下层的数据库去处理。所以为了<strong>简化应用编程模型</strong> ，事务诞生了。通过使用事务，应用程序可以自由地忽略某些潜在的错误情况和并发问题，因为数据库会替应用处理好这些问题</p>
<p>1974年的时候，IBM的圣荷西研究中心发布了，第一款提供优秀的事务处理能力的关系型数据库R[seminal-project]。时至今日开发者已经习惯了事务，他们觉得事务是理所当然的，是天然就存在的，然而并不是，了解事务出现的历史，我们可以发现事务是我们的计算机先驱们为了解决一揽子问题，提供的一种解决方案</p>
<h2 id="ACID">ACID</h2>
<p>谈及事务，必谈事务的4大特性ACID；那么ACID 分别指的是什么？</p>
<p><em><strong>A</strong>tomicity</em> ： 原子性。<strong>能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力</strong>，可以理解为<strong>可终止性</strong>。假设没有原子性，如果有多次更改，但是更改发生过程中发生了错误，应用程序很难判断哪些更改生效了，哪些没有生效。如果有了原子性，应用程序可以确定的知道在发生错误时，所有更改没有生效。<strong>没有原子性，错误处理就会变的很复杂</strong></p>
<blockquote>
<p>区别于线程的原子操作：多线程中的原子操作描述的是，如果一个线程执行一个原子操作，意味着另外一个线程无法看到该原子操作的中间结果。而这个特性在ACID中是 <em>I(isolation)</em> 来描述的</p>
</blockquote>
<p><em><strong>C</strong>onsistency</em>：一致性。在事务中，一致性是指：<strong>对数据的一组特定陈述必须始终成立</strong>，即为<em>不变量</em>，如在会计系统中，所有账户整体上必须借贷相抵，转账过程中，加钱和减钱是相等的。原子性，隔离性和持久性是数据库的属性，而一致性(在ACID意义上)是应用程序的属性</p>
<blockquote>
<p>这是一个一词多意的词，用行话来说，这个词被重载了</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>有别于副本一致性，比如在单主复制的模式下，采用异步复制的方式，收敛最终一致</p>
</li>
<li class="lvl-2">
<p>还有大家有可能会听过一致性hash(一致性散列)那是一种为了避免重新分区带来的复杂度提高的一种解决方案</p>
</li>
<li class="lvl-2">
<p>CAP定理中，C指的是线性一致性</p>
</li>
</ul>
</blockquote>
<p><em><strong>I</strong>solation</em>：隔离性。<strong>竞争条件下，同时执行的事务是相互隔离的</strong>，下图是两个客户之间的竞争状态同时递增计数器的图述。<strong>缺乏隔离性，就会导致并发问题</strong></p>
<p align="center">
  <img src="/2023/09/21/ddia/02.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 两个客户之间的竞争状态同时递增计数器 </span>
</p>
<p><em><strong>D</strong>urability</em> ：持久性。持久性是事务的一个承诺，也即事务完成后，即便发生硬件故障或者数据库崩溃，写入的任务数据也不会丢失。持久性过去一般被认为写入了非易失性存储介质</p>
<h2 id="单对象操作和多对象操作">单对象操作和多对象操作</h2>
<p><strong>单一对象操作</strong>，所谓单对象操作中的对象，指的是数据库中被修改的对象，比如你正在向数据库写入一个20KB的Json文档，以下场景可能会发生：</p>
<p>1️⃣ 在发送第一个10KB之后，网络连接中断，数据库是否存储了不可解析的10KBJSON片段？</p>
<p>2️⃣ 在数据库正在覆盖的磁盘上前一个值的过程中电源发生故障，是否最终将新旧值拼接在一起？</p>
<p>3️⃣ 如果另一个客户端在写入过程中读取该文档，是否会看到部分更新？</p>
<p>这里的 JSON对象，就是单一对象，单一对象是相对于多对象而言的，待会我们会谈及到多对象。为了针对以上的问题，存储引擎会在单个对象上提供原子性和隔离性，如此一来：</p>
<p>🅰️ 原子性通过WAL(即redo-log)日志来实现崩溃恢复</p>
<p>🅱️ 使用每个对象的锁来实现隔离(每次仅仅允许一个线程访问对象)</p>
<p>除了单对象操作，还有就是CAS(Compare-and-set)，防止多个客户端同时写入同一个对象时的更新丢失，即当值没有并发被其他人修改的时候，才允许执行写入操作。CAS操作和单对象操作，被称作是轻量级事务。<strong>事务通常更多的强调 ： 将多个对象的多个操作合并为一个执行的单元的机制</strong></p>
<p><strong>何为多对象？</strong> 在操作数据库时，需要协调写入几个不同的对象：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>关系模型中，一个表中的行对另外一个表的外键引用。你得确保外键是最新的，可用的</p>
</li>
<li class="lvl-2">
<p>在字段冗余的场景中，单个字段在多处被存储，你得保证这几处是同步的</p>
</li>
<li class="lvl-2">
<p>二级索引的数据库中，数据更新的时候，二级索引也需要更新</p>
</li>
</ul>
<p>在这种情形下，需要使用事务来进行处理</p>
<p>接下来我们会讲述隔离级别，在讲述隔离级别之前，明确两点：</p>
<p>🅰️ 隔离级别是对事务的4大特性之一隔离性上进行了一个等级划分，数据库标准的事务隔离级别包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>读未提交(read uncommitted)</p>
</li>
<li class="lvl-2">
<p>读已提交(read committed)</p>
</li>
<li class="lvl-2">
<p>可重复读/快照隔离(repeatable read)</p>
</li>
<li class="lvl-2">
<p>串行化(serializable)</p>
</li>
</ul>
<p>🅱️ 隔离级别最高是可序列化，表示同一时间只能有一个事务。隔离级别和性能之间是一个负相关的关系，也就是说隔离级别越高，数据一致性的保证越好，但是性能越差。隔离级别是数据一致性和服务性能的一场博弈。为了实现更优的性能，我们需要较弱的隔离级别</p>
<p>下面介绍这些弱隔离级别</p>
<h2 id="读已提交">读已提交</h2>
<p>最基本的弱隔离级别是，读已提交，它提供了两个保证：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>没有<strong>脏读(dirty reads)</strong>，从数据库读时，只能看到已提交的数据</p>
</li>
<li class="lvl-2">
<p>没有<strong>脏写(dirty writes)</strong>，写入数据库时，只会覆盖已经写入的数据</p>
</li>
</ul>
<p>另外读未提交：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>可以防止脏写</p>
</li>
<li class="lvl-2">
<p>但是不能够防止脏读</p>
</li>
</ul>
<p>下图是一个没有脏读的例子：可以看到<em>直到用户1提交了之后</em>，用户2才看到提交之后的值x=3,而在这之前用户1只能看到x=2</p>
<p align="center">
  <img src="/2023/09/21/ddia/03.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 用户2只有在用户1的事务已经提交后才能看到x的新值 </span>
</p>
<p>那么为什么要防止脏读呢？主要是下面两个原因：</p>
<p>1️⃣ 如果事务需要更新多个对象，脏读取意味着另一个事务可能会只看到一部分更新。比如说下面这个电子邮件的例子。事务还没有提交，但是用户2看到了未读邮件，可是未读邮件的数量却还是旧值</p>
<p align="center">
  <img src="/2023/09/21/ddia/04.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 一个事务读取另一个事务的未被执行的写入（“脏读”） </span>
</p>
<p>2️⃣ 若数据库允许脏读，意味着一个事务可能会看到稍后需要回滚的数据，即从未实际提交给数据库的数据。比如下面的例子中读到了未提交的数据，但是后面事务回滚了</p>
<p align="center">
  <img src="/2023/09/21/ddia/05.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 原子性确保发生错误时，事务先前的任何写入都会被撤消，以避免状态不一致 </span>
</p>
<p>两个事务同时更新数据库中的对象，先前的写入没有提交，后面的写入覆盖这个尚未提交的值，这就是脏写。没有脏写，意味着在写入数据库时，只会覆盖已经写入的数据。在<strong>读已提交</strong>的隔离级别上运行的事务必须防止脏写，通常是延迟第二次写入，直到第一次写入事务提交或中止为止。下图是脏写发生的示例，发票属于Alice; 销售属于Bob’</p>
<p align="center">
  <img src="/2023/09/21/ddia/06.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 如果存在脏写，来自不同事务的冲突写入可能会混淆在一起 </span>
</p>
<h2 id="实现读已提交">实现读已提交</h2>
<p>读已提交是一种非常Fashion的一个隔离级别，有很多数据库软件将读已提交设置为默认的隔离级别，比如Oracle 11、PostgreSQL、SQLServer 2012 ，那么如何实现</p>
<p>1️⃣ 无脏写保证：数据库通过使用 <strong>行锁(row-level lock)<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup></strong> 来防止脏写；即当事务想要修改特定对象时，必须获取该对象的锁，然后必须持有该锁，直到事务被提交或终止。这种锁定是读已提交模式（或更强的隔离级别）的数据库自动完成的</p>
<blockquote></blockquote>
<p>2️⃣ 无脏读保证：MVCC<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup> ，数据库都会记住旧的已提交值，和当前持有写入锁的事务设置的新值。 当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值</p>
<blockquote>
<p align="center">
  <img src="/2023/09/21/ddia/07.png" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 一个值从1按顺序修改为4的过程。在读已提交的隔离级别下，仅仅保留为提交版本和提交前版本2个版本 </span>
</p>
</blockquote>
<p>读已提交的隔离级别无法避免<em>不可重复读</em>的情况，下面的例子：爱丽丝在银行有1000美元的储蓄，两个账户，每个500美元；现在一个事务从她的一个账户中，转移了100美元到另一个账户</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Alice在转账事务之前查询了账户1的金额为500元</p>
</li>
<li class="lvl-2">
<p>Alice在转账之后完成之后，查询了账户2的金额为400元</p>
</li>
<li class="lvl-2">
<p>此时账户的总额为900元，Alice就很疑惑为什么自己的钱少了？</p>
</li>
</ul>
<p align="center">
  <img src="/2023/09/21/ddia/07.jpg" width="75%" alt="Your image description">
    <br>
  <span style="color:gray">读取偏差：Alice观察数据库处于不一致的状态 </span>
</p> 
<p>这种，这种异常被称为<strong>不可重复读(nonrepeatable read)</strong>，如果Alice在事务结束时再次读取账户1的余额，她将看到与她之前的查询中看到的不同的值(600美元)。在读已提交的隔离条件下，<strong>不可重复读</strong>可能会发生</p>
<h2 id="实现快照隔离">实现快照隔离</h2>
<p>快照隔离的另外一个叫法是可重复读，快照隔离和读已提交一致，使用写锁来防止脏写，也就是正在进行写入的事务会阻止另外一个事务修改同一个对象。读取没有任何的锁定，<strong>写不阻塞读，读不阻塞写</strong>，RC下也是，数据库使用<strong>多版本并发控制(MVCC, multi-version concurrentcy control)</strong> 数据库保留一个对象的几个不同的提交版本。另外使用MVCC实现快照隔离的存储引擎通常也会使用MVCC来实现读已提交(一个对象的两个版本：提交的版本和被覆盖但尚未提交的版本)</p>
<p align="center">
  <img src="/2023/09/21/ddia/08.jpg" width="75%" alt="Your image description">
    <br>
  <span style="color:gray">  使用多版本对象实现快照隔离 </span>
</p>
<p>那么我们再来看一下<em>一致性快照的可见性规则</em>：也就是说当一个事务从数据库中读取时，事务ID用于决定它可以看见哪些对象，看不见哪些对象。规则如下：</p>
<p>1️⃣ 在每次事务开始时，数据库列出当时所有其他(尚未提交或中止)的事务清单，即使之后提交了，这些事务的写入也都会被忽略</p>
<p>2️⃣ 被中止事务所执行的任何写入都将被忽略</p>
<p>3️⃣ 由具有较晚事务ID(即，在当前事务开始之后开始的)的事务所做的任何写入都被忽略，而不管这些事务是否已经提交</p>
<p>4️⃣ 所有其他写入，对应用都是可见的</p>
<p>更简单的讲，对于隔离级别的实现数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准</p>
<p>1️⃣ “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念</p>
<p>2️⃣ 在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的</p>
<p>3️⃣ 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图</p>
<p>4️⃣ “串行化”隔离级别下直接用加锁的方式来避免并行访问</p>
<h2 id="丢失更新">丢失更新</h2>
<p>前面描述的是读-写并发场景下，只读事务在并发写入时候能看到什么，另外一个问题是两个事务并发写入的问题，即写-写冲突。如下图就是<strong>丢失更新</strong>的例子</p>
<p align="center">
  <img src="/2023/09/21/ddia/02.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> 丢失更新：两个客户之间的竞争状态同时递增计数器 </span>
</p>
<p>解决写-写冲突有很多方式，比如原子写（数据库提供），显示锁定，比较并设置(CAS)</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 数据库提供原子更新操作，消除在应用程序代码中执行读取-修改-写入序列的需要</span></span><br><span class="line"><span class="keyword">update</span> counters <span class="keyword">set</span> <span class="keyword">value</span> <span class="operator">=</span> <span class="keyword">value</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">where</span> key <span class="operator">=</span> <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示锁定</span></span><br><span class="line"><span class="keyword">begin</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> figures</span><br><span class="line">    <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">'robot'</span> <span class="keyword">and</span> game_id <span class="operator">=</span> <span class="number">222</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- `for update` 子句告诉数据库应该对该查询返回的所有行加锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查玩家的操作是否有效，然后更新先前select返回棋子的位置</span></span><br><span class="line"><span class="keyword">update</span> figures <span class="keyword">set</span> position <span class="operator">=</span> <span class="string">'c4'</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置(CAS)</span></span><br><span class="line"><span class="keyword">update</span> wiki_pages <span class="keyword">set</span> content <span class="operator">=</span> <span class="string">'新内容'</span></span><br><span class="line">  <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1234</span> <span class="keyword">and</span> content <span class="operator">=</span> <span class="string">'旧内容'</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>在MySQL中，使用当前读<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup>的方式来处理写-写冲突，下图为RR隔离级别下，写-写冲突的例子</p>
<blockquote></blockquote>
<p align="center">
  <img src="/2023/09/21/ddia/10.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray">  </span>
</p>
<h2 id="写偏差">写偏差</h2>
<p>如果两个事务读取相同的对象，然后不同的事务可能更新不同的对象，则可能发生写偏差(写偏差包含丢失更新)</p>
<p>下面是写偏差的例子，描述的是一个医生轮班管理程序，医院有以下的要求：至少有一位医生在待命，现在Alice 和 Bob 两位值班医生都感觉到不适，决定请假：</p>
<p align="center">
  <img src="/2023/09/21/ddia/09.jpg" width="75%" alt="Your image description">
    <br>
  <span style="color:gray"> 写入偏差导致应用程序错误的示例 </span>
</p>
<p>在多个事务更新同一个对象的特殊情况下，就会发生脏写或丢失更新(取决于时机) <strong>防止写偏差，需要使用序列化隔离级别</strong></p>
<h2 id="幻读">幻读</h2>
<p><strong>一个事务中的写入改变另一个事务的搜索查询的结果，称为幻读</strong></p>
<p>下图是一个幻读的例子：</p>
<blockquote>
<p>幻读会导致写偏差。快照隔离避免了只读事务中的幻读，但是无法避免读写事务中的幻读。从上面的例子来看，幻读的问题貌似是没有对象可以加锁。人为的引入锁对象的方式被称之为<em>物化冲突</em></p>
</blockquote>
<p align="center">
  <img src="/2023/09/21/ddia/11.jpg" width="75%" alt="Your image description">
    <br>
  <span style="color:gray"> 干扰事务 干扰 主事务的执行 </span>
</p>
<p>🅰️ 主事务，检测表中是否有<code>id=1</code>的记录，没有则插入（<code>for update</code> 没有用，因为没有加锁对象），这是我们期望的正常业务逻辑</p>
<p>🅱️ 干扰事务，目的在于扰乱，主事务的正常的事务执行</p>
<p>我们看到，干扰事务率先执行了，主事务发生了幻读，因为主事务读取的状态并不能支持它的下一步逻辑，感觉看到了幻影。上例中是干扰事务妨碍了主事务搜索结果。在MySQL中，使用间隙锁（下文会涉及到）来处理幻读问题。<em>不可重复读侧重表达读-读，幻读则是说读-写，用写来证实读的是鬼影</em></p>
<h2 id="序列化-串行化">序列化/串行化</h2>
<p>对串行化的理解应当是这样的：一次只执行一个事务。设计单线程的系统有时候比支持并发的系统更好，因为它可以避免协调锁的开销。数据库的早期，数据库意图包含整个用户的活动流程，但是如今的web应用，一个事务不会跨越多个请求，事务会在同一个HTTP请求被提交</p>
<h3 id="两阶段锁定-2PL">两阶段锁定-2PL</h3>
<p>30年以来，数据库中只有一种广泛使用的序列化算法：<strong>两阶段锁定(2PL，two-phase locking)</strong>。两阶段这个名字的来源：第1阶段（当事务正在执行时）获取锁，第2阶段(在事务结束时)释放所有的锁</p>
<p>2PL要求只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入(修改或删除)，就需要<strong>独占访问(exclusive access)</strong> 权限。锁可以处于<em>共享模式</em>，可以处于<em>独占模式</em>：</p>
<p>1️⃣ 若事务要读取对象，则须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务已经在对象上持有排它锁，则这些事务必须等待</p>
<p>2️⃣ 若事务要写入一个对象，它必须首先以独占模式获取该锁。没有其他事务可以同时持有锁(无论是共享模式还是独占模式)，所以如果对象上存在任何锁，该事务必须等待</p>
<p>3️⃣ 如果事务先读取再写入对象，则它可能会将其共享锁升级为独占锁。升级锁的工作与直接获得排他锁相同</p>
<p>4️⃣ 事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）</p>
<p>由于加了这么多的锁，可能会发生死锁情况，死锁及死锁检测的内容可以看看MySQL的笔记</p>
<p>在Java中有这么一个定律：对象（Object）就是锁，前面内容涉及到的锁都是针对特定对象的(如表中的一行)，对于某些更改没有特定对象，有没有一种锁针对这种场景呢？</p>
<h3 id="谓词锁">谓词锁</h3>
<p>谓词锁类似于共享/排它锁，但不属于特定的对象（例如，表中的一行），它属于所有符合某些搜索条件的对象，如：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> bookings</span><br><span class="line"><span class="keyword">where</span> room_id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">and</span></span><br><span class="line">      end_time <span class="operator">&gt;</span> <span class="string">'2018-01-01 12:00'</span> <span class="keyword">and</span> </span><br><span class="line">      start_time <span class="operator">&lt;</span> <span class="string">'2018-01-01 13:00'</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>谓词锁限制访问：</p>
<p>🅰️ 如果事务A想要，<strong>读取</strong>匹配某些条件的对象，就像在这个 <code>select</code> 查询中那样，它必须获取查询条件上的<strong>共享谓词锁(shared-mode predicate lock)</strong>。如果另一个事务B，持有任何满足这一查询条件对象的排它锁，事务A必须等到B释放它的锁之后才允许进行查询</p>
<p>🅱️ 如果事务A想要，<strong>插入，更新或删除</strong>任何对象，则必须首先检查旧值或新值，是否与任何现有的谓词锁匹配。如果事务B持有匹配的谓词锁，那么A必须等到B已经提交或中止后才能继续</p>
<p>谓词锁的关键思想是，<strong>谓词锁甚至适用于数据库中尚不存在，但将来可能会添加的对象（幻象）</strong>。和快照隔离的区别在是：快照隔离中读不阻塞写，写不阻塞读；2PL中，写阻塞读，读阻塞写</p>
<h3 id="索引范围锁">索引范围锁</h3>
<p>索引范围锁，也称为<strong>间隙锁(next-key locking)</strong></p>
<p>谓词锁的弊端是性能不佳：<strong>如果活跃事务持有很多锁，检查匹配的锁会非常耗时</strong>。因此，大多数使用2PL的数据库实际上实现了索引范围锁，间隙锁是一种简化的近似版谓词锁</p>
<p>比如在房间预订数据库中，您可能会在<code>room_id</code>列上有一个索引，并且/或者在<code>start_time</code> 和 <code>end_time</code>上有索引（否则前面的查询在大型数据库上的速度会非常慢</p>
<p>🅰️ 假设您的索引位于<code>room_id</code>上，并且数据库使用此索引查找<code>123</code>号房间的现有预订。现在数据库可以简单地将共享锁附加到这个索引项上，指示事务已搜索<code>123</code>号房间用于预订</p>
<p>🅱️ 或者，如果数据库使用基于时间的索引来查找现有预订，那么它可以将共享锁附加到该索引中的一系列值，指示事务已经将<code>12:00~13:00</code> 时间段标记为用于预定</p>
<p>无论哪种方式，搜索条件的近似值都附加到其中一个索引上。现在，如果另一个事务想要插入，更新或删除同一个房间和/或重叠时间段的预订，则它将不得不更新索引的相同部分。在这样做的过程中，它会遇到共享锁，它将被迫等到锁被释放。这种方法能够有效防止幻读和写入偏差</p>
<h2 id="序列化快照隔离（SSI）">序列化快照隔离（SSI）</h2>
<p><strong>可序列化快照隔离(SSI, serializable snapshot isolation)</strong> 它提供了完整的可序列化隔离级别，但与快照隔离相比只有只有很小的性能损失，是一种新的隔离技术</p>
<h2 id="总结-2">总结</h2>
<p>1️⃣ 脏读: 一个客户端读取到另一个客户端尚未提交的写入。<strong>读已提交</strong>或更强的隔离级别可以防止脏读</p>
<p>2️⃣ 脏写: 一个客户端覆盖写入了另一个客户端尚未提交的写入。几乎所有的事务实现都可以防止脏写</p>
<p>3️⃣ 读取偏差(不可重复读): 在同一个事务中，客户端在不同的时间点会看见数据库的不同状态。<strong>快照隔离</strong>经常用于解决这个问题，它允许事务，从一个特定时间点的一致性快照中读取数据。快照隔离通常使用<strong>多版本并发控制(MVCC)</strong> 来实现</p>
<p>4️⃣ 更新丢失: 两个客户端同时执行<strong>读取-修改-写入序列</strong>。其中一个写操作，在没有合并另一个写入变更情况下，直接覆盖了另一个写操作的结果。所以导致数据丢失。快照隔离的一些实现可以自动防止这种异常，而另一些实现则需要手动锁定(<code>select for update</code>)</p>
<blockquote>
<p>和脏写的区别在于：脏写是覆盖尚未提交的写入，更新丢失是覆盖了一个已提交的写入</p>
</blockquote>
<p>5️⃣ 写偏差: 一个事务读取一些东西，根据它所看到的值作出决定，并将决定写入数据库。但是，写的时候，决定的前提不再是真实的。只有可序列化的隔离才能防止这种异常</p>
<p>6️⃣ 幻读 : 事务读取符合某些搜索条件的对象，另一个客户端进行写入，影响搜索结果。快照隔离可以防止直接的幻像读取，但是写入歪斜环境中的幻读需要特殊处理，例如索引范围锁定。只有可序列化的隔离才能防范所有这些问题。我们讨论了实现可序列化事务的三种不同方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>字面意义上的串行执行: 如果每个事务的执行速度非常快，并且事务吞吐量足够低，足以在单个CPU核上处理，这是一个简单而有效的选择</p>
</li>
<li class="lvl-2">
<p>两阶段锁定: 数十年来，两阶段锁定一直是实现可序列化的标准方式，但是许多应用出于性能问题的考虑避免使用它</p>
</li>
<li class="lvl-2">
<p><strong>可串行化快照隔离(SSI)</strong></p>
</li>
</ul>
<h1>第9章节-一致性与共识</h1>
<p>构建容错系统的最好方法，是找到一些带有实用保证的通用抽象，实现一次，然后让应用依赖这些保证。比如通过使用<strong>事务</strong>这个抽象，应用可以假装没有崩溃(原子性)，没有其他人同时访问数据库(隔离性)，存储设备是完全可靠的(持久性)。即使发生崩溃，竞态条件和磁盘故障，事务抽象隐藏了这些问题，因此应用不必担心它们</p>
<p>同样的分布式系统最重要的抽象之一就是<strong>共识(consensus)</strong>：<strong>其非正式定义是让所有的节点对某件事达成一致</strong></p>
<blockquote>
<p>分布式一致性模型和事务的特性ACID中的一致性 ，隔离级别的区别❓</p>
<p>ACID一致性的概念是，<strong>对数据的一组特定陈述必须始终成立</strong>。即<strong>不变量(invariants)</strong></p>
<p>分布式一致性主要是关于：面对延迟和故障时，如何协调副本间的状态</p>
<p>事务隔离的目的是为了，避免由于同时执行事务而导致的竞争状态</p>
</blockquote>
<h2 id="线性一致性">线性一致性</h2>
<p>多数的数据库提供了最终一致性的保证(数据是最终收敛的)。最终一致性的问题是：如果你在同一个时刻问2个副本同样一个问题，可能得到不同的答案，<strong>线性一致性</strong>尝试提供只有一个副本的假象，即提供新鲜度保证(一个客户端完成写操作，所有client可以必须能看到最新的答案)</p>
<blockquote>
<p>线性一致性和可序列化的区别❓</p>
<p>可序列化是事务的隔离性，它确保事务的执行是特定的顺序</p>
<p>线性一致性是读取和写入寄存器(单个对象)的新鲜度保证，它不会将多个操作组合为事务</p>
<p>一个数据库可以提供可串行性和线性一致性，这种组合称之为，单副本强可串行性(strong-1SR)，基于2阶段锁的可串行化实现，通常是线性一致的，可重复读不是线性一致的</p>
</blockquote>
<h3 id="线性一致性的作用">线性一致性的作用</h3>
<p>🅰️ 单主复制的系统中，领导选取(只有一个节点持有锁)</p>
<p>🅱️ 唯一性约束(只有一个对象持有该id)</p>
<h3 id="实现线性一致的系统">实现线性一致的系统</h3>
<p>1️⃣ 单主复制：可能线性一致</p>
<p>2️⃣ 共识算法：线性一致</p>
<p>3️⃣ 多主复制：非线性一致</p>
<h2 id="CAP">CAP</h2>
<p>有一种说法是： 一致性、可用性、分区容错性，三者只能选择其二，这种说法有一定的误导性。这里的<em>P</em>指的是网络分区<sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup>，网络分区是一种故障，是一定会(概率事件)存在的，P不是一个可选项而是一个必选项，那么就有了</p>
<p>🅰️ CP : 在网络分区下一致但不可用 。若应用需要线性一致性，某些副本和其他副本断开连接，那么这些副本掉线时不能处理请求(单主复制+同步)，请求必须等到网络问题解决，或直接返回错误。无论哪种方式，服务都<strong>不可用(unavailable)</strong></p>
<p>🅱️ AP : 在网络分区下可用但不一致 。应用不需要线性一致性，那么某个副本即使与其他副本断开连接，也可以独立处理请求（例如多主复制）。在这种情况下，应用可以在网络问题前保持可用，但其行为不是线性一致的</p>
<blockquote></blockquote>
<h2 id="全序-vs-偏序">全序 vs 偏序</h2>
<h3 id="因果顺序不是全序的">因果顺序不是全序的</h3>
<p>自然数集是全序的，如1,2,3；数学集合是偏序的，比如<code>{a,b}</code>  和 <code>{b,c}</code> 是没有办法比较大小的。线性一致是全序的，不存在任何并发，所有的操作在一条时间线上。而因果关系是偏序的，存在着并发，线性一致性强于因果一致性，但是性能不如因果一致性</p>
<h3 id="序列号顺序">序列号顺序</h3>
<p>显示跟踪所有已读数据确保因果关系意味着巨大的额外开销，可以使用序列号或时间戳来排序事件，时间戳并不一定来自时钟，可以是一个逻辑时钟(自增计数器)，单主复制的数据库中，主库为每个操作自增一个计数器，从库按照复制日志的顺序来应用写操作，那么从库的状态始终是因果一致的</p>
<h3 id="非因果序列号生成器">非因果序列号生成器</h3>
<p>对于无主复制或者多主复制，如何生成序列号呢？有下面三种方式：</p>
<p>1️⃣ 每个节点生成自己独立的一组序列号，如有2个节点，一个奇数一个偶数</p>
<p>2️⃣ 将物理时钟附加到每个操作上，也许可以提供一个全序关系</p>
<p>3️⃣ 预先分配序列区块号，如节点A是1-1000区块的所有权；节点B是1001-2000区块的所有权</p>
<p>三种共同的问题是：生成的序列号与因果关系不一致。兰伯特时间戳可以产生与因果关系一致的时间戳</p>
<h3 id="兰伯特时间戳">兰伯特时间戳</h3>
<p>(计数器，节点ID)$(counter, node ID)$ 组成<em>兰伯特</em>时间戳，每个节点和每个客户端跟踪迄今为止所见到的最大<strong>计数器</strong>值，并在每个请求中包含这个最大计数器值。当一个节点收到最大计数器值大于自身计数器值的请求或响应时，它立即将自己的计数器设置为这个最大值。下面2条规则去判断：</p>
<p>🅰️ 如果你有两个时间戳，则<strong>计数器</strong>值大者是更大的时间戳</p>
<p>🅱️  如果计数器值相同，则节点ID越大的，时间戳越大</p>
<p align="center">
  <img src="/2023/09/21/ddia/12.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>其中客户端 A 从节点2 接收计数器值 <code>5</code> ，然后将最大值 <code>5</code> 发送到节点1 。此时，节点1 的计数器仅为 <code>1</code> ，但是它立即前移至 <code>5</code> ，所以下一个操作的计数器的值为 <code>6</code> 。虽然兰伯特时间戳定义了一个与因果一致的全序，但它还不足以解决分布式系统中的许多常见问题，比如确保用户名能唯一标识用户帐户的系统，你得搜集所有相同用户名的兰伯特时间戳，才能比较他们的时间戳，节点无法马上决定当前请求失败还是成功。所以仅知道全序是不够的，还需要知道全序何时结束</p>
<h2 id="全序广播-原子广播">全序广播(原子广播)</h2>
<p>全序广播通常被描述为在节点间交换消息的协议。 非正式地讲，它要满足两个安全属性：</p>
<p>1️⃣ 可靠交付（reliable delivery）:  没有消息丢失：如果消息被传递到一个节点，它将被传递到所有节点</p>
<p>2️⃣ 全序交付（totally ordered delivery）:  消息以相同的顺序传递给每个节点</p>
<p>正确的全序广播算法必须始终保证可靠性和有序性，即使节点或网络出现故障。当然在网络中断的时候，消息是传不出去的，但是算法可以不断重试，以便在网络最终修复时，消息能及时通过并送达</p>
<p>可以使用全序广播来实现可序列化的事务，由于具备上述2个安全属性，数据库的分区和副本就可以相互保持一致。<em>节点得到了共识</em></p>
<blockquote>
<p>🅰️ <strong>全序广播等于共识</strong></p>
<p>🅱️ <strong>线性一致的CAS等于共识</strong></p>
</blockquote>
<h2 id="分布式事务与共识">分布式事务与共识</h2>
<p>共识的目标只是<strong>让几个节点达成一致(get serveral nodes to agree on something)</strong>。节点达成一致(共识)的应用场景：</p>
<p>🅰️ 领导选取：如在单主复制中，如果有2个以上领导就会有发生脑裂情况，脑裂时2主都会接收写入，导致数据不一致或数据丢失</p>
<p>🅱️ 原子提交：在跨多节点或跨多分区事务的数据库中，所有节点必须就：<em>一个事务是否成功</em>这件事达成一致(要不都成功；要不都失败)</p>
<p>2PC是一个最简单的共识算法，更好的一致性算法比如ZooKeeper(Zab)和etcd(Raft)中使用的算法</p>
<blockquote>
<p>区分普通事务和两种的不同的分布式事务</p>
<p>0️⃣ 普通事务是相对单个节点而言的多对象操作；而分布式事务涉及多个节点</p>
<p>1️⃣ 数据库内部的分布式事务， 一些分布式数据库(即在其标准配置中使用复制和分区的数据库)支持数据库节点之间的内部事务，比如MySQL Cluster的NDB存储引擎就有这样的内部事务支持。此情形下，所有参与事务的节点都运行相同的软件</p>
<p>2️⃣ 异构分布式事务：在异构事务中，参与者是2者或者以上的技术，比如来自不同供应商的2个数据库/消息代理，跨系统的分布式事务需要保证原子提交</p>
</blockquote>
<h2 id="原子提交和2PC">原子提交和2PC</h2>
<p>对于多对象事务及维护次级索引的数据库，原子提交可以防止失败的事务搅乱数据库，避免数据库陷入半成品结果和半更新状态；对于单对象的原子性一般时都由数据库(存储引擎)本身保证。 <strong>两阶段提交(two-phase commit)</strong> 是一种用于实现跨多个节点的原子事务提交的算法，即确保所有节点提交或所有节点中止</p>
<p align="center">
  <img src="/2023/09/21/ddia/13.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>2PC使用一个通常不会出现在单节点事务中的新组件：<strong>协调者(coordinator)</strong>（也称为<strong>事务管理器(transaction manager)</strong>）。2PC事务以应用在多个数据库节点(<strong>参与者(participants)</strong>)上读写数据开始。当应用准备提交时，协调者开始阶段1：它发送一个 <strong>准备(prepare)</strong> 请求到每个节点，询问它们是否能够提交，然后协调者会跟踪参与者的响应：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果所有参与者都回答“是”，表示它们已经准备好提交，那么协调者在阶段2发出 <strong>提交(commit)</strong> 请求，然后提交真正发生</p>
</li>
<li class="lvl-2">
<p>如果任意一个参与者回复了“否”，则协调者在阶段2 中向所有节点发送 <strong>中止(abort)</strong> 请求</p>
</li>
</ul>
<p>2PC具体的流程如下：</p>
<p>1️⃣ 当应用想要启动一个分布式事务时，它向协调者请求一个事务ID。此事务ID是全局唯一的</p>
<p>2️⃣ 应用在每个参与者上启动单节点事务，并在单节点事务上捎带上这个全局事务ID</p>
<p>3️⃣ 当应用准备提交时，协调者向所有参与者发送一个<strong>准备</strong>请求，并打上全局事务ID的标记。如果任意一个请求失败或超时，则协调者向所有参与者发送针对该事务ID的中止请求</p>
<p>4️⃣ 参与者收到准备请求时，需要确保在任意情况下都可以提交事务。这包括将所有事务数据写入磁盘(出现故障，电源故障，或硬盘空间不足都不能是稍后拒绝提交的理由)以及检查是否存在任何冲突或违反约束。通过向协调者回答“是”，节点承诺，只要请求，这个事务一定可以不出差错地提交。换句话说，<em>参与者放弃了中止事务的权利，但没有实际提交</em></p>
<p>5️⃣ 当协调者收到所有准备请求的答复时，会就提交或中止事务作出明确的决定(只有在所有参与者投赞成票的情况下才会提交)。协调者必须把这个决定写到磁盘上的事务日志中，如果它随后就崩溃，恢复后也能知道自己所做的决定。这被称为<strong>提交点(commit point)</strong></p>
<p>6️⃣一旦协调者的决定落盘，提交或放弃请求会发送给所有参与者。如果这个请求失败或超时，协调者必须永远保持重试，直到成功为止。没有回头路：如果已经做出决定，不管需要多少次重试它都必须被执行。如果参与者在此期间崩溃，事务将在其恢复后提交——由于参与者投了赞成，因此恢复后它不能拒绝提交</p>
<p>下图是MySQL的两阶段提交过程，该过程保证bin-log和redo-log一致</p>
<p align="center">
  <img src="/2023/09/21/ddia/03.png" width="55%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<h2 id="协调者失效">协调者失效</h2>
<p>上述第3️⃣步中很协调者发送“准备”请求之前失败，参与者可以安全的终止事务；在第5️⃣ 步中如果任何提交和终止请求失败，协调者将无条件重试，但是协调者崩溃，参与者就什么也做不了只能等待。参与者的这这种事务状态称为：<strong>存疑或者不确定</strong></p>
<p align="center">
  <img src="/2023/09/21/ddia/14.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>上图中：协调者实际上决定提交，数据库2收到提交请求，但是协调者在将提交请求发送到数据库1之前发生崩溃，因此数据库1不知道是否提交或中止。这里即便<strong>超时</strong>， 也是没用的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果数据库1 在超时后单方面中止，它将最终与执行提交的数据库2 不一致</p>
</li>
<li class="lvl-2">
<p>单方面提交也是不安全的，因为另一个参与者可能已经中止了</p>
</li>
</ul>
<p>此时完成2PC的唯一方法是等待协调者恢复，因此，协调者必须在<em>向</em>参与者发送提交/中止请求之前，将其提交/中止决定写入磁盘上的事务日志，协调者恢复后，通过读取其事务日志来确定所有存疑事务的状态，任何在协调者日志中没有提交记录的事务都会中止</p>
<h2 id="恰好一次的消息处理">恰好一次的消息处理</h2>
<p>异构的分布式事务能够集成两种不同的系统，比如当用于处理消息的数据库事务成功提交后，消息队列中的一条消息可以被认为已处理。如果消息或者数据库事务任意一个失败，2者都会终止，而消息代理可能会在稍后安全的重传消息。通过这种方式，可以确保消息被有效地恰好处理一次</p>
<h2 id="XA事务">XA事务</h2>
<p>扩展架构(eXtended Architecture)是跨异构技术实现两阶段提交的标准。许多关系型数据库(PostgresSQL、MySQL、SQL Server、Oracle))和消息代理(ActiveMQ，HornetQ，MSMQ和IBM MQ)都支持XA</p>
<h2 id="容错共识">容错共识</h2>
<blockquote>
<p>共识的定义：一个或多个节点可以**提议(propose)<strong>某些值，而共识算法</strong>决定(decides)**采用其中的某个值</p>
<p>共识算法需要满足以下性质：</p>
<p>1️⃣ 一致同意：没有2个节点的决定不同</p>
<p>2️⃣ 完整性：没有节点决定2次</p>
<p>3️⃣ 有效性：如果一个节点决定了值<code>v</code>,则<code>v</code>由某个节点所提议</p>
<p>4️⃣ 终止 ： 由所有未崩溃的节点来最终决定值</p>
</blockquote>
<p>终止属性形成了容错的思想，该属性是一个活性属性，而另外三个是安全属性。如果不关心容错，仅仅满足前三个属性就OK，因为你可以将其中一个节点硬编码为leader，让该节点做出所有的决定，但是节点一旦失效，系统无法就无法做出决定了。比如2PC就能够满足，但是2PC的问题是，协调者失效，存疑的参与者无法决定是提交还是终止，故2PC不满足终止属性的要求</p>
<p>绝大多数共识算法实际上并不直接使用1️⃣2️⃣3️⃣4️⃣形式化模型，而是使用全序广播代为实现</p>
<h2 id="共识算法和全序广播">共识算法和全序广播</h2>
<p>最著名的容错共识算法是<strong>视图戳复制(VSR, viewstamped replication)</strong>，Paxos，Raft 以及 Zab。视图戳复制，Raft和Zab直接实现了全序广播，因为这样做比重复 <strong>一次一值(one value a time)</strong> 的共识更高效，因为全序广播的要求是：</p>
<blockquote>
<p>1️⃣ 可靠交付（reliable delivery）:  没有消息丢失：如果消息被传递到一个节点，它将被传递到所有节点</p>
<p>2️⃣ 全序交付（totally ordered delivery）:  消息以相同的顺序传递给每个节点</p>
</blockquote>
<p>可以发现，<strong>全序广播等于进行了重复多轮共识</strong></p>
<p>在单主复制中，将所有的写入操作都交给主库，并以相同的顺序将他们应用到从库，从而使副本保持在最新状态，这里其实是一种 <strong>“独裁类型”</strong> 的共识算法，领导者是运维指定的，一旦故障必须人为干预，它无法满足共识算法的终止属性</p>
<h2 id="时代编号和法定人数">时代编号和法定人数</h2>
<p>共识协议一般会定义1个<strong>时代编号(epoch number)</strong>，在Paxos中称为<strong>投票编号(ballot number)</strong>，视图戳复制中的<strong>视图编号(view number)</strong>，以及Raft中的<strong>任期号码(term number)</strong>，并确保在每个时代中，领导者都是唯一的。每次领导者被认为挂掉的时候，会产生全序且单调递增的新的时代编号，更高时代编号的领导才真的领导。节点在做出决定之前对提议进行投票的过程是一种同步复制，这是共识的局限性</p>
<h2 id="总结：">总结：</h2>
<p>很多问题都可以归结为共识问题，并且彼此等价(从这个意义上来讲，如果你有其中之一的解决方案，就可以轻易将它转换为其他问题的解决方案)。这些等价的问题包括：</p>
<p>1️⃣ <strong>线性一致性的CAS寄存器</strong>:  寄存器需要基于当前值是否等于操作给出的参数，原子地<strong>决定</strong>是否设置新值</p>
<p>2️⃣ <strong>原子事务提交</strong> :  数据库必须<strong>决定</strong>是否提交或中止分布式事务</p>
<p>3️⃣  <strong>全序广播</strong>:  消息系统必须<strong>决定</strong>传递消息的顺序</p>
<p>4️⃣ <strong>锁和租约</strong>:  当几个客户端争抢锁或租约时，由锁来<strong>决定</strong>哪个客户端成功获得锁</p>
<p>5️⃣ <strong>成员/协调服务</strong>: 给定某种故障检测器(例如超时)，系统必须<strong>决定</strong>哪些节点活着，哪些节点因为会话超时需要被宣告死亡</p>
<p>6️⃣ <strong>唯一性约束</strong>: 当多个事务同时尝试使用相同的键创建冲突记录时，约束必须<strong>决定</strong>哪一个被允许，哪些因为违反约束而失败</p>
<p>如果你只有一个节点，或者你愿意将决策权分配给单个节点，所有这些事都很简单。这就是在单领导者数据库中发生的事情：所有决策权归属于领导者，这就是为什么这样的数据库能够提供线性一致的操作，唯一性约束，完全有序的复制日志等。但如果该领导者失效，或者如果网络中断导致领导者不可达，这样的系统就无法取得任何进展。应对这种情况可以有三种方法：</p>
<blockquote>
<p>1️⃣等待领导者恢复，接受系统将在这段时间阻塞的事实。许多XA/JTA事务协调者选择这个选项。这种方法并不能完全达成共识，因为它不能满足<strong>终止</strong>属性的要求：如果领导者续命失败，系统可能会永久阻塞</p>
<p>2️⃣ 人工故障切换，让人类选择一个新的领导者节点，并重新配置系统使之生效，许多关系型数据库都采用这种方方式。这是一种来自“天意”的共识 —— 由计算机系统之外的运维人员做出决定。故障切换的速度受到人类行动速度的限制，通常要比计算机慢得多</p>
<p>3️⃣ 使用算法自动选择一个新的领导者。这种方法需要一种共识算法，使用成熟的算法来正确处理恶劣的网络条件是明智之举</p>
</blockquote>
<h1>批处理</h1>
<h2 id="关于衍生数据">关于衍生数据</h2>
<p>第三部分的内容，主要讨论将多个不同数据系统(有着不同的数据模型，并针对不同的访问模式进行优化)集成为一个协调一致的应用架构时，会遇到的问题。从高层次看，存储和记录数据系统分为2大类：</p>
<p>🅰️ 记录系统(System of record) ：数据的权威版本(如果其他系统和<strong>记录系统</strong>之间存在任何差异，那么记录系统中的值是正确的)</p>
<p>🅱️ 衍生数据系统(Derived data systems) ：通常是另一个系统中的现有数据进行转换或处理的结果，如缓存、索引、物化视图等，推荐系统中，预测汇总数据通常衍生自用户日志</p>
<p>三种不同的数据处理系统：</p>
<p>1️⃣ 服务(在线系统)</p>
<p>2️⃣ 批处理系统(离线系统)</p>
<p>3️⃣ 流处理系统(准实时系统)</p>
<p>流处理和批处理最关键的区别是处理无界数据和有界数据</p>
<blockquote>
<p>MPP数据库(大规模并行处理(MPP， massively parallel processing)专注于在一组机器上并行执行分析SQL查询，而MapReduce和分布式文件系统的组合则更像是一个可以运行任意程序的通用操作系统，批处理框架看起来越来越像MPP数据库了</p>
</blockquote>
<h2 id="UNIX">UNIX</h2>
<p>基于Unix的awk，sed，grep，sort，uniq和xargs等工具的组合，可以轻松的帮助我们完成一些数据分析的工作，而且性能相当的好。而且，这些工具使用相同的接口，在Unix中，这种接口是一个file(准确的说是一个文件描述符)</p>
<blockquote>
<p>文件是一个统一的接口，如果我们的程序的输入和输出都是文件，那么所有的程序缝合起来，像接力一样完成复杂的工作；统一的接口还包括URL和HTTP(我们可以在网站和网站之间无缝跳转)。这和函数式编程的理念非常类似</p>
</blockquote>
<p>Unix工具很强大，但是其局限性就是只能在一台机器上运行，所以Hadoop这样的工具应运而生</p>
<h2 id="MapReduce">MapReduce</h2>
<p>Unix和MapReduce比对</p>
<table>
<thead>
<tr>
<th>MR</th>
<th>除了生成输出没有副作用</th>
<th>简单粗暴却有效</th>
<th>分布式</th>
<th>分布式文件系统上读写文件</th>
<th>使用无共享架构</th>
<th>通过工作流(workflow)将多个MR作业连接在一起，文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unix</td>
<td>除了生成输出没有副作用</td>
<td>简单粗暴却有效</td>
<td>单机</td>
<td>使用<code>stdin</code>和<code>stdout</code>作为输入输出</td>
<td>共享架构</td>
<td>管道符，内存缓存区<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup></td>
</tr>
</tbody>
</table>
<blockquote></blockquote>
<p>MapReduce是一个编程框架，可以使用它编写代码处理HDFS等分布式文件系统中的大型数据集，并且遵循<em>移动计算大于移动数据的原则</em>。MapReduce的数据处理过程如下：</p>
<p>1️⃣ 读取一组输入文件，并将其分解成记录(records)</p>
<p>2️⃣ 调用Mapper函数，从每条输入记录中提取一对键值；map的任务数由输入文件块的数量决定</p>
<p>3️⃣ 按键排序所有的键值对</p>
<p>4️⃣ 调用Reducer函数遍历排序后的键值对，相同的key，将会在reducer中相邻；reduce的任务数量是可配置的</p>
<p>其中第2️⃣4️⃣步是自定义数据处理代码的地方，第3️⃣步Mapper的输出始终在送往Reducer之前进行排序，无须编写。下图是个三个Mapper和三个Reducer的MR任务：</p>
<p align="center">
  <img src="/2023/09/21/ddia/42.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>Mapper中的数据去往Reducer的过程可以看做是Mapper将消息发送给Reducer，每当Mapper发出一个键值对，这个键的作用就好像是去往到目标地址(IP地址)</p>
<h2 id="Reducer端联接：">Reducer端联接：</h2>
<p>如下图，左侧是事件日志，右侧是用户数据库，任务需要将用户活动和用户档案相关联：</p>
<p align="center">
  <img src="/2023/09/21/ddia/43.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
整个连接的MapReduce过程如下:
<p align="center">
  <img src="/2023/09/21/ddia/44.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
MapReduce框架通过键对Mapper输出进行分区，然后对键值对进行排序，使得具有相同ID的所有活动事件和用户记录在Reducer输入中彼此相邻。 Map-Reduce作业可以进一步让这些记录排序，使Reducer总能先看到来自用户数据库的记录，紧接着是按时间戳顺序排序的活动事件(二次排序/secondary sort)
<p>然后Reducer可以执行实际的连接逻辑：每个用户ID都会被调用一次Reducer函数，且因为二次排序，第一个值应该是来自用户数据库的出生日期记录。 Reducer将出生日期存储在局部变量中，然后使用相同的用户ID遍历活动事件，输出已观看网址和观看者年龄的结果对。随后的Map-Reduce作业可以计算每个URL的查看者年龄分布，并按年龄段进行聚集</p>
<p>因为Mapper的输出是按键排序的，然后Reducer将来自连接两侧的有序记录列表合并在一起，所以这个算法被称为排序合并连接(sort-merge join)</p>
<p>MapReduce实现这分组操作的方法是设置Mapper，使得Mapper生成的键值对使用所需的分组键</p>
<blockquote>
<p>热键(hot pot)和倾斜连接(skewed join) ： 热键是指记录中某个键记录数显著高于其他的键，热键关联是会产生倾斜关联(1个Reducer会处理比其他Reducer更多的记录)；一般处理倾斜连接方式是分2次MR</p>
</blockquote>
<h2 id="Map端联接：">Map端联接<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup>：</h2>
<p>在Reducer端连接中，排序，复制至Reducer，以及合并Reducer输入，所有这些操作可能开销巨大，如果数据具备某些特性，或许可以使用一些性能更优的连接方式，如：</p>
<p>1️⃣广播散列连接：在小表足够小的情况下，将小表读取到内存散列表中，然后Mapper扫描大表在散列表中查找每个事件</p>
<p>2️⃣ 分区散列连接：本质是GRACE Hash Join，在Hive中叫做：Map 端桶连接</p>
<p>3️⃣ Map端合并连接：本质是 sort-merge-join</p>
<blockquote></blockquote>
<p>批处理的常见用途是：构建机器学习系统(分类器/推荐系统等)，建立搜索索引(google最初使用MR就是为其搜索索引建立索引)，批处理的输出哲学和Unix一致，除了产生输出不会产生任何副作用，即容错能力高</p>
<h2 id="Hadoop与分布式数据库比对">Hadoop与分布式数据库比对</h2>
<p>Hadoop很像Unix的分布式版本，其中HDFS是分布式文件系统，MapReduce是Unix进程的变种实现，我们一直讨论的并行连接算法在MPP数据库中已有实现，区别在于MPP数据库专注于在一组机器上并行执行分析SQL，而MapReduce和分布式文件系统的组合更像是可以运行任意通用程序的操作系统</p>
<table>
<thead>
<tr>
<th></th>
<th>存储多样性</th>
<th>处理模型</th>
<th>故障处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hadoop</td>
<td>字节序列</td>
<td>MapReduce模型，SQL模型等<br>处理模型多样性<sup class="footnote-ref"><a href="#fn21" id="fnref21">[21]</a></sup></td>
<td>针对故障频繁而设计<sup class="footnote-ref"><a href="#fn22" id="fnref22">[22]</a></sup></td>
</tr>
<tr>
<td>分布式数据库</td>
<td>要求特定的模型(关系/文档)</td>
<td>SQL模型<sup class="footnote-ref"><a href="#fn23" id="fnref23">[23]</a></sup></td>
<td>查询失效时，多数MPP会终止查询</td>
</tr>
</tbody>
</table>
<blockquote></blockquote>
<p>💔：使用原始的<code>MapReduce API</code>来实现复杂的处理工作实际上是非常困难，所以在MapReduce上有很多高级编程模型(Pig，Hive，Cascading，Crunch)被创造出来。🅰️方面，MapReduce非常稳健；🅱️方面，对于某些类型的处理而言，其他工具有时会快上几个数量级。流处理组件(storm、spark、flink)可以认为是解决"慢"这个问题而被发展出来的，物化中间状态也是一种加速方式</p>
<h2 id="物化中间状态">物化中间状态</h2>
<p>将数据发布到分布式文件系统中众所周知的位置能够带来<strong>松耦合</strong>，这样作业就不需要知道是谁在提供输入或谁在消费输出，一个作业的输出只能用作另一个作业的输入的情况下，分布式文件系统上的文件只是简单的<strong>中间状态(intermediate state)</strong>：一种将数据从一个作业传递到下一个作业的方式。将这个中间状态写入文件的过程称为<strong>物化(materialization)</strong>[<sup>22][</sup>23]</p>
<blockquote>
<p>link: <a href="https://en.wikipedia.org/wiki/Materialized_view">https://en.wikipedia.org/wiki/Materialized_view</a> + <a href="https://stackoverflow.com/questions/93539/what-is-the-difference-between-views-and-materialized-views-in-oracle">https://stackoverflow.com/questions/93539/what-is-the-difference-between-views-and-materialized-views-in-oracle</a> + <a href="https://en.wikipedia.org/wiki/Materialized_view">https://en.wikipedia.org/wiki/Materialized_view</a></p>
</blockquote>
<p>💔：Unix管道将一个命令的输出与另一个命令的输入连接起来。管道并没有完全物化中间状态，而是只使用一个小的内存缓冲区，将输出增量地**流(stream)**向输入，与Unix管道相比，MapReduce完全物化中间状态的方法的不足之处在于：</p>
<p>1️⃣MapReduce作业只有在前驱作业(生成其输入)中的所有任务都完成时才能启动，而由Unix管道连接的进程会同时启动，输出一旦生成就会被消费</p>
<p>2️⃣ Mapper通常是多余的，如果Reducer和Mapper的输出有着相同的分区与排序方式，那么Reducer就可以直接串在一起，而不用与Mapper相互交织</p>
<p>3️⃣ 将中间状态存储在分布式文件系统中意味着这些文件被复制到多个节点</p>
<h2 id="数据流引擎">数据流引擎</h2>
<p>为了解决MapReduce的这些问题，几种用于分布式批处理的新执行引擎(Spark、Tez、Flink)被开发出来，它们的设计方式有很多区别，但有一个共同点：把整个工作流作为单个作业来处理，而不是把它分解为独立的子作业。由于它们将工作流显式建模为数据从几个处理阶段穿过，所以这些系统被称为<strong>数据流引擎(dataflow engines)</strong>，像MapReduce一样，它们在一条线上通过反复调用用户定义的函数来一次处理一条记录，这些函数为<strong>算子(operators)</strong>，数据流引擎提供了几种不同的选项来将一个算子的输出连接到另一个算子的输入：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>一种选项是对记录按键重新分区并排序，就像在MapReduce的混洗阶段一样。这种功能可以用于实现排序合并连接和分组</p>
</li>
<li class="lvl-2">
<p>另一种可能是接受多个输入，并以相同的方式进行分区，但跳过排序。当记录的分区重要但顺序无关紧要时，这省去了分区散列连接的工作，因为构建散列表还是会把顺序随机打乱</p>
</li>
<li class="lvl-2">
<p>对于广播散列连接，可以将一个算子的输出，发送到连接算子的所有分区</p>
</li>
</ul>
<p>与MapReduce模型相比，它有几个优点：</p>
<p>1️⃣排序等昂贵的工作只需要在实际需要的地方执行，而不是默认地在每个Map和Reduce阶段之间出现</p>
<p>2️⃣没有不必要的Map任务，因为Mapper所做的工作通常可以合并到前面的Reduce算子中(因为Mapper不会更改数据集的分区)</p>
<p>3️⃣由于工作流中的所有连接和数据依赖都是显式声明的，因此调度程序能够总览全局，知道哪里需要哪些数据，因而能够利用局部性进行优化。例如，它可以尝试将消费某些数据的任务放在与生成这些数据的任务相同的机器上，从而数据可以通过共享内存缓冲区传输，而不必通过网络复制</p>
<p>4️⃣通常，算子间的中间状态足以保存在内存中或写入本地磁盘，这比写入HDFS需要更少的I/O(必须将其复制到多台机器，并将每个副本写入磁盘)。 MapReduce已经对Mapper的输出做了这种优化，但数据流引擎将这种思想推广至所有的中间状态</p>
<p>5️⃣ 算子可以在输入就绪后立即开始执行；后续阶段无需等待前驱阶段整个完成后再开始</p>
<p>6️⃣ 与MapReduce(为每个任务启动一个新的JVM)相比，现有Java虚拟机(JVM)进程可以重用来运行新算子，从而减少启动开销</p>
<p>你可以使用数据流引擎执行与MapReduce工作流同样的计算，而且由于此处所述的优化，通常执行速度要明显快得多。相同的处理逻辑，可以通过修改配置切换底层计算引擎，简单地从MapReduce切换到Tez或Spark<sup class="footnote-ref"><a href="#fn24" id="fnref24">[24]</a></sup></p>
<blockquote></blockquote>
<h2 id="总结-3">总结</h2>
<p>本章主要讲述了Unix的管道思想，MapReduce与其接口HDFS，最后是数据流引擎构建自己的管道式的数据传输机制。并且还讨论了分布式批处理框架要解决的2个主要问题：</p>
<p>🅰️ 分区：这一过程的目的是把所有的<strong>相关</strong>数据(例如带有相同键的所有记录)都放在同一个地方</p>
<p>🅱️容错：MapReduce经常写入磁盘，这使得从单个失败的任务恢复很轻松，无需重新启动整个作业，但在无故障的情况下减慢了执行速度。数据流引擎更多地将中间状态保存在内存中，更少地物化中间状态，这意味着如果节点发生故障，则需要重算更多的数据。确定性算子减少了需要重算的数据量</p>
<h1>流处理</h1>
<p>流处理和批处理最原始的区别在于，流处理处理无界数据，而批处理针对有界数据。在流处理中的上下文中，记录通常被叫做<strong>事件</strong>，一个事件由生产者(producer)/发布者(publisher)/发送者(sender)生成一次，然后可能由多个消费者(consumer)/订阅者(subscribers)/接收者(recipients)进行处理。流处理的目标是<strong>事件发生后，立刻得到处理</strong>。流处理中相关的事件通常被聚合为一个主题(topic)或流(stream)</p>
<p>本质上来说，文件或者是数据库可以连接生产者和消费者，但是这种方式下消费者需要不断降低轮询文件/数据库的间隔，才能降低事件处理的延迟，而轮询会增加数据库的额外开销，我们希望在有新的事件产生的时候，能够通知到消费者，数据库的触发器或许是一个可选项，但是触发器功能有限，为了解决这个问题，消息系统应运而生</p>
<blockquote>
<p>2个进程之间进行消息传递(通信)，可以通过接口调用，还可以使用消息服务</p>
</blockquote>
<h2 id="消息系统">消息系统</h2>
<p>消息系统一定要考虑2个问题：</p>
<p>🅰️生产者发送消息的速度比消费者能够处理的速度快该如何应对？有三种方式处理：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>1️⃣丢掉消息</p>
</li>
<li class="lvl-2">
<p>2️⃣将消息放入缓冲队列</p>
</li>
<li class="lvl-2">
<p>3️⃣ 背压机制(backpressure)/流量控制(flow control)：即为阻塞生产者，避免其发送更多的消息<sup class="footnote-ref"><a href="#fn25" id="fnref25">[25]</a></sup></p>
</li>
</ul>
<blockquote></blockquote>
<p>🅱️ 如果节点崩溃或短暂脱机，是否会有消息丢失？也即<strong>持久性</strong>要求</p>
<p>批处理的一个优良的特性是，它提供了强大的可靠性保证：失败的任务会自动重试，且失败任务的输出会自动丢弃。这意味着好像故障没有发生一样，我们尝试⚠️<em>在流处理中达到类似的保证</em>。有些消息系统是直连生产者和消费者，比如使用UDP连接的应用，这种方式的确latency很低，但此类应用有一个前提假设：消费者和生产者始终在线，流处理如果是用这种方式，消费者一旦脱机，可能会丢失期间的消息</p>
<p><strong>消息代理/消息队列</strong></p>
<p>本质上消息代理是<strong>针对处理消息流</strong>的数据库。消息代理解决了上文提及的2个问题：</p>
<p>🅰️ (消费者)消费能力不足时，暂存消息；不需要丢弃消息或者背压</p>
<p>🅱️ 持久性保证：落盘</p>
<table>
<thead>
<tr>
<th>消息代理</th>
<th>消息<em>成功</em>传递给消费者后，自动删除</th>
<th>基于主题的模式匹配</th>
<th>不支持任意查询，数据变化时，会通知消费者</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据库</td>
<td>数据库保留数据直到显示删除</td>
<td>数据库支持二级索引</td>
<td>查询时，往往是基于某个时间点的快照</td>
</tr>
</tbody>
</table>
<p>如上描述的，消息队列和常规的数据的差别，其中行1是关于消息代理的传统观点，被封装在JMS/AMQP<sup class="footnote-ref"><a href="#fn26" id="fnref26">[26]</a></sup>标准中，其实现有RabbitMQ，ActiveMQ等</p>
<blockquote>
<p>AMQP: Advanced Message Queuing Protocol 高级消息队列协议：面向消息中间件提供的开放的应用层协定</p>
</blockquote>
<p>消息代理中，如果有多个消费者读取同一个主题的消息时，使用2种主要的消息传递模式:</p>
<p>🅰️ 负载均衡(load balance) : 在消费者间共享消费主题</p>
<p>🅱️ 扇出(fan-out) ： 将每条消息传递给多个消费者</p>
<p>两种模式可以组合使用：两个独立的消费者组可以每组各订阅一个主题，每一组都共同收到所有消息，但在每一组内部，每条消息仅由单个节点处理</p>
<p align="center">
  <img src="/2023/09/21/ddia/38.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>消息代理使用确认(acknowledgment)<sup class="footnote-ref"><a href="#fn27" id="fnref27">[27]</a></sup>机制，来确保消息不会丢失，但一种可能的情况是：代理向消费者传递消息后消费者崩溃或处理了部分崩溃了，代理由于超出一段时间没有收到确认(也可能是确认在网络中丢失了)，便将消息传递给另外一个消费者，当消费者的消费模式是负载均衡时，下面的情况可能会发生：处理m3时消费者2崩溃，因此稍后重传至消费者1</p>
<p align="center">
  <img src="/2023/09/21/ddia/39.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<blockquote></blockquote>
<p>批处理的关键特性是：重试失败任务不会发生任何副作用，而AMQP/JMS风格的消息传递收到消息是具有破坏性的，因为确认可能导致消息从代理中被删除，因此再次运行同一个消费者可能会得到不同的结果。即便是注册新的消费者到消息系统，通常只能接收到消费者注册之后开始发送的消息，而文件系统/数据库系统新增的客户端能够读取到任意久远的数据</p>
<p><strong>基于日志的消息代理(log-based message brokers)</strong> 尝试实现 🅰️既有数据库的持久存储方式；🅱️又有消息传递的低延迟通知</p>
<h2 id="基于日志的消息代理">基于日志的消息代理</h2>
<p>在基于日志(append only mode)的消息代理中，生产者通过将消息追加到日志末尾来发送消息，而消费者通过依次读取日志来接收消息，若消费者读到日志末尾，则会等待新消息追加的通知(如Unix的 <code>tail -f</code>)。同时为了提升吞吐量，基于日志的消息代理可以对日志进行分区，每个分区内，代理为每个消息分配一个<em>单调递增</em>的序列号/偏移量(offset)。并且<em>分区内消息完全有序(跨分区无顺序保证</em>)</p>
<p align="center">
  <img src="/2023/09/21/ddia/40.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>Apache Kafka、Amazon Kinesis Streams、Twitter的DistributedLog都是基于日志的消息代理。其中下面几点要注意：</p>
<p>1️⃣消费者组：支持多个消费者组成一个消费者主订阅一个主题，单个节点消费特定的分区，一般而言单线程处理单分区是更适合的选择，通过增加分区的方式提高并行度</p>
<p>2️⃣ 消费者偏移量：所有偏移量小于消费者的当前偏移量的消息已经被处理(类似单主复制中的日志序列号)<sup class="footnote-ref"><a href="#fn28" id="fnref28">[28]</a></sup></p>
<blockquote></blockquote>
<p>3️⃣重播旧消息：消费者的消费唯一的副作用就是导致偏移量的前进，但是消费者可以操纵偏移量(类似于批处理)</p>
<h2 id="流和数据库">流和数据库</h2>
<p>此间的讨论，我们发现基于日志的消息代理从数据库中获得灵感并将其应用于消息传递，其实也可以反过来，从消息传递和流中获得灵感，并将他们应用于数据库。在单主复制中，主库的写入事件构成写入流，将写入流应用到从库，最终得到数据的精确副本。在异构数据系统中，由于相同或相关的数据出现在了不同的地方，因此相互间需要保持同步：如果某个项目在数据库中被更新，它也应当在缓存，搜索索引和数据仓库(使用ETL)中被更新，我们在批处理将描述了如何使用批处理去更新其他衍生数据系统。使用的批处理的弊端是时延，如何保证衍生数据系统低延迟获取记录系统的变更数据？</p>
<p>这就涉及到<strong>变更数据捕获(change data capture, CDC)</strong>,这是一种观察写入数据库的所有数据变更，并将其提取并转换为可以复制到其他系统中的形式的过程。如下图：捕获数据库中的变更，并不断将相同的变更应用至搜索索引</p>
<p align="center">
  <img src="/2023/09/21/ddia/45.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
从本质上说，变更数据捕获使得一个数据库成为领导者(被捕获变化的数据库)，并将其他组件变为追随者。基于日志的消息代理非常适合从源数据库传输变更事件，因为它保留了消息的顺序。 LinkedIn的Databus，Facebook的Wormhole和Yahoo!的Sherpa大规模地应用这个思路。 Bottled Water使用解码WAL的API实现了PostgreSQL的CDC，Maxwell和Debezium通过解析binlog对MySQL做了类似的事情
<p>重放<strong>所有</strong>对数据库进行变更的日志，过于耗时，因此一般会保留数据库的快照，快照+快照时刻对应的偏移量可以加快重建数据库的完整状态。另外一个加速重建数据库完整状态的方式是日志压缩<sup class="footnote-ref"><a href="#fn29" id="fnref29">[29]</a></sup>，Apache Kafka支持这种日志压缩功能</p>
<blockquote></blockquote>
<h2 id="事件溯源-Event-Sourcing">事件溯源(Event Sourcing)</h2>
<p>事件溯源起源于领取驱动设计(domain-driven design,DDD)，和CDC类似，事件溯源将<strong>所有涉及对应用状态的变更存储为变更事件日志</strong>，其核心在于将用户的行为记录为不可变的事件，而不是在可变数据库中记录这些行为的影响。事件存储是仅追加的，原地删除和更新是不被鼓励的。事件日志和星型模式中的事实表有相似之处</p>
<p>使用事件溯源的应用需要拉取事件日志(表示写入系统的数据)，并将其转换为适合向用户显示的应用状态，和CDC一样，重放事件日志可以重新构建系统的当前状态。 事件溯源的哲学是仔细区分<strong>事件(event)<strong>和</strong>命令(command)</strong>，用户的请求刚到达时，它一开始是一个命令(在这个时间点上它仍然可能可能失败，比如违反了一些完整性条件)应用必须首先验证它是否可以执行该命令。如果验证成功并且命令被接受，则它变为一个持久化且不可变的事件。从数学角度来看，应用状态是事件流对时间求积分的结果 $state(now) = \int_{t=0}^{now}{stream(t) \ dt}$，变更流是应用状态对时间求微分的结果 $stream(t) = \frac{d\ state(t)}{dt}$</p>
<p>日志压缩是连接事件日志与数据库状态之间的桥梁：它只保留每条记录的最新版本，并丢弃被覆盖的版本。我们可以基于事件溯源中的记录的事件日志派生出多个视图，通过将数据写入的形式与读取形式相分离<sup class="footnote-ref"><a href="#fn30" id="fnref30">[30]</a></sup>，并允许几个不同的读取视图，这样极大的提高了灵活性</p>
<blockquote></blockquote>
<p>事件溯源和变更数据捕获的最大缺点是事件日志的消费者通常是异步的，所以可能出现的情况是：用户写入日志，然后从日志衍生视图中读取，结果发现他的写入还没有反映在读取视图中，一种解决方案是将事件附加到日志时同步执行读取视图的更新，如果是事件日志和读取视图保存在同一个存储系统中，需要使用事务，如果是异构数据库则涉及分布式事务</p>
<p>🎈至此，我们谈及到了流的来源1️⃣用户活动事件，2️⃣传感器，3️⃣写入数据库；流如何传输1️⃣直接通过消息传送 2️⃣消息代理 3️⃣ 事件日志。那么我们用流干什么？</p>
<h2 id="流处理">流处理</h2>
<p>流一般有以下三种用途</p>
<p>1️⃣ 你可以将事件中的数据写入数据库，缓存，搜索索引或类似的存储系统，然后能被其他客户端查询</p>
<p>2️⃣ 以某种方式将事件推送给用户，如发送报警邮件或推送通知，或将事件流式传输到可实时显示的仪表板上。这种情况下，人是流的最终消费者</p>
<p>3️⃣ 你可以处理一个或多个输入流，并产生一个或多个输出流。流可能会经过由几个这样的处理阶段组成的流水线，最后再输出1️⃣或2️⃣</p>
<p>我们将重点讨论3️⃣处理流产生其他衍生流，处理这样的流的代码片段，称之为算子(operator)或者作业(job)；流处理和批处理最大的区别是流处理处理无界数据，由于是无界导致排序没有意义，也就无法使用排序合并连接（sort merge join），容错机制也不能像批处理那样通过从头执行的方式</p>
<h2 id="流处理应用">流处理应用</h2>
<p>1️⃣ 复合事件处理(complex,event processing CEP)，CEP通常使用高层次的声明式查询语句如SQL，在流中搜索某些事件（就像正则表达式一样），当发现匹配时，引擎发出一个<strong>复合事件(complex event)</strong>（因此得名）。一般而言，数据库会持久存储数据，并将查询视为临时的，当查询进入时，数据库搜索与查询匹配的数据，然后在查询完成时丢掉查询。 CEP引擎反转了角色：查询是长期存储的，来自输入流的事件不断流过它们。CEP的实现包括 Esper、IBM InfoSphere Streams</p>
<p>2️⃣流分析，流分析关注大量事件上的聚合与统计指标，统计指标通常是在固定时间区（窗口[window]）间内进行计算的。许多开源分布式流处理框架的设计都是针对分析设计的：例如Apache Storm，Spark Streaming，Flink</p>
<p>3️⃣ 维护物化视图。数据库的变更流（CDC或是事件日志）可以用于维护衍生数据系统，使其与源数据库保持最新，基于衍生查询（写入和查询相分离）。也是流的一个应用，但是要求任意时间段内的所有事件，和流分析场景有很大的不同。类似Spark Streaming 不支持</p>
<h3 id="关于事件时间和处理时间">关于事件时间和处理时间</h3>
<p>🅰️ 处理时间：事件到达处理节点的时钟。使用处理时间定义窗口，会因为处理速率的变动引入人为因素，如下图：</p>
<p align="center">
  <img src="/2023/09/21/ddia/46.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<p>🅱️ 事件时间：事件发生的时间。延迟先发生的事件先到达处理节点，无法确定是否已经收到了特定窗口的所有事件，如何处理这种在窗口宣告完成之后到达的滞留（straggler）事件？</p>
<h3 id="窗口">窗口</h3>
<p>1️⃣ 滚动窗口(Tumbling Window)：窗口有固定的长度，而且每个事件都只属于一个窗口</p>
<p>2️⃣跳动窗口(Hopping Window) ：窗口有固定的长度，如1分钟跳跃步长的5分钟窗口</p>
<p>3️⃣滑动窗口(Sliding Window)：滑动窗口包含了彼此间距在特定时长内的所有事件，通过维护一个按时间排序的事件缓冲区，并不断从窗口中移除过期的旧事件，可以实现滑动窗口</p>
<p>4️⃣会话窗口(Session window) 将同一用户出现时间相近的所有事件分组在一起，而当用户一段时间没有活动时（例如，如果30分钟内没有事件）窗口结束</p>
<h2 id="流式连接">流式连接</h2>
<p>涉及<strong>流-流</strong>连接，<strong>流-表</strong>连接，与<strong>表-表</strong>连接</p>
<p>1️⃣ 流流连接，实际是窗口的连接，Window join 作用在两个流中有<em>相同 key</em> 且处于<em>相同窗口</em>的元素上。比如Flink将流流连接细分为滚动Window Join，滑动Window Join，会话Window Join。<a href="https://nightlies.apache.org/flink/flink-docs-master/zh/docs/dev/datastream/operators/joining/">Flink的双流Join</a>。比如下图是Spark Streaming中一个广告流和一个点击流的连接</p>
<p align="center">
  <img src="/2023/09/21/ddia/55.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<span class="github-emoji" style="display:inline;vertical-align:middle"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>流表连接，实际是流扩展。如下图的点击流和用户档案的连接，首先将数据库副本加载到流处理器中，然后流处理器需要一次处理一个活动事件。 流表连接实际上非常类似于流流连接；最大的区别在于对于表的变更日志流，连接使用了一个可以回溯到“时间起点”的窗口
<p align="center">
  <img src="/2023/09/21/ddia/43.jpg" width="85%" alt="Your image description">
    <br>
  <span style="color:gray"> todo </span>
</p>
<span class="github-emoji" style="display:inline;vertical-align:middle"><span>3⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 表表连接。在推特时间线的例子中，用户查看自身主页时间线时，迭代用户所关注人群的推文并合并它们需要一个时间线缓存，在流处理器中实现这种缓存维护，需要推文事件流(发送与删除)和关注关系事件流(关注与取消关注)，即该流处理的过程是维护了一个连接了两个表(推文与关注)的物化视图，如下时间线实际上是这个查询结果的缓存，每当基础表发生变化时都会更新
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> follows.follower_id <span class="keyword">as</span> timeline_id, </span><br><span class="line">    <span class="built_in">array_agg</span>(tweets.<span class="operator">*</span> <span class="keyword">order</span> <span class="keyword">by</span> tweets.timestamp <span class="keyword">desc</span>)</span><br><span class="line"><span class="keyword">from</span> tweets</span><br><span class="line"><span class="keyword">join</span> follows <span class="keyword">on</span>  tweets.sender_id <span class="operator">=</span> follows.followee_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> follows.follower_id</span><br></pre></td></tr></tbody></table></figure>
<h2 id="连接的时间依赖性">连接的时间依赖性</h2>
<p>流流、流表、表表连接有很多共同点，<strong>他们都需流处理器维护连接一侧的一些状态(广告流和点击流，用户档案，关注列表)，然后当连接另外一侧的消息到达时查询该状态</strong>。这里会有一个问题，如在流表连接的例子中，如果用户更新了档案，哪些活动事件与旧档案连接(在档案更新前)？，哪些又与新档案连接(在档案更新后)？即连接存在<em>时序依赖</em>，比如处理发票和税率问题时，当连接销售额与税率表时，你可能期望的是使用销售时的税率参与连接，如果你正在重新处理历史数据，销售时的税率可能和现在的税率有所不同</p>
<p>即如果跨流事件的顺序是未定的，则连接会变成不确定性的，那么在同样输入上重跑可能会得到不同的结果。这个问题在数仓中叫<em>缓慢变化的维度(slowly changing dimension,SCD)<sup class="footnote-ref"><a href="#fn31" id="fnref31">[31]</a></sup></em>，通常通过对特定版本的记录使用唯一的标识符来解决：例如，每当税率改变时都会获得一个新的标识符，而发票在销售时会带有税率的标识符。这种变化使连接变为确定性的，但也会导致日志压缩无法进行：表中所有的记录版本都需要保留</p>
<blockquote></blockquote>
<h2 id="流处理如何处理容错">流处理如何处理容错</h2>
<p>在批处理中，容错的方式就是重跑，而且其输出的效果就像只处理了一次一样，这个原则叫做<strong>恰好/精确一次语义(exactly-once semantics)</strong>，流处理为了实现恰好一次语义，有以下2种方式</p>
<p>🅰️ 微批，即将流分解成小块，并像微型批处理一样处理每个块，微批次(通常为1S)也隐式提供了一个与批次大小相等的滚动窗口(<em>按处理时间而不是事件时间戳分窗</em>)，代表应用为Spark Streaming</p>
<p>🅱️存档点， Apache Flink会定期生成状态的滚动存档点并将其写入持久存储。如果流算子崩溃，它可以从最近的存档点重启，并丢弃从最近检查点到崩溃之间的所有输出</p>
<p>在流处理框架的范围内，微批次与存档点方法提供了与批处理一样的<strong>恰好一次语义</strong>。但是，只要输出离开流处理器(例如，写入数据库，向外部消息代理发送消息，或发送电子邮件)，框架就无法抛弃失败批次的输出了。在这种情况下，重启失败任务会导致外部副作用发生两次，只有微批次或存档点不足以阻止这一问题，我们需要确保事件处理的所有输出和副作用<strong>当且仅当</strong>处理成功时才会生效。分布式事务是一种解决方案，另外一种方式是<strong>幂等性</strong>(idempotence)</p>
<p>幂等操作是多次重复执行与单次执行效果相同的操作，例如，将键值存储中的某个键设置为某个特定值是幂等的（再次写入该值，只是用同样的值替代），而递增一个计数器不是幂等的(再次执行递增意味着该值递增两次)。在使用来自Kafka的消息时，每条消息都有一个持久的，单调递增的偏移量。将值写入外部数据库时可以将这个偏移量带上，这样你就可以判断一条更新是不是已经执行过了，因而避免重复执行</p>
<p>&lt;完&gt;</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>意味着即使发生故障，系统也能正常工作 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>意味着即使在负载增加的情况下也有保持性能的策略 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>有许多方面，但实质上是关于工程师和运维团队的生活质量的 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>SSTable : Sort String Table ，排序字符串表，对每个段文件中的键进行排序 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>卡桑德拉，Apache Cassandra是一套开源分布式NoSQL数据库系统。它最初由Facebook开发，用于改善电子邮件系统的搜索性能的简单格式数据，集Google BigTable的数据模型与Amazon Dynamo的完全分布式架构于一身 <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>和ES一样是一个企业级的搜索索引 <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>Hologres存储引擎： <a href="https://developer.aliyun.com/article/779284?spm=a2c4g.11186623.0.0.11cf49fc9XL2Nw&amp;groupCode=hologres">https://developer.aliyun.com/article/779284?spm=a2c4g.11186623.0.0.11cf49fc9XL2Nw&amp;groupCode=hologres</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>固定大小的块或者页面：如果读者注意到过SQL引擎的执行计划的话，一般会有一个类似seq_page_cost（postgresql叫这个）的参数描述的就是每次Planner抓取一个数据页的成本（cost）， the planner’s estimate of the cost of a disk page fetch that is part of a series of sequential fetches <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>数据湖：是指使用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%80%B2%E4%BD%8D%E5%A4%A7%E5%9E%8B%E7%89%A9%E4%BB%B6">大型二进制对象</a>或文件这样的自然格式储存数据的系统[<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%B9%96#cite_note-1">1]</a>  ，数据湖可以包括<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93">关系数据库</a>的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">结构化数据</a>(行与列)、半结构化的数据(<a href="https://zh.wikipedia.org/wiki/%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94%E5%80%BC">CSV</a>，日志，<a href="https://zh.wikipedia.org/wiki/XML">XML</a>, <a href="https://zh.wikipedia.org/wiki/JSON">JSON</a>)，非结构化数据 (电子邮件、文件、PDF)和 二进制数据(图像、<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E9%9F%B3%E8%A8%8A">音频</a>、视频) <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>分区有很多中叫法，比如Solr Cloud中被称为分片(shard),在HBase中称之为区域(Region)，Bigtable/Kudu中则是表块(tablet，Cassandra和Riak中是虚节点(vnode), Couchbase中叫做虚桶(vBucket)，但是分区(partition)是约定俗成的叫法 <a href="#fnref10" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>该分区方式依赖于散列函数，一个 $32$ 位散列函数,无论何时给定一个新的字符串输入，它将返回一个 $0$ 到 $2^{32} -1$ 之间的"随机"数 <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>我们搜索的关键词决定了次级索引的分区方式，因此称之为关键词索引，关键词(term)一词来源于全文搜索索引(一种特殊的次级索引)。 <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>即一致性哈希解决的问题，一致性哈希的主要应用就是降低路由成本 <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>关于硬件故障：硬件故障率是很高的，磁盘在进行大量的读写之后失效的概率是很高的，IDC数据中心对物理环境的要求是很苛刻的，为了降低温度空调不够用，甚至把数据中心搬到山洞里，比如阿里在贵州云南的IDC，地板使用静电地板，每个机房入口的挡鼠板比膝盖还高，供电都是双路供电等。 <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>行锁满足两阶段锁协议，两阶段锁协议是说：锁需要的时候才加上的，在事务结束的时候才释放；同时行锁也是2PL（2阶段锁定），在当前事务写入时必须持有排它锁，直到事务提交才释放排它锁。 <strong>两阶段锁协议和2pl说的是一个事情</strong> <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制； <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>更新数据是先读后写的，读只能读当前<strong>已提交</strong>的最新值，这就是当前读 <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>网络分区区别于分区，分区是一种中将数据集划分为多块，以此来提升并发读写能力； 而网络分区是指节点<em>彼此断开</em>但是仍然活跃。 <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>多个MR任务连接的方式是将后一个MR任务的输入配置为前一个MR任务的输出；而Unix命令管道是直接将一个进程的输出作为另外一个进程的输入，仅用一个很小的内存缓冲区 <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>关于上述三种连接方式请参阅：<a href="https://mp.weixin.qq.com/s/lulNpgxillQ0s5fb_rgvdw">https://mp.weixin.qq.com/s/lulNpgxillQ0s5fb_rgvdw</a> <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn21" class="footnote-item"><p>并非所有数据类型的处理都可以合理的用SQL表达(推进系统、特征工程等)，所以编写代码是必须的，而MR能使得工程师可以轻松的在大型数据集上执行自己的代码，甚至还可以基于MapReduce+HDFS 建立SQL查询执行引擎，比如Hive就是这么做的；除了SQL和MapReduce之外，由于Hadoop平台的开放性，还可以构建更多的模型。由于不需要将数据导入到专门的系统进行不同类型的处理，采用新的处理模型也更容易。如MPP风格的分析型数据库impala，随机访问风格的OLTP数据库HBase(LSM) <a href="#fnref21" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn22" class="footnote-item"><p>落盘一方面是容错，一方面是假设数据集太大不能适应内存。并且支持支持资源的过度使用 <a href="#fnref22" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn23" class="footnote-item"><p>MPP 是单体的紧密集成的软件，负责磁盘上的存储布局，查询计划，调度和执行，这些组件针对数据库的特定需求做了优化，因此可以对特定查询有很好的性能，但只支持SQL模型 <a href="#fnref23" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn24" class="footnote-item"><p>Tez是一个相当薄的库，它依赖于YARN shuffle服务来实现节点间数据的实际复制，而Spark和Flink则是包含了独立网络通信层，调度器，及用户向API的大型框架 <a href="#fnref24" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn25" class="footnote-item"><p>比如能够恰好连接1个生产者和一个消费者Unix管道和TCP连接，他们在应对这个问题的时候使用背压机制，它们有一个固定大小的缓冲区，一旦填满发送者就会被阻塞，直到接受者从缓冲区取出数据 <a href="#fnref25" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn26" class="footnote-item"><p>JMS: Java Message Service，是关于Java消息中间的一组接口标准，所有消息中间件(MOM)需要实现这组接口，可类比JDBC <a href="#fnref26" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn27" class="footnote-item"><p>确认机制：消费者必须显示的告知代理处理完毕的时间，以便代理将消息从队列中移除 <a href="#fnref27" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn28" class="footnote-item"><p>❓消费者节点失效，则失效消费者的分区将指派给其他节点，并从最后记录的偏移量开始消费消息。如果消费者已经处理了后续的消息，但还没有记录它们的偏移量，那么重启后这些消息将被处理两次，这个问题如何解决呢? <a href="#fnref28" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn29" class="footnote-item"><p>日志压缩：类似在hash索引中讨论的日志压缩，存储引擎定期查找具有相同键的记录，丢弃到重复的内容并且只保留每个键的最新值。比如在CDC系统被配置为，每个变更都包含一个主键，且每个键的更新都替换了该键以前的值，那么只需要保留对键的最新写入就足够了。无论何时需要重建衍生数据系统(如搜索索引)，你可以从压缩日志主题0偏移量处启动新的消费者，然后依次扫描日志中的所有消息 <a href="#fnref29" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn30" class="footnote-item"><p>写入和读取形式相分离，也叫命令查询责任分离(command query responsibility segregation, CQRS） <a href="#fnref30" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn31" class="footnote-item"><p>SCD，处理SCD问题有很多种方式，从SCD0到SCD6，其中最流行的是：SCD1和SCD2；wiki：<a href="https://en.wikipedia.org/wiki/Slowly_changing_dimension%EF%BC%9BYouTube">https://en.wikipedia.org/wiki/Slowly_changing_dimension；YouTube</a> tutorial：<a href="https://www.youtube.com/watch?v=XqdZF0DJpUs">https://www.youtube.com/watch?v=XqdZF0DJpUs</a> <a href="#fnref31" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 45 讲</title>
    <url>/2023/09/30/mysql/</url>
    <content><![CDATA[<p>MySQL实战45讲</p>
<p>🅰️ 本文内容来源于极客时间专栏：<a href="https://time.geekbang.org/column/intro/100020801">《MySQL 实战45讲》</a></p>
<p>🅱️ 本文脚注的作用是对前一段描述内容的解释说明，并且放在<strong>当前</strong>章节的最后，而不是文末。更好的阅读体验推荐typora</p>
<span id="more"></span>
<h1>1-基础架构：一条SQL是如何执行的</h1>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select * from T where ID=10; </span><br></pre></td></tr></tbody></table></figure>
<h2 id="1-1-MySQL-基础架构">1.1-MySQL 基础架构</h2>
<p><strong>如下图所示</strong>：</p>
<p align="center">
  <img src="/2023/09/30/mysql/01.jpg" width="70%" alt="Your image description">
</p>
<p>对比下hive的架构是：解析器-编译器-优化器-执行器</p>
<h3 id="A-连接器">A-连接器</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>客户端连接连接器使用的协议是 <strong>TCP 协议</strong></p>
</li>
<li class="lvl-2">
<p>连接完成后，如果没有后续动作，这个连接就会处于<strong>sleep</strong>状态 ,也就是空闲状态（另外一个状态是 Query）</p>
</li>
<li class="lvl-2">
<p>客户端如果 <strong>wait_timeout</strong>（默认是8h）时间内没的动静，连接就会断开</p>
</li>
</ul>
<h4 id="MySQL-长短连接：">MySQL 长短连接：</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>长连接：连接成功后，一直持有这个连接，向 Server 发起请求</p>
</li>
<li class="lvl-2">
<p>短连接：执行完几次查询之后就断开连接，下次查询的时候在重新建立一个</p>
</li>
</ul>
<p>💁‍♂️ 由于连接的过程是比较复杂的，开发中需要尽量减少连接动作，也就是使用长连接</p>
<p>MySQL 在执行的过程中，临时使用的内存是管理在连接对象里面的，这些资源在连接断开的时候才释放，所以有时MySQL的内存涨的很快，而内存占用过大可能会导致被 <strong>Kill</strong>掉 ，表现为MySQL异常重启。如何避免：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>定期断开长连接</p>
</li>
<li class="lvl-2">
<p>MySQL5.7  之后的版本，在执行一个比较大的操作后，执行<code>mysql_reset_connection</code>来初始化连接(该操作不需要重连和鉴权，就恢复到刚创建完的状态)</p>
</li>
</ul>
<h3 id="B-执行器">B-执行器</h3>
<p>执行器是Server和存储引擎交互的部分，Server会调用存储引擎的接口，如对于</p>
<p><code>select * from T where ID=10;</code> ID 字段没有索引</p>
<p>1️⃣ 调用 InnoDB引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是，则将这行存在结果集中</p>
<p>2️⃣ 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行(取满足条件的第一行和满足条件的下一行这个逻辑在存储引擎中已经实现)</p>
<p>3️⃣ 执行器将上述遍历过程中所有满足条件的行，组成结果集返回给客户端</p>
<h1>2-日志系统：一条SQL更新是如何执行的</h1>
<p>MySQL中有2个重要的日志：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>redo log 重做日志 <strong>引擎层日志</strong>(InnoDB引擎特有)</p>
</li>
<li class="lvl-2">
<p>bin log 归档日志 <strong>server 层日志</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>redo log</th>
<th>bin log</th>
</tr>
</thead>
<tbody>
<tr>
<td>引擎模块，InnoDB引擎特有</td>
<td>server模块，所有引擎都可用</td>
</tr>
<tr>
<td>循环写</td>
<td>追加写</td>
</tr>
<tr>
<td>物理日志（在某个页面做了什么修改）</td>
<td>逻辑日志（语句的更改逻辑，如给<code>id=2</code>这一行的c字段加1）</td>
</tr>
</tbody>
</table>
<h2 id="2-1-redolog">2.1-redolog</h2>
<p>对于一个更新操作来说，如果每次更新都需要立刻写磁盘，则MySQL的存储引擎需要找到被更新的记录，然后更新。这个先定位再更新的机制必然有一定的成本（查找成本+IO成本<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>）。MySQL尝试使用下面的思路来提升 <strong>更新效率</strong></p>
<blockquote>
<p>WAL : Write - Ahead Logging ： 先写日志，后写磁盘</p>
</blockquote>
<p><strong>当涉及更新一条记录的时候，InnoDB引擎会将记录写到 redo log 里，并且更新内存</strong>。InnoDB引擎会在适当（系统比较空）的时候，将操作记录刷写到磁盘。在细节上：MySQL了会设置固定大小的 redo log，比如配置一组4个文件，每个文件1GB</p>
<p align="center">
  <img src="/2023/09/30/mysql/02.jpg" width="70%" alt="Your image description">
</p>
<p>有了redo log， InnoDB可以实现 crash-safe（保证在数据库发生异常重启之后，之前提交的记录不会丢失）。redo log的写入 被拆分为2个步骤 ： prepare + commit 也就是<strong>两阶段提交</strong>：</p>
<p align="center">
  <img src="/2023/09/30/mysql/03.jpg" width="60%" alt="Your image description">
</p>   
<p><strong>两阶段提交实现了 bin log 和 redo  log 的逻辑一致</strong></p>
<p>对于 <code> update T set c=c+1 where ID=2 ;</code> id 是主键  , 更新的细节如下：</p>
<p>1️⃣ 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 <code>ID=2</code> 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回</p>
<p>2️⃣ 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据</p>
<p>3️⃣ 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务</p>
<p>4️⃣ 执行器生成这个操作的 binlog，并把 binlog 写入磁盘</p>
<p>5️⃣ 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（<code>commit</code>）状态，更新完成</p>
<p>可以通过反证法的方式来证明，无论是先写redolog再写binlog，还是先写binlog再写redolog都会导致崩溃恢复后的数据不一致。而两阶段提交可以保证数据一致性</p>
<h2 id="2-2-bin-log">2.2-bin log</h2>
<p>bin log 是MySQL server层维护的一种二进制日志，记录所有的DML和DDL。作用有：</p>
<p>1️⃣ 复制： MySQL Master端开启binlog，slave 可以获得数据备份，同样可以实现数据同步（如数据采集）</p>
<p>2️⃣ 数据恢复：根据binlog来回放历史数据</p>
<p>binlog 包含两类文件</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>二进制日志索引文件(.index)：记录所有的二进制文件</p>
</li>
<li class="lvl-2">
<p>二进制日志文件(.00000*)：记录所有 DDL 和 DML 语句事件</p>
</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看binlog的状态：查看当前二进制日志文件的状态信息，显示正在写入的二进制文件，及当前position</span></span><br><span class="line"><span class="keyword">show</span> master status;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看二进制索引文件和二进制日志文件存储位置</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">'%log_bin%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看binlog文件列表</span></span><br><span class="line"><span class="keyword">show</span> <span class="type">binary</span> logs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解析binlog 日志文件</span></span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span>  <span class="string">'mysql-bin.000238'</span>; </span><br></pre></td></tr></tbody></table></figure>
<p><code>show master  status</code> 命令结果如下：<img src="/2023/09/30/mysql/09/30/mysql/04.jpg" class=""></p>
<blockquote>
<p>Executed_Gtid_Set : 数据发生变化，当前值就会发生变化</p>
</blockquote>
<h4 id="binlog-日志格式">binlog 日志格式</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>Statement 模式：基于 SQL 语句的复制(statement-based replication-SBR)，日志量小，会产生非确定性（比如使用不确定的函数<code>now()</code>）</p>
</li>
<li class="lvl-2">
<p>Row 模式：基于行的复制(row-based replication-RBR)，日志量大，可以保证一致性，<strong>记录了记录修改前后的样子</strong></p>
</li>
<li class="lvl-2">
<p>Mixed 模式：混合模式复制(mixed-based replication-MBR)，根据SQL语句的类型自动选择Statement或Row格式</p>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/33504555">参考1</a></p>
<p><a href="https://www.cnblogs.com/rickiyang/p/13841811.html">参考2</a></p>
<h1>3-事务隔离： 为什么你改了，我还看不见</h1>
<p>在 MySQL 中，事务支持是在引擎层实现的</p>
<h2 id="3-1-隔离性和隔离级别">3.1-隔离性和隔离级别</h2>
<p>SQL 标准的事务隔离级别包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>读未提交（read uncommitted）</p>
</li>
<li class="lvl-2">
<p>读提交（read committed）</p>
</li>
<li class="lvl-2">
<p>可重复读（repeatable read）(MySQL 默认的隔离级别)</p>
</li>
<li class="lvl-2">
<p>串行化（serializable ）</p>
</li>
</ul>
<p>结合下图，说说上面前3种隔离级别下，v1,v2,v3 的值</p>
<p align="center">
  <img src="/2023/09/30/mysql/06.jpg" width="50%" alt="Your image description">
</p>
<p>1️⃣ 读未提交：<code>V1=2,v2=2,v3=2</code></p>
<p>2️⃣ 读已提交：<code>V1=1,v2=2,v3=2</code></p>
<p>3️⃣ 可重复读：<code>V1=1,v2=1,v3=2</code></p>
<p>4️⃣ 可串行化：事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看 <code>V1=1,v2=1,v3=2</code></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看 MySQL当前的隔离级别设置值：</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">'tx_isolation'</span> </span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">'transaction_isolation'</span> <span class="comment">-- mysql5.7以上version </span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-2-事务隔离的实现">3.2-事务隔离的实现</h2>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准</p>
<p>1️⃣ “读未提交”隔离级别下直接返回记录上的最新值，没有视图概念</p>
<p>2️⃣ 在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的</p>
<p>3️⃣ 在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图</p>
<p>4️⃣ “串行化”隔离级别下直接用加锁的方式来避免并行访问</p>
<p>拿<strong>可重复读</strong>来说：假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录</p>
<p align="center">
  <img src="/2023/09/30/mysql/07.jpg" width="80%" alt="Your image description">
</p>
<p>当前值是4，不同时刻启动的事务会有不同的 read-view（事务视图），对于是三个视图记录的值分别不同：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>read-view A               1</p>
</li>
<li class="lvl-2">
<p>read-view B                 2</p>
</li>
<li class="lvl-2">
<p>read-view C                 4</p>
</li>
</ul>
<blockquote>
<p><strong>MVCC（ Multi-Version Concurrency Control） : 同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制</strong>。其主要的思想是在读取数据时创建数据的一份快照，并对该快照进行读取，而不是直接在原始数据上进行操作。这样做可以实现非阻塞的读操作，从而提高并发性能</p>
</blockquote>
<p>对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到</p>
<p>💁‍♂️  <strong>建议尽量不要使用长事务</strong>：</p>
<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这会大量占用存储空间</p>
<h2 id="3-3-事务启动方式">3.3-事务启动方式</h2>
<p>事务启动的方式如下：</p>
<p>1️⃣ : 显示启动事务语句，<code>begin / start transaction</code> 开启事务，<code>commit / rollback</code> 结束事务（提交/回滚）</p>
<p>2️⃣ : <code>set autocommit = 0</code> ,将线程的自动提交off ，意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接， <strong>这会导致长事务</strong>。</p>
<p>💁‍♂️ <strong>建议：set autocommit = 1（开启自动提交）</strong>，通过显式语句的方式来启动事务。<code>commit work and chain</code>，则是提交事务并自动启动下一个事务，这种方式可以省去了再次执行 begin 语句的开销</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 你可以在 information_schema 库的 innodb_trx 这个表中查询长事务</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span></span><br></pre></td></tr></tbody></table></figure>
<h1>4-深入浅出 索引 (上)</h1>
<h2 id="4-1-索引的常见模型">4.1-索引的常见模型</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>哈希表 ： 只是适合等值查询的场景，对范围查询不友好，严重依赖内存（size 瓶颈）</p>
</li>
<li class="lvl-2">
<p>有序数组： 等值查询、范围查询都很快，对数据更新（插入/删除后数据）不友好</p>
</li>
<li class="lvl-2">
<p>N叉树：在读写上有性能有点，适配磁盘的访问模式</p>
</li>
<li class="lvl-2">
<p>跳表 ：  可以说是有序的带层次的(在数据的基础上一层层加索引)链表</p>
</li>
</ul>
<p>单纯从存储上来说，LSM（log structure merge）树(日志结构合并树) 这种新的存储引擎也具备一定的优势，关于LSM这种结构可以参考《design data intensive application》 这本书的第三章节，从 追加日志，到SSTable ,到 LSM的过程</p>
<h2 id="4-2-InnoDB的索引模型">4.2-InnoDB的索引模型</h2>
<p>InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。举个例子来说：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- table schema</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T</span><br><span class="line">(</span><br><span class="line">    id   <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    k    <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    index (k)</span><br><span class="line">) engine <span class="operator">=</span> InnoDB;</span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T (id,k)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">100</span>, <span class="number">1</span>),</span><br><span class="line">       (<span class="number">200</span>, <span class="number">2</span>),</span><br><span class="line">       (<span class="number">300</span>, <span class="number">3</span>),</span><br><span class="line">       (<span class="number">500</span>, <span class="number">5</span>),</span><br><span class="line">       (<span class="number">600</span>, <span class="number">6</span>)</span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>
<p>对于上述的索引和数据，形成2颗索引树：</p>
<p align="center">
  <img src="/2023/09/30/mysql/08.jpg" width="80%" alt="Your image description">
</p>
<p>基于主键索引的查询和基于普通索引的查询的区别：</p>
<p>🅰️ <code>select * from T where ID=500</code>，即主键查询方式，则只需要搜索 ID 这棵 B+ 树</p>
<p>🅱️ <code>select * from T where k=5</code>，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong></p>
<p>InnoDB引擎中，主键索引默认就是聚簇索引（clustered index）</p>
<h2 id="4-3-索引维护">4.3-索引维护</h2>
<p>这里我们讨论2种情况</p>
<p>1️⃣ 插入新行 <code>id = 700</code> ，只是需要在R5的后面插入新记录</p>
<p>2️⃣ 插入新行 <code>id = 400</code> ，这种情况下又分成2种情况：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>R3~R5所在的数据页没有满，需要移动R4,R5的数据，给<code>id=400</code>空出位置</p>
</li>
<li class="lvl-2">
<p>R3~R5所在的数据页满了，会发生页分裂[^10]</p>
<blockquote>
<p>页分裂会导致性能下降，同时空间利用率下降，需要申请新的数据页,将R4，R5移动到新的分页，同时如果相邻的2个页由于数据删除，数据页会进行合并</p>
</blockquote>
</li>
</ul>
<p>建表时维护自增主键的优势：</p>
<p>1️⃣ 不会发生页分裂</p>
<p>2️⃣ 自增主键一般占用的空间比较小，二级索引存储主键时，占用存储也比较小</p>
<p>💁‍♂️ 无论是删除主键索引还是创建主键索引，都会导致表重建，而重建普通索引可以达到节省空间的目的，如果你有重建主键索引的需求：<code>alter table T engine=InnoDB</code> 会触发MySQL重建表，并进行碎片处理，达到节省空间的目的</p>
<h1>5-深入浅出 索引 (下)</h1>
<p>对于上面的表插入如下数据：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(id,k,name)</span><br><span class="line"><span class="keyword">values</span> (<span class="number">100</span>, <span class="number">1</span>, <span class="string">'aa'</span>),</span><br><span class="line">       (<span class="number">200</span>, <span class="number">2</span>, <span class="string">'bb'</span>),</span><br><span class="line">       (<span class="number">300</span>, <span class="number">3</span>, <span class="string">'cc'</span>),</span><br><span class="line">       (<span class="number">500</span>, <span class="number">5</span>, <span class="string">'ee'</span>),</span><br><span class="line">       (<span class="number">600</span>, <span class="number">6</span>, <span class="string">'ff'</span>),</span><br><span class="line">       (<span class="number">700</span>, <span class="number">7</span>, <span class="string">'gg'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> k <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>问执行上述的查询，需要执行几次树的搜索操作，会扫描多少行？SQL 的执行流程如下：</p>
<p>1️⃣ 在 k 索引树上找到 k=3 的记录，取得 ID = 300；</p>
<p>2️⃣再到 ID 索引树查到 ID=300 对应的 R3；</p>
<p>3️⃣ 在 k 索引树取下一个值 k=5，取得 ID=500；</p>
<p>4️⃣ 再回到 ID 索引树查到 ID=500 对应的 R4；</p>
<p>5️⃣在 k 索引树取下一个值 k=6，不满足条件，循环结束。</p>
<p>上面的查询过程读了K索引的3条记录，（步骤1|3|5）回表了2次（步骤2|4）。回表的过程会影响数据响应时间，所以查询应该尽可能的避免回表，<strong>索引覆盖</strong>会解决这个问题</p>
<p>回表：从普通索引树搜索回到主键索引锁搜索的过程，就叫做回表</p>
<h2 id="5-1-索引覆盖">5.1-索引覆盖</h2>
<p><code>select ID from T where k between 3 and 5</code>  查询，只需要查询索引K就可以得到查询结果，不需要回表，这就是索引覆盖。其中</p>
<p>🅰️ 对引擎来说：在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项）</p>
<p>🅱️ MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2</p>
<h2 id="5-2-最左前缀原则">5.2-最左前缀原则</h2>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tuser` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  `id_card` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  `ismale` tinyint(<span class="number">1</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  <span class="keyword">primary</span> key (`id`),</span><br><span class="line">  key `id_card` (`id_card`),</span><br><span class="line">  key `name_age` (`name`,`age`)</span><br><span class="line">) engine<span class="operator">=</span>innodb</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</strong></p>
</blockquote>
<p>🅰️ <code>where name like '张%' </code></p>
<p>🅱️ <code>where name  = '张三'</code></p>
<p>以上两种查询都可以用到 name_age 这个索引</p>
<h2 id="5-3-索引下推">5.3-索引下推</h2>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">select * from tuser where name like '张%' and age=10 and ismale=1;</span><br></pre></td></tr></tbody></table></figure>
<p>对于上面的查询查询过程如下：</p>
<p>1️⃣ 使用普通索引(name_age)树,找到第一个满足条件的记录ID3</p>
<p>2️⃣  按照版本分</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>MySQL 5.6前 ： 只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值</p>
</li>
<li class="lvl-2">
<p>MySQL 5.6后 ：可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p>
</li>
</ul>
<p>下图是二者的区别： 左表回表4次，右表回表2次</p>
<p align="center">
  <img src="/2023/09/30/mysql/09.jpg" width="90%" alt="Your image description">
</p>
<h1>6-全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h1>
<p>数据库锁设计的初衷是为了处理并发（多个线程访问同一个资源）问题，按照锁的范围分：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>全局锁</p>
</li>
<li class="lvl-2">
<p>表锁</p>
</li>
<li class="lvl-2">
<p>行锁</p>
</li>
</ul>
<h2 id="6-1-全局锁">6.1-全局锁</h2>
<p>MySQL通过FTWRL（Flush tables with read lock）,来加全局锁，加上全局锁之后，所有的数据更新语句和DML语句都会被阻塞。全局锁的典型使用场景是：<strong>做全库的逻辑备份</strong>。通过FTWRL的方式来添加全局锁，可以有效的突破的存储引擎带来的限制（MyISAM是不支持事务的，如果是InnoDB引擎，在RR的情况下，可以实现逻辑备份并且备份的时是支持更新的）</p>
<p><a href="https://time.geekbang.org/column/article/69862">关于使用FTWRL 还是使用 set global readonly=true</a></p>
<h2 id="6-2-表级锁">6.2-表级锁</h2>
<p>MySQL 的表级锁有2种</p>
<p>🅰️ 表锁</p>
<p>🅱️ DML锁 （Metadata Lock）</p>
<h3 id="6-2-1-表锁">6.2.1-表锁</h3>
<p>（假设是线程A）锁表的语法<code>lock table t1 read,t2 write</code> ,使用 <code>unlock talbe </code> 释放锁，对于该锁表语句：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>除了A之外的线程 对 t1 可读，对 t2 不可读写</p>
</li>
<li class="lvl-2">
<p>线程A 在执行<code>unlock tables</code>之前，只能执行读 t1, 读写 t2, 不能在访问其他表（写t1都不行，更别他其他的表了）</p>
</li>
</ul>
<h3 id="6-2-2-DML锁">6.2.2-DML锁</h3>
<p>🅰️ 对一个表做增删改查的操作的时候（会申请读锁），加DML 读锁，<strong>读锁之间不互斥</strong></p>
<p>🅱️ 对表做DML 变更的时候，加DML写锁，<strong>读写锁、写写锁之间互斥</strong></p>
<p>如下例子中，给表T增加字段，表T变的完全 不可读写</p>
<p align="center">
  <img src="/2023/09/30/mysql/10.jpg" width="80%" alt="Your image description">
</p>
<p>处理上述问题，我们首先要尽量避免长事务（session A位置 及时 commit），下面的语句在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃，<strong>阻塞会引发后面的阻塞</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name nowait <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name wait n <span class="keyword">add</span> <span class="keyword">column</span> ... </span><br></pre></td></tr></tbody></table></figure>
<h1>7-行锁功过：怎么减少行锁对性能的影响</h1>
<p>MySQL 的行锁是在引擎层面实现的，InnoDB支持行锁，MyISAM不支持行锁</p>
<h2 id="7-1-两阶段锁">7.1-两阶段锁</h2>
<p>两阶段锁协议（Two-Phase Locking Protocol），目的是为了保证事务的隔离性，避免数据的不一致性，在两阶段锁协议中，事务的执行过程被分为两个阶段：获取锁阶段（Growing Phase）和释放锁阶段（Shrinking Phase）</p>
<p>🅰️ 获取锁阶段：在这个阶段中，事务可以获取需要的锁，但不能释放任何锁</p>
<p>🅱️ 释放锁阶段：在这个阶段中，事务可以释放锁，但不能再获取新的锁（事务结束的时候释放锁）</p>
<p>右图事务B需等A释放锁才能获得<code>id=1</code>的锁</p>
 <p align="center">
  <img src="/2023/09/30/mysql/11.jpg" width="80%" alt="Your image description">
</p>
<p>在InnoDB事务中，<strong>行锁满足两阶段锁协议</strong>。这个协议对我们的帮助就是： <strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong> 比如在一个简易的影票交易系统中，如顾客A要在影院B 购买电影票，步骤如下：</p>
<p>1️⃣ 从顾客A账户余额中扣除电影票价 update</p>
<p>2️⃣ 给影院B的账户余额增加这张电影票价 update（同时可能有另外一个顾客C在影院B购票，此处可能是最容易造成锁冲突的地方）</p>
<p>3️⃣ 记录一条交易日志 insert</p>
<p>1,2,3应在一个事务中，根据两阶段锁协议，我们的事务应该将2 安排在最后。<strong>能够最大限度的减少事务之间的锁等待</strong></p>
<p>两阶段锁协议确保了在事务处理过程中，其他事务不能访问正在处理的数据。然而，它也可能会导致死锁，因为可能会出现两个或更多的事务，互相等待对方释放锁的情况。因此，实际的数据库系统需要额外的机制来检测和解决死锁</p>
<h2 id="7-2-死锁和死锁检测">7.2-死锁和死锁检测</h2>
<p align="center">
  <img src="/2023/09/30/mysql/12.jpg" width="80%" alt="Your image description">
</p>
<p>右图例子为，行锁中的死锁（当并发系统中不同线程出现，循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁）</p>
<p>出现死锁后，有2种策略：</p>
<p>1️⃣ 进入等待状态，直到超时（<code>MySQL innodb</code> 超时时间 由<code>innodb_lock_wait_timeout</code> 指定，默认50s）, 由于超时时间阈值设置过小可能会导致假阴性（误杀，将正常的等待判断为死锁），通常不会采用此方案</p>
<p>2️⃣ 发起死锁检测（<code>innodb_deadlock_detect</code> 设置为 <code>on</code>） , 发现死锁后，主动回滚其中一个事务，让其他事务继续执行。死锁检测有额外的负担（死锁检测是$O(N^2)$的时间复杂度）</p>
<p><strong>减少死锁的主要方向，就是控制访问相同资源的并发事务量</strong>，即降低$N$值</p>
<p>为什么死锁检测是$O(N^2)$的时间复杂度</p>
<blockquote>
<p>并发更新同一行的1000个线程，整体耗费的死锁检测操作为$1000\times1000=100$万。 为什么是个乘法——并发更新此行R1的某单个线程Tx，其所作的死锁检测工作为，Tx会有查看锁持有情况，耗费1000此操作——a.查看自身持有的行锁; b.遍历其他999个线程所持有的行锁，总共为$1 + 999=1000$次。 为什么会遍历其他999个线程，而不是仅看当前持有R1行锁的这个线程就行了？—— 因为行锁排队。某线程Tm排队获取R1行锁，排在Tx前。如果Tx当前持有行锁R2，过会Tm先于Tx获持R1后，会变成——Tm持有R1，等待R2 &amp;&amp; Tx持有R2，等待R1——Tm和Tx成环死锁。 因此并发更新同一行的有N个线程，对应的死锁检测耗费代价为$O(N^2)$ ! 死锁检测不可避免，为防止死锁检测代价过高引起性能问题——想办法减少同时对同一行的更新的并发并发度。即降低N值</p>
</blockquote>
<p>为了避免死锁检测带来的性能问题，我们可以也可以从业务逻辑的角度出发去解决这个问题，比如在购买影票的例子中，我们可以将一行改为，<strong>逻辑上的多行</strong>来减少锁冲突:</p>
<blockquote>
<p>可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗,如果账户余额可能会减少，比如退票逻辑，那么这时候就需要考虑当一部分行记录变成 0 的时候，代码要有特殊处理</p>
</blockquote>
<h1>8-事务到底是隔离的还是不隔离的？</h1>
<p>当前讨论的隔离级别：<mark>RR</mark>，id = 1 的原始值为1，如下图顺序进行查询：</p>
<p align="center">
  <img src="/2023/09/30/mysql/13.jpg" width="80%" alt="Your image description">
</p> 
<p>🅰️ A事务查到的  k = 1</p>
<p>🅱️ B事务查到的  k = 3</p>
<h2 id="8-1-MVCC是如何工作的？">8.1-MVCC是如何工作的？</h2>
<p><strong>transaction id</strong> ： 每个事务的唯一 id号（对象是某一个动作）。InnoDB中每个事务都有一个唯一的事务ID，记为 transaction id ,该 id 是事务开启的时候向InnoDB的事务系统申请的，该 id 按照申请顺序严格递增</p>
<p><strong>row  trx_id</strong>： 记录当前数据是被哪个transaction_id 改为当前值的 （对象是某一个数据）。每次事务更新数据时，会生成新的数据版本，row trx_id 记录当前的数据版本是被哪个事务改为当前值的</p>
<p>如下图：一个记录被多个事务连续更新后的状态：</p>
<p align="center">
  <img src="/2023/09/30/mysql/14.jpg" width="80%" alt="Your image description">
</p>
<p>关于undo log : 语句更新会产生 undo log (回滚日志)，作用是可以用于回滚，同时可以提供多版本并发控制下的读（MVCC）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<p><mark>从可读性上来说</mark>：一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p>
<blockquote>
<p>1️⃣ 版本未提交，不可见</p>
<p>2️⃣ 版本已提交，但是</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>在视图创建后提交的，不可见</p>
</li>
<li class="lvl-2">
<p>是在视图创建前提交的，可见</p>
</li>
</ul>
</blockquote>
<p>按照上面的规则来判断事务A，事务A的一致性视图是在事务A启动的时候生成的，此时：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>事务B的 (id=1,k=3) 还没有提交，不可见 ，属于情况 1</p>
</li>
<li class="lvl-2">
<p>事务C的(id=1,k=2) 已经提交，但是是在A的一致性视图创建<strong>后</strong>提交的，不可见，属于情况2.1</p>
</li>
<li class="lvl-2">
<p>(id=1,k=1) 已经提交，而且是在A的一致性视图创建<strong>前</strong>提交的，可见，属于情况2.2</p>
</li>
</ul>
<p>真实的物理实现，涉及到<strong>高水位</strong>（视图数组最大值+1）、<strong>低水位</strong>（视图数组的最小值）、<strong>视图数组</strong>（已经开始，但没有提交的事务id构成的数组）</p>
<p><a href="https://time.geekbang.org/column/article/70562">参考逻辑</a></p>
<h2 id="8-2-更新逻辑">8.2-更新逻辑</h2>
<p>我们再来分析一下事务B的 <code>update</code> 逻辑，按照上述的一致性读逻辑，事务B，是不能读到事务C的(1,2)的，因为事务C的是在事务B的一致性视图生成后提交的，按理说不可见；视图B在更新前去查询一次数据，返回的K=1，但是当更新的时候，必须拿到最新的值（1,2），否则事务C的更新就丢失了，因此更新数据涉及到一条规则：</p>
<blockquote>
<p><strong>当前读：更新数据是先读后写的，读只能读当前已提交的最新值，这个读 称之为当前读</strong></p>
</blockquote>
<p>因此，事务B查询结果是 (id=1,k=3)</p>
<p>此外，<strong>除了update 语句外，select 语句如果加锁，也是当前读</strong>，如我们将事务A的查询改为如下语句，也可以得到<code>k=3</code>的结果</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> lock <span class="keyword">in</span> share mode; <span class="comment">-- 读锁（S 锁，共享锁）</span></span><br><span class="line"><span class="keyword">select</span> k <span class="keyword">from</span> t <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 写锁（X 锁，排他锁)</span></span><br><span class="line"><span class="comment">-- update 的加锁语义和 select …for update 是一致的</span></span><br></pre></td></tr></tbody></table></figure>
<p>进一步假设事务C还没有提交，事务B就更新，事务B的更新语句会如何处理呢？</p>
<p align="center">
  <img src="/2023/09/30/mysql/15.jpg" width="60%" alt="Your image description">
  <n>
  <span style="color:gray"> info about the picture </span>
</n></p>
<p>由于<strong>2阶段锁协议</strong>（2PL）的存在，事务C’ 没有提交，即  (1,2) 这个版本的写锁 还没有释放，而事务B是当前读，必须得到当前版本(1,2)，而且必须加锁，因此阻塞了，必须等事务C’释放这个锁，才能继续它的当前读，如下图：</p>
<p align="center">
  <img src="/2023/09/30/mysql/16.jpg" width="50%" alt="Your image description">
</p>
<p>对于开头的3个事务，下面更改隔离级别为：<mark>RC</mark>：</p>
<p align="center">
  <img src="/2023/09/30/mysql/17.jpg" width="50%" alt="Your image description">
</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>事务A ： k = 2</p>
</li>
<li class="lvl-2">
<p>事务B ： k = 3</p>
</li>
</ul>
<h1>9-普通索引和唯一索引，应该怎么选？</h1>
<p>对于表T 查询，讨论在 k 上建立唯一索引还是普通索引</p>
<p align="center">
  <img src="/2023/09/30/mysql/08.jpg" width="70%" alt="Your image description">
</p>
<h2 id="9-1-查询过程">9.1-查询过程</h2>
<p>对于<code>select id from T where k=5</code>查询，该查询在索引树上的查询过程，先是从 B+ 树的 root 开始，按层搜索到叶子节点(右下角数据页，可以认为数据页内部通过二分法来定位记录)</p>
<p>1️⃣ : 对于普通索引来说，查找满足条件的第一个记录(5,500)后 ,需要查找下一个记录，直到碰到第一个不满足k=5条件的记录</p>
<p>2️⃣: 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就停止检索</p>
<p>但是两者的性能差异微乎其微的，因为<code>InnoDB</code>引擎是以数据页为单位来进行数据的读写的，当找到 k = 5 的记录的时候，它所在的数据页已经在内存中了，普通索引需要多做一次的 <strong>‘查找和判断下一条记录’</strong>  只是一次指针寻址和一次计算，如果k=5记录数据页的最后一个记录，这种情况的概率很低，计算平均性能的差异对现在的CPU来说可以忽略不计</p>
<blockquote>
<p>以数据页为单位进行数据读写：当需要读一条记录的时候，并不是将目标记录本身从磁盘中读出来，而是以页为单位，将目标记录所在的页整体读入内存，每个数据页大小默认为16KB</p>
</blockquote>
<h2 id="9-2-更新过程">9.2-更新过程</h2>
<p>当需要更新一个数据页时，MySQL会进行判断当前修改的数据页是否在内存中：</p>
<p>1️⃣ : 在内存中，直接对数据进行更新</p>
<p>2️⃣ : <code>InnoDB</code>将更新缓存在change buffer（既存储在内存中，也存储磁盘中： 可以缓存更新逻辑）中，在下次访问这个数据页的时候，将数据读入内存，执行change buffer 中和这个数据页有关的更新操作</p>
<p>访问数据页时会触发merge（将change buffer的操作应用到数据页，得到最终的结果的过程称之为 merge），系统后台线程会定期merge，在数据库正常关闭过程中，也会执行merge。无疑，使用change buffer  能够有效的提升语句的执行效率，而且由于数据页不需要读入内存占用<strong>buffer pool</strong><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>,还可以提高内存利用率</p>
<p>为什么唯一索引不能使用change buffer？是因为唯一索引需要检查当前的插入是否违反了唯一约束，这个检查需要将数据页读取到内存中，因此不能使用change buffer。只有普通索引可以使用change buffer，对于一张表需要插入新记录 (5,500)，<code>InnoDB</code>的处理流程如下：</p>
<p>1️⃣ 这个记录在内存中</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果是唯一索引：找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束</p>
</li>
<li class="lvl-2">
<p>如果是普通索引：找到3和5之间的位置，插入这个值，语句执行结束</p>
</li>
</ul>
<p>相比之下只是相差一个CPU时间</p>
<p>2️⃣ 这个记录不在内存中：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>唯一索引：将数据页读入到内存，判断到没有冲突，插入这个值，语句执行结束</p>
</li>
<li class="lvl-2">
<p>普通索引：将更新记录在 change buffer，语句执行就结束了</p>
</li>
</ul>
<p>相比下，普通索引省掉了磁盘读入内存涉及随机IO的访问<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>， 使用change buffer，对于写多读少的系统很合适，如账单日志类目这种页面写完之后被访问的概率很低的系统</p>
<p>💁‍♂️ 关于唯一索引和普通索引选取的建议：</p>
<blockquote>
<p><strong>2类索引在查询上对性能没有什么影响，优先尽量使用普通索引；如果所有的更新后，都立马伴随着这个记录的查询，应该关闭change buffer</strong></p>
</blockquote>
<h4 id="对比redo-log-WAL-和-Change-buffer">对比redo log WAL 和 Change buffer</h4>
<p>在性能上<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>：redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗</p>
<h1>10-MySQL为什么有时候会选错索引？</h1>
<p>双1设置可以=&gt; 数据安全 <a href="https://www.cnblogs.com/kevingrace/p/10441086.html">参考link</a></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables  <span class="keyword">like</span> <span class="string">'innodb_flush_log_at_trx_commit'</span>; </span><br><span class="line"><span class="comment">-- innodb_flush_log_at_trx_commit = 1 每次事务提交时MySQL都会把 redo log buffer的数据写入log file，并且flush(刷到磁盘)中去;</span></span><br><span class="line"><span class="keyword">show</span> variables  <span class="keyword">like</span> <span class="string">'sync_binlog'</span>  </span><br><span class="line"><span class="comment">-- sync_binlog = 1  sync_binlog =N (N&gt;0) ，MySQL 在每写 N次 二进制日志binary log时，会使用fdatasync()函数将它的写二进制日志binary log同步到磁盘中去。</span></span><br></pre></td></tr></tbody></table></figure>
<p>对于某个表t</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">  `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  <span class="keyword">primary</span> key (`id`),</span><br><span class="line">  key `a` (`a`),</span><br><span class="line">  key `b` (`b`)</span><br><span class="line">) engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></tbody></table></figure>
<p>在数据库中，影响执行效率的因素：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>扫描行数是影响执行代价的因素之一，扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少</p>
</li>
<li class="lvl-2">
<p>否使用了 临时表</p>
</li>
<li class="lvl-2">
<p>是否排序等因素</p>
</li>
<li class="lvl-2">
<p>扫描普通索引会考虑到回表的代价</p>
</li>
</ul>
<p>索引基数（索引上不同值的个数）越大，索引的区分度越大，通过 <code>show index from table_name</code> 查看索引基数。该命令得到的是一个采样估算值<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p>
<p>优化器存在选错索引的可能性。对于由于索引统计信息不准确导致的问题，你可以用 <code>analyze table</code> 来解决。而对于其他优化器误判的情况</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>你可以在应用端用 force index 来强行指定索引</p>
</li>
<li class="lvl-2">
<p>也可以通过修改语句来引导优化器</p>
</li>
<li class="lvl-2">
<p>还可以通过增加或者删除索引来绕过这个问题</p>
</li>
</ul>
<h1>11-怎么给字符串字段加索引</h1>
<h2 id="11-1-前缀索引">11.1-前缀索引</h2>
<p>在原字段建立索引和建立前缀索引：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index1(email); <span class="comment">-- 在email上建立索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> SUser <span class="keyword">add</span> index index2(email(<span class="number">6</span>)); <span class="comment">-- 在 email的前6个字符建立索引</span></span><br></pre></td></tr></tbody></table></figure>
<p align="center">
  <img src="/2023/09/30/mysql/18.jpg" width="80%" alt="Your image description">
</p>
<p>前缀索引的优势：占用空间更小；前缀索引的劣势：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>无法使用覆盖索引</p>
</li>
<li class="lvl-2">
<p>由于长度定义的不好(前缀索引要选择合适的长度)，导致索引的基数变小，最终导致回表扫描变多。如何选择前缀索引的长度：</p>
</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">4</span>)) <span class="keyword">as</span> L4</span><br><span class="line">     , <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">5</span>)) <span class="keyword">as</span> L5</span><br><span class="line">     , <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">6</span>)) <span class="keyword">as</span> L6</span><br><span class="line">     , <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email, <span class="number">7</span>)) <span class="keyword">as</span> L7</span><br><span class="line"><span class="keyword">from</span> SUser;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="11-2-倒序存储-hash-字段">11.2-倒序存储 &amp; hash 字段</h2>
<p>2种方式否不支持范围查询</p>
<h1>12-为什么我的MySQL会“抖”一下？</h1>
<p>一条 SQL 语句，正常执行的时候特别快，但是有时也不知道怎么回事，它就会变得特别慢，并且这样的场景很难复现，它不只随机，而且持续时间还很短。表现出来，就好像MySQL抖了一下</p>
<h2 id="12-1-SQL为什么变慢？">12.1-SQL为什么变慢？</h2>
<p><strong>脏页</strong> ： 当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页“</p>
<p><strong>干净页</strong>：内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</p>
<p><strong>flush</strong> : 将内存数据刷写到磁盘上使得，内存数据和磁盘的数据一致</p>
<p>什么情况下会触发数据库的 Flash？</p>
<p>1️⃣ redo log 写满，需要推进 checkpoint时</p>
<p>2️⃣ 内存不足，需要淘汰脏页时</p>
<p>3️⃣ MySQL空闲时，刷脏页</p>
<p>4️⃣ MySQL正常关闭的时候，刷写脏页</p>
<p>其中情况1出现的时候，MySQL会阻塞所有更新，从监控上看，更新数变为0 ；情况2出现的时候，MySQL使用buffer pool来管理内存，buffer pool 中的内存页存在三种状态：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>还没有使用的</p>
</li>
<li class="lvl-2">
<p>使用了而且是干净页</p>
</li>
<li class="lvl-2">
<p>使用了而且是脏页</p>
</li>
</ul>
<p>当读入的数据页没有在内存中时，必须从 buffer pool中申请新页，淘汰则会淘汰最久不使用的数据页，如果是干净页直接释放出来使用，如果是脏页，必须将脏页刷写到磁盘变成干净页才能使用，MySQL刷脏页是一个常态，但是一个查询要淘汰的脏页个数太多时，会导致查询时间加长。从而导致MySQL抖动了一下</p>
<h2 id="12-2-InnoDB刷脏页的控制策略">12.2-<code>InnoDB</code>刷脏页的控制策略</h2>
<p>InnoDB使用<code>innodb_io_capacity</code><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>，告知InnoDB所在的主机的IO能力，这样InnoDB才能最大发挥磁盘IOPS的能力。当前的这个参数是最大的写磁盘的能力，还需要$innodb_io_capacity \times R %$ <sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>InnoDB的刷盘速度实际参考2个因素：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>脏页比例</p>
</li>
<li class="lvl-2">
<p>redo log 写盘速度</p>
</li>
</ul>
<h1>13-为什么表数据删掉一半，表文件大小不变？</h1>
<p>MySQL在进行数据删除的时候，会将数据页标记为可复用，实际上并不会进行删除，会形成空洞；如果主键不是依次递增的，插入数据会导致页分裂，会导致页空洞，更新数据可以认为是先删除在插入，也会导致页分裂。如果把这些空洞去掉，就可以达到收缩表空间的目的。而重建表，就可以达到这样的目的</p>
<p>左图：MySQL5.5 | 右图： MySQL5.6</p>
<p align="center">
  <img src="/2023/09/30/mysql/19.jpg" width="100%" alt="Your image description">
</p>
<h1>14-count(*)这么慢，我该怎么办？</h1>
<p>普通索引树比主键索引树小很多<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>，对于count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上是一致的，MySQL优化器会找到最小的那棵树来遍历，<strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统涉及的通用法则之一</strong></p>
<p>InnoDB 表直接<code> count(*)</code> 会遍历全表，虽然结果准确，但会导致性能问题(全表扫描会导致所导致的性能问题)。可以考虑使用外部存储的方式来存储<code>count(*)</code>,比如redis。不能够保证计数和 MySQL 表里的数据精确一致的原因，是这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图</p>
<h2 id="14-1-count-的用法">14.1-count(?) 的用法</h2>
<p>至于分析性能差别的时候，你可以记住这么几个原则：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>server 层要什么就给什么；</p>
</li>
<li class="lvl-2">
<p>InnoDB 只给必要的值；</p>
</li>
<li class="lvl-2">
<p>现在的优化器只优化了 count(*) 的语义为“取行数”，其他“显而易见”的优化并没有做</p>
</li>
</ul>
<p>1️⃣ 对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加</p>
<p>2️⃣ 对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加</p>
<p>3️⃣ 对于 count(字段) 来说：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；</p>
</li>
<li class="lvl-2">
<p>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加</p>
</li>
</ul>
<p>4️⃣ <code>count(*)</code> 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加</p>
<p>按照效率排序的话，<code>count(字段)</code>&lt;<code>count(主键 id)</code>&lt;<code>count(1)</code>≈<code>count(*)</code>，所以我建议你，尽量使用 <code>count(*)</code></p>
<h1>15-答疑文章（一）：日志和索引相关问题</h1>
<p>redo log buffer 就是一块内存，用来先存 redo 日志的。可以认为WAL和redo log 是一个东西</p>
<h1>16-<code>order by </code>是怎么工作的?</h1>
<p>对于下面的查询，MySQL是如何执行的呢？</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city</span><br><span class="line">            ,name</span><br><span class="line">            ,age </span><br><span class="line"><span class="keyword">from</span> t </span><br><span class="line"><span class="keyword">where</span> city<span class="operator">=</span><span class="string">'杭州'</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">1000</span>  ; <span class="comment">-- id是主键， city上有索引</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="16-1-全字段排序">16.1-全字段排序</h2>
<p align="center">
  <img src="/2023/09/30/mysql/20.jpg" width="100%" alt="Your image description">
</p>
<p>1️⃣ 初始化 sort buffer<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>, 确定放入 <code>name,city,age</code> 3个字段</p>
<p>2️⃣ 根据 <code>city</code> 的索引树，找到第一个满足 <code>city = '杭州'</code> 的主键id</p>
<p>3️⃣ 回表取出整行，取<code>name,city , age</code> 3个字段的值，存入 sort buffer</p>
<p>4️⃣ 从索引city 取下一个记录的主键id</p>
<p>5️⃣ 重复3,4 直到不满足查询条件为止</p>
<p>6️⃣ 对 sort buffer 中的数据按照name 做 快排。 <code>sort_buffer_size</code>（当前参数的大小决定排序是基于内存的快排，还是开辟磁盘空间，使用归并排序）</p>
<p>7️⃣ 取前1000行返回给客户端</p>
<h2 id="16-2-row-id-排序">16.2-row_id 排序</h2>
<p align="center">
  <img src="/2023/09/30/mysql/21.jpg" width="100%" alt="Your image description">
</p>
<p>1️⃣ 初始化 sort_buffer<sup class="footnote-ref"><a href="#fn10" id="fnref10:1">[10:1]</a></sup>，确定放入两个字段，即 name 和 id</p>
<p>2️⃣ 从索引 city 找到第一个满足 <code>city='杭州’</code> 条件的主键 id，也就是图中的 ID_X（city索引数的图）</p>
<p>3️⃣ 到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中</p>
<p>4️⃣ 从索引 city 取下一个记录的主键 id</p>
<p>5️⃣ 重复步骤 3、4 直到不满足 city='杭州’条件为止，也就是图中的 ID_Y（city索引数的图）</p>
<p>6️⃣ 对 sort_buffer 中的数据按照字段 name 进行排序 , <code>max_length_for_sort_data</code>（设置该参数，对于太长的字段，可以实现只是取排序字段  和主键 排序，select的字段通过回表的方式获取）</p>
<p>7️⃣ 遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端</p>
<h2 id="16-3-联合索引">16.3-联合索引</h2>
<p>执行如下语句：<code>alter table t add index city_user(city, name);</code></p>
<p align="center">
  <img src="/2023/09/30/mysql/22.jpg" width="100%" alt="Your image description">
</p>
<p>1️⃣ 从索引 (city,name) 找到第一个满足 city='杭州’条件的主键 id</p>
<p>2️⃣ 到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回</p>
<p>3️⃣ 从索引 (city,name) 取下一个记录主键 id</p>
<p>4️⃣ 重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city='杭州’条件时循环结束</p>
<p>当然我们可以进一步在 <code>city name age</code> 3个字段上建立索引，然后当前的查询就会索引覆盖，更快</p>
<h1>17-如何正确的显示随机消息</h1>
<p>对于需求：从单词表中随机选出3个单词，<code>select word from words order by rand() limit 3;</code> 测试插入10W条记录，本章使用了</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>内存临时表 -&gt; 按照row id 的方式进行排序</p>
</li>
<li class="lvl-2">
<p>磁盘临时表 -&gt; 优先队列排序算法，生成一个大根堆，完成排序</p>
</li>
</ul>
<p>然后介绍了一种<em>随机1排序</em>的方法：</p>
<p>1️⃣ 取得这个表的主键 id 的最大值 M 和最小值 N</p>
<p>2️⃣ 用随机函数生成一个最大值到最小值之间的数 $X = (M-N)\times rand() + N$</p>
<p>3️⃣ 取不小于 X 的第一个 ID 的行</p>
<p>最后又介绍了一种<em>随机2排序</em>方法：</p>
<p>1️⃣ 取得整个表的行数，并记为 C</p>
<p>2️⃣ 取得 $Y = floor(C * rand())$。 floor 函数在这里的作用，就是取整数部分</p>
<p>3️⃣ 再用 limit Y,1 取得一行</p>
<h1>18-为什么我的这些SQL语句逻辑相同，性能确差异巨大？</h1>
<h2 id="18-1-条件字段函数操作">18.1-条件字段函数操作</h2>
<p>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。比如，你在 <code>t_modified</code> 、<code>id</code>上建立索引，却产生了下面的SQL写法：<code>where month(t_modified)  = 7</code> 或者 <code>where id - 1 = 100</code> 。</p>
<h2 id="18-2-隐式类型转换">18.2-隐式类型转换</h2>
<p>首先，<strong>在MySQL、PostgreSQL、 Hive 中，字符串类型和数字类型比较的时候，都是将字符串转为数字比较</strong>，验证方法如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'10'</span> <span class="operator">&gt;</span> <span class="number">9</span>;</span><br><span class="line"><span class="comment">-- 如果是字符类型转为数字类型，返回结果应该为1或者是true</span></span><br><span class="line"><span class="comment">-- 如果是数字类型转为字符类型，返回的结果应该是0或者是false</span></span><br></pre></td></tr></tbody></table></figure>
<p>所以对于表 tradelog（tradeid 类型为字符类型），执行如下查询将无法使用索引：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span> tradeid<span class="operator">=</span><span class="number">110717</span>; </span><br><span class="line"><span class="comment">-- 因为实际的SQL是：</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tradelog <span class="keyword">where</span>  <span class="built_in">CAST</span>(tradid <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">110717</span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="18-3-隐式字符编码转换">18.3-隐式字符编码转换</h2>
<p>表trade_detail 字符集使用utf8; tradelog 表使用 utf8mb4<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>字符集，2个表在做关联Join的时候</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> tradelog l <span class="comment">-- utf8mb4</span></span><br><span class="line">   , trade_detail d <span class="comment">-- utf8</span></span><br><span class="line"><span class="keyword">where</span> d.tradeid <span class="operator">=</span> l.tradeid <span class="comment">-- l表的tradeid 有索引</span></span><br><span class="line">  <span class="keyword">and</span> l.id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure>
<p align="center">
  <img src="/2023/09/30/mysql/23.jpg" width="100%" alt="Your image description">
</p>
<h1>19-为什么我只查一行的语句，也执行这么慢？</h1>
<p>如果MySQL数据库本身就有很大的压力，导致数据库的CPU利用率很高或者是 ioutil(IO 利用率) 很高，这种情况下所有的语句执行都可能变慢。除了这个原因之外，还有另外2种情况：</p>
<h2 id="19-1-查询长时间不返回">19.1-查询长时间不返回</h2>
<p>这种情况下，有2种原因导致，遇到这种情况，详细分析可以参考 <a href="https://time.geekbang.org/column/article/74687">链接</a></p>
<p>1️⃣  等 DML锁，通过 <code>sys.schema_table_lock_waits</code><sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup>表可以定位到哪个 process id 造成了阻塞</p>
<p>2️⃣  等flush， flush table 是很快的，出现 waiting for table flush 状态的情况可能是,有一个flush tables  命令被别的语句阻塞了，然后flush table 又阻塞了我们的select 语句。</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">flush tables t <span class="keyword">with</span> read lock;  <span class="comment">-- 只关闭表t</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;     <span class="comment">-- 关闭 MySQL里所有打开的表</span></span><br></pre></td></tr></tbody></table></figure>
<p align="center">
  <img src="/2023/09/30/mysql/24.jpg" width="100%" alt="Your image description">
</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">'%long_query_time%'</span>; <span class="comment">-- 查看慢查询阈值</span></span><br><span class="line"><span class="keyword">set</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 设置慢查询阈值</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> mysql.slow_log; <span class="comment">-- 记录慢查询可以记录到表中，也可以记录到文件中，如果记录到表中，可以按照当前的方式查询</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="19-2-查询慢">19.2-查询慢</h2>
<p>1️⃣ 全表扫描， 从SQL上来说，我们应该避免全表扫描</p>
<p>2️⃣ 时间消耗在unlog回滚上 ：</p>
<p>对于<code>select * from t where id = 1; -- 10w记录，id是主键，从查询返回来看返回结果很慢</code></p>
<p align="center">
  <img src="/2023/09/30/mysql/25.jpg" width="100%" alt="Your image description">
</p>
<p>当前读可以很快的读取到数据；而一致性读需要相当的响应时间</p>
<h1>20-幻读是什么，幻读有什么问题？</h1>
<h2 id="20-1-幻读是什么？">20.1-幻读是什么？</h2>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  <span class="keyword">primary</span> key (`id`),</span><br><span class="line">  key `c` (`c`)</span><br><span class="line">) engine<span class="operator">=</span>innodb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></tbody></table></figure>
<p align="center">
  <img src="/2023/09/30/mysql/26.jpg" width="80%" alt="Your image description">
    <br>
  <span style="color:gray"> info about the picture </span>
</p>
<p>幻读说明：当前读+新插入的 数据才会出现</p>
<p>1️⃣ 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，<strong>幻读在“当前读（读到所有已提交记录的最新值）”下才会出现</strong></p>
<p>2️⃣ 上面 session B 的修改结果，被 session A 之后的 select 语句用“当前读”看到，不能称为幻读。<strong>幻读仅专指“新插入的行”</strong></p>
<h2 id="20-2-幻读有什么问题？">20.2-幻读有什么问题？</h2>
<p>幻读会导致：</p>
<p>🅰️ 破坏语义。 如上例中 T1语义就是对所有<code>d=5</code>的行都加上锁，SessionB的 T2语句更新<code>id=0</code>后，还可以修改<code>id=0</code>的字段值，破坏了SessionA中 T1定义的对所有<code>d=5</code>的行加锁的逻辑</p>
<p>🅱️ 破坏数据一致性<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup></p>
<p align="center">
  <img src="/2023/09/30/mysql/45.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> info about the picture </span>
</p>
<p>如上的分析，都是建立在假设 <code>select * from t where d=5 for update</code> 这条语句只给 <code>d=5</code> 这一行，也就是 <code>id=5</code> 的这一行加锁”导致的，我们尝试把扫描过程中碰到的行，也都加上写锁，看看会发生什么？</p>
<p align="center">
  <img src="/2023/09/30/mysql/46.png" width="100%" alt="Your image description">
    <br>
  <span style="color:gray"> info about the picture </span>
</p>
<p>如上，即使把所有的记录都加上锁，还是阻止不了新插入的记录，在 T3 时刻，我们给所有行加锁的时候，<code>id=1</code> 这一行还不存在，不存在也就加不上锁</p>
<p>行锁只能锁住行，但是新插入记录的动作要更新的是记录之间的**“间隙” **， 为了解决幻读问题，MySQL引入了 <strong>间隙锁</strong>（Gap lock）</p>
<h2 id="20-3-间隙锁">20.3-间隙锁</h2>
<p align="center">
  <img src="/2023/09/30/mysql/27.png" width="90%" alt="Your image description">
    <br>
  <span style="color:gray"> info about the picture </span>
  </p>
<p><strong>跟行锁有冲突关系的是“另外一个行锁”</strong>。但是间隙锁不一样，<strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作</strong>。间隙锁之间都不存在冲突关系</p>
<p align="center">
  <img src="/2023/09/30/mysql/28.jpg" width="80%" alt="Your image description">
</p>
<p>如果这里 <code>begin ; select  * from where c = 5 lock in share mode;</code> 此时 session B是会被阻塞的</p>
<p>间隙锁和行锁合称 next-key lock，<strong>每个 next-key lock 是前开后闭区间</strong>。也就是说，我们的表 t 初始化以后，如果用 <code>select * from t for update</code> 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是<br>
$$<br>
(-\infty,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20,25],(25,+\infty)<br>
$$<br>
下图是一个间隙锁导致的死锁例子：</p>
<p align="center">
  <img src="/2023/09/30/mysql/29.jpg" width="80%" alt="Your image description">
</p>
<ol>
<li class="lvl-3">
<p>session A 执行 <code>select … for update</code> 语句，由于 <code>id=9</code> 这一行并不存在，因此会加上间隙锁 (5,10)</p>
</li>
<li class="lvl-3">
<p>session B 执行 <code>select … for update</code> 语句，会加上间隙锁 (5,10)，间隙锁之间不会冲突，该语句执行成功</p>
</li>
<li class="lvl-3">
<p>session B 试图插入一行 (9,9,9)，被 session A 的间隙锁挡住了，只好进入等待；session A 试图插入一行 (9,9,9)，被 session B 的间隙锁挡住了</p>
</li>
</ol>
<p>可以发现间隙锁的引入，可能会导致同样的语句锁住更大的范围，解决掉了幻读，但是影响了并发度的。<strong>只有在可重复读的隔离级别下，才会有间隙锁。读提交的隔离级别下不会有间隙锁</strong>。要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row，这也是现在不少公司使用的配置组合</p>
<h1>21-为什么我只改一行的语句，锁这么多？</h1>
<p>隔离级别：<mark>RR</mark>；间隙锁和 next-key lock（行锁和间隙锁统一称为 next-key lock） 的加锁规则：</p>
<p>1️⃣ 原则 1：加锁的基本单位是 next-key lock，next-key lock 是前开后闭区间</p>
<p>2️⃣ 原则 2：查找过程中访问到的对象才会加锁</p>
<p>3️⃣ 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁</p>
<p>4️⃣优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁</p>
<p>5️⃣一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止</p>
<p>具体案例<a href="https://time.geekbang.org/column/article/75659">移步</a></p>
<p>锁退化的问题，</p>
<h1>22-MySQL有哪些“饮鸩止渴”提高性能的方法？</h1>
<p>💡 下面这些优化的方式都是有损的</p>
<h2 id="22-1-短链接风暴">22.1-短链接风暴</h2>
<p>连接过程涉及TCP+鉴权等会占用CPU资源</p>
<p>1️⃣ 第一种方法：先处理掉那些占着连接但是不工作的线程。<code>kill connection + id </code>的命令<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>， 一个客户端处于 sleep 状态时，它的连接被服务端主动断开后，这个客户端并不会马上知道</p>
<p>2️⃣ 第二种方法：减少连接过程的消耗。重启数据库，并使用–skip-grant-tables 参数启动。风险很高</p>
<h2 id="22-2-慢查询性能问题">22.2-慢查询性能问题</h2>
<p>引发性能的情况有三种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>索引没有设计好； 可以Online DDL</p>
</li>
<li class="lvl-2">
<p>SQL 语句没写好；参见<a href="#18-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84%E8%BF%99%E4%BA%9BSQL%E8%AF%AD%E5%8F%A5%E9%80%BB%E8%BE%91%E7%9B%B8%E5%90%8C%EF%BC%8C%E6%80%A7%E8%83%BD%E7%A1%AE%E5%B7%AE%E5%BC%82%E5%B7%A8%E5%A4%A7%EF%BC%9F">章节 18</a> 为什么这些SQL语句逻辑相同，性能差异确巨大</p>
</li>
<li class="lvl-2">
<p>MySQL 选错了索引。应急方案 force index</p>
</li>
</ul>
<p>如何避免情况1和情况2？</p>
<p>1️⃣ 上线前，在测试环境，把慢查询日志（slow log）打开，并且把 long_query_time 设置成 0，确保每个语句都会被记录入慢查询日志</p>
<p>2️⃣ 在测试表里插入模拟线上的数据，做一遍回归测试</p>
<p>3️⃣ 观察慢查询日志里每类语句的输出，特别留意 Rows_examined 字段是否与预期一致</p>
<p>不要吝啬这段花在上线前的“额外”时间，因为这会帮你省下很多故障排除的时间</p>
<p><strong>查询重写</strong>：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> query_rewrite.rewrite_rules(<span class="keyword">pattern</span>, replacement, pattern_database) <span class="keyword">values</span> ("select * from t where id + 1 = ?", "select * from t where id = ? - 1", "db1");</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br></pre></td></tr></tbody></table></figure>
<h2 id="22-3-QPS-突增问题">22.3-QPS 突增问题</h2>
<p>有时由于业务突然出现高峰，或者应用程序 bug，导致某个语句的 QPS 突然暴涨，也可能导致 MySQL 压力过大，影响服务。<a href="https://time.geekbang.org/column/article/75746">详情移步</a></p>
<h1>23-MySQL是怎么保证数据不丢的？</h1>
<p>关于数据可靠性,也即持久性的</p>
<h2 id="23-1-binlog-写入机制">23.1-binlog 写入机制</h2>
<blockquote>
<p>只要redo log 和binlog 写入了磁盘，就能确保MySQL异常重启后，数据可以恢复</p>
</blockquote>
<p align="center">
  <img src="/2023/09/30/mysql/30.jpg" width="100%" alt="Your image description">
</p>
<p>1️⃣ 事务执行过程中，先把日志写入到binlog cache ，事务提交的时候，再把binlog cache写入到binlog 文件中，并清空binlog cache</p>
<p>2️⃣ 系统给 binlog cache 分配了一片内存，每个线程会按照参数<strong>binlog_cache_size</strong> 的大小获取自己享有的cache大小，如果不够用就暂存到磁盘</p>
<p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</p>
</li>
<li class="lvl-2">
<p>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</p>
</li>
<li class="lvl-2">
<p>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync<sup class="footnote-ref"><a href="#fn15" id="fnref15">[15]</a></sup></p>
</li>
</ul>
<p>将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，比较常见的是将其设置为 100~1000 中的某个数值</p>
<h2 id="23-2-redo-log-的写入机制">23.2-redo log 的写入机制</h2>
<p>redo log 3种存储状态</p>
<p align="center">
  <img src="/2023/09/30/mysql/31.jpg" width="100%" alt="Your image description">
</p>
<p>InnoDB 提供了 <code>innodb_flush_log_at_trx_commit</code> 参数来控制 redo log 的写入策略：</p>
<p>1️⃣ 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中</p>
<p>2️⃣ 设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘</p>
<p>3️⃣ 设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache</p>
<p>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘<sup class="footnote-ref"><a href="#fn16" id="fnref16">[16]</a></sup>。此外还有2种情况也会写盘：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>redo log buffer 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动写盘(只是write 不 fsync)</p>
</li>
<li class="lvl-2">
<p>并行事务提交时，顺带将这个事务的redo log buffer 持久化到磁盘</p>
</li>
</ul>
<p><strong>日志逻辑序列号<sup class="footnote-ref"><a href="#fn17" id="fnref17">[17]</a></sup></strong> : 是单调递增的，用来对应 redo log 的一个个写入点。每次写入长度为 length 的 redo log， LSN 的值就会加上 length</p>
<p><strong><a href="">组提交</a></strong></p>
<p>todo : 部分内容没有做总结</p>
<h1>24-MySQL是怎么保证主备一致的？</h1>
<p><strong>主备库的区别</strong>：备库和从库的概念是不同的，虽然二者都是只读的，但是从库对外提供服务，而备库只是为主库提供备份</p>
<h2 id="24-1-MySQL-主备的基本原理">24.1-MySQL 主备的基本原理</h2>
<p>左图为主备切换流程(M-S架构)，右图为节点 A 到 B 这条线的内部流程是什么样的</p>
<p align="center">
  <img src="/2023/09/30/mysql/32.jpg" width="100%" alt="Your image description">
</p>
<p>一个事务日志同步的完整过程是这样的：</p>
<p>1️⃣ 在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量</p>
<p>2️⃣ 在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接</p>
<p>3️⃣ 主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B</p>
<p>4️⃣ 备库 B 拿到 binlog 后，写到本地文件，称为<strong>中转日志</strong>（relay log）</p>
<p>5️⃣ sql_thread 读取中转日志，解析出日志里的命令，并执行</p>
<h2 id="24-2-binlog-的三种格式对比">24.2-binlog 的三种格式对比</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>statement</p>
</li>
<li class="lvl-2">
<p>row</p>
</li>
<li class="lvl-2">
<p>mixed</p>
</li>
</ul>
<p>row 格式使用 mysqlbinlog工具解析出来的结果：</p>
<p align="center">
  <img src="/2023/09/30/mysql/33.jpg" width="100%" alt="Your image description">
</p>
<p>越来越多的场景要求把 MySQL 的 binlog 格式设置成 row。其中一个直接看出来的好处：<strong>恢复数据</strong></p>
<h2 id="24-3-M-M架构">24.3-M-M架构</h2>
<p align="center">
  <img src="/2023/09/30/mysql/34.jpg" width="90%" alt="Your image description">
</p>
<h1>25-MySQL是怎么保证高可用的？</h1>
<h2 id="25-1-主备延迟">25.1-主备延迟</h2>
<p>和数据同步有关的时间点主要包括以下三个：</p>
<p>1️⃣ 主库 A 执行完成一个事务，写入 binlog，我们把这个时刻记为 T1</p>
<p>2️⃣ 之后传给备库 B，我们把备库 B 接收完这个 binlog 的时刻记为 T2</p>
<p>3️⃣ 备库 B 执行完成这个事务，我们把这个时刻记为 T3</p>
<p><strong>主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是 $T3-T1$</strong></p>
<h2 id="25-2-造成主备延迟的原因">25.2-造成主备延迟的原因</h2>
<p>1️⃣ 备库所在机器的性能要比主库所在的机器性能差</p>
<p>2️⃣ 备库的压力大</p>
<p>3️⃣ 大事务<sup class="footnote-ref"><a href="#fn18" id="fnref18">[18]</a></sup></p>
<p>4️⃣ 备库的并行复制能力</p>
<h2 id="25-3-可靠性优先策略">25.3-可靠性优先策略</h2>
<p>推荐使用该策略</p>
<h2 id="25-4-可用性优先策略">25.4-可用性优先策略</h2>
<p>介绍了异常切换的情况</p>
<h1>26-备库为什么会延迟好几个小时？</h1>
<p>主要介绍：备库并行复制能力。MySQL5.6之前备库的复制时单线程的。为什么要有多线程复制呢？这是因为单线程复制的能力全面低于多线程复制，对于更新压力较大的主库，备库是可能一直追不上主库的。从而导致备库上 seconds_behind_master 的值越来越大</p>
<p align="center">
  <img src="/2023/09/30/mysql/35.png" width="100%" alt="Your image description">
</p>
<p>coordinator 在分发的时候，需要满足以下这两个基本要求：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个 worker 中</p>
</li>
<li class="lvl-2">
<p>同一个事务不能被拆开，必须放到同一个 worker 中</p>
</li>
</ul>
<p>todo:待更</p>
<h1>27-主库出问题了，从库怎么办？</h1>
<p>大多数的互联网应用场景都是读多写少，在发展过程中很可能先会遇到读性能的问题。而在数据库层解决读性能问题，就要涉及到接下来两篇文章要讨论的架构，一主多从。（前3章是一主一备）</p>
<p>1️⃣ 基于位点的主备切换(需要注意的是这个位点并不准确)</p>
<p>2️⃣ GTID：GTID](全称是 Global Transaction Identifier，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识格式： <code>GTID=server_uuid:gno</code></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>server_uuid 是一个实例第一次启动时自动生成的，是一个全局唯一的值</p>
</li>
<li class="lvl-2">
<p>gno 是一个整数，初始值是 1，每次提交事务的时候分配给这个事务，并加 1<sup class="footnote-ref"><a href="#fn19" id="fnref19">[19]</a></sup></p>
</li>
</ul>
<h1>28-读写分离有哪些坑？</h1>
<p>自定义的<a href="%E5%9C%A8%E4%BB%8E%E5%BA%93%E4%B8%8A%E4%BC%9A%E8%AF%BB%E5%88%B0%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%B8%AA%E8%BF%87%E6%9C%9F%E7%8A%B6%E6%80%81%E2%80%9D%E7%9A%84%E7%8E%B0%E8%B1%A1%EF%BC%8C%E5%9C%A8%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E9%87%8C%EF%BC%8C%E6%88%91%E4%BB%AC%E6%9A%82%E4%B8%94%E7%A7%B0%E4%B9%8B%E4%B8%BA%E2%80%9C%E8%BF%87%E6%9C%9F%E8%AF%BB%E2%80%9D">过期读</a> 。 涉及到的处理过期读的方案如下：</p>
<p>1️⃣ 强制走主库方案；<a href="%E6%AF%94%E5%A6%82%EF%BC%8C%E5%9C%A8%E4%B8%80%E4%B8%AA%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E4%B8%8A%EF%BC%8C%E5%8D%96%E5%AE%B6%E5%8F%91%E5%B8%83%E5%95%86%E5%93%81%E4%BB%A5%E5%90%8E%EF%BC%8C%E9%A9%AC%E4%B8%8A%E8%A6%81%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%A1%B5%E9%9D%A2%EF%BC%8C%E7%9C%8B%E5%95%86%E5%93%81%E6%98%AF%E5%90%A6%E5%8F%91%E5%B8%83%E6%88%90%E5%8A%9F%E3%80%82%E9%82%A3%E4%B9%88%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E9%9C%80%E8%A6%81%E6%8B%BF%E5%88%B0%E6%9C%80%E6%96%B0%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%B0%B1%E5%BF%85%E9%A1%BB%E8%B5%B0%E4%B8%BB%E5%BA%93%E3%80%82%E4%B9%B0%E5%AE%B6%E6%9D%A5%E9%80%9B%E5%95%86%E9%93%BA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%B0%B1%E7%AE%97%E6%99%9A%E5%87%A0%E7%A7%92%E7%9C%8B%E5%88%B0%E6%9C%80%E6%96%B0%E5%8F%91%E5%B8%83%E7%9A%84%E5%95%86%E5%93%81%EF%BC%8C%E4%B9%9F%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97%E7%9A%84">对于必须要拿到最新结果的请求，强制将其发到主库上。对于可以读到旧数据的请求，才将其发到从库上</a></p>
<p>2️⃣ sleep 方案</p>
<p>3️⃣ 判断主备无延迟方案</p>
<p>4️⃣ 配合 semi-sync 方案</p>
<p>5️⃣ 等主库位点方案</p>
<p>6️⃣ 等 GTID 方案</p>
<h1>29-如何判断一个数据库是不是出问题了？</h1>
<p>主备切换有下面2种场景：</p>
<p>🅰️ 主动切换</p>
<p>🅱️ 被动切换；即由HA 系统确认主库出了问题，然后HA系统发起切换</p>
<h1>30-答疑文章（二）：用动态的观点看加锁</h1>
<h1>31-误删数据后除了跑路，还能怎么办？</h1>
<p>误删数据的事后处理办法，更重要是要做到事前预防误删数据，下面是2个建议：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>[sql_safe_updates 参数设置为 on。这样一来，如果我们忘记在 delete 或者 update 语句中写 where 条件，或者 where 条件里面没有包含索引字段的话，这条语句的执行就会报错](如果你确定这个删除操作没问题的话，可以在 delete 语句中加上 where 条件，比如 where1=1)</p>
</li>
<li class="lvl-2">
<p>代码上线前，必须经过 SQL 审计</p>
</li>
</ul>
<p>防止误删表，误删库的建议：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>第一条建议是，账号分离</p>
</li>
<li class="lvl-2">
<p>第二条建议是：制定操作规范。这样做的目的，是避免写错要删除的表名(比如：在删除数据表之前，必须先对表做改名操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。改表名的时候，要求给表名加固定的后缀比如加 _to_be_deleted ，然后删除表的动作必须通过管理系统执行。并且，管理系删除表的时候，只能删除固定后缀的表)</p>
</li>
</ul>
<h1>32-为什么还有kill不掉的语句？</h1>
<h1>33-我查这么多数据，会不会把数据库内存打爆？</h1>
<h2 id="全表扫描对-server层的影响">全表扫描对 server层的影响</h2>
<p>假如，现在有一个 对 200G的<code>InnoDB</code>表 db1.t 进行全表扫描，并将结果集保存在客户端的需求，你可能会有下面命令：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h$host <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="operator">-</span>p$pwd <span class="operator">-</span>e "select * from db1.t" <span class="operator">&gt;</span> $target_file</span><br></pre></td></tr></tbody></table></figure>
<p>那么server端 取数据和发数据的流程是下面这样的：</p>
<p>1️⃣ 获取一行，写到 net_buffer 中。这块内存的大小是由参数 net_buffer_length 定义的，默认是 16k</p>
<p>2️⃣ 重复获取行，直到 net_buffer 写满，调用网络接口发出去</p>
<p>3️⃣ 如果发送成功，就清空 net_buffer，然后继续取下一行，并写入 net_buffer</p>
<p>4️⃣ 如果发送函数返回 EAGAIN 或 WSAEWOULDBLOCK，就表示本地网络栈（socket send buffer）写满了，进入等待，直到网络栈重新可写，再继续发送</p>
<p>即：<strong>边读边发</strong>，整个流程如下：</p>
<p align="center">
  <img src="/2023/09/30/mysql/36.jpg" width="80%" alt="Your image description">
</p>
<p>执行 <code>show processlist </code> state 处于 Sending to client 状态的，就表示服务器端的网络线程写满了。<strong>对于正常的线上业务来说，如果一个查询的返回结果不会很多的话，建议使用 <code>mysql_store_result</code> 这个接口，直接把查询结果保存到本地内存</strong></p>
<h2 id="全表扫描对InnoDB的影响">全表扫描对<code>InnoDB</code>的影响</h2>
<p><strong>内存利用率</strong>： buffer pool (实际是 buffer pool 中的 change buffer) 可以起到加速更新的作用，同时也具备加速查询的作用，事务提交的时候，磁盘的数据页是旧的，如果马上有一个查询来读数据页，MySQL并不需要将redo log 应用到数据页，也是直接读内存页就可以了。Buffer pool 对查询的加速效果，依赖内存命中率。<code>show engine innodb status</code>  搜索hit 即可定位到。[如何设置buffer pool的大小？](其中 buffer pool 的大小，可通过 参数 <code>innodb_buffer_pool_size</code> 设置，一般设置为物理内存的 60%~80%。)</p>
<p><code>InnoDB</code> 内存管理使用的 [LRU](Least Recently Used) 这个缓存淘汰算法，并且是基于链表实现的缓存淘汰算法</p>
<p align="center">
  <img src="/2023/09/30/mysql/37.jpg" width="100%" alt="Your image description">
</p>
<p>改进后的 LRU 算法执行流程变成了下面这样。</p>
<p>1️⃣ 图 7 中状态 1，要访问数据页 P3，由于 P3 在 young 区域，因此和优化前的 LRU 算法一样，将其移到链表头部，变成状态</p>
<p>2️⃣之后要访问一个新的不存在于当前链表的数据页，这时候依然是淘汰掉数据页 Pm，但是新插入的数据页 Px，是放在 LRU_old 处</p>
<p>3️⃣ 处于 old 区域的数据页，每次被访问的时候都要做下面这个判断：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>若这个数据页在 LRU 链表中存在的时间超过了 1 秒，就把它移动到链表头部</p>
</li>
<li class="lvl-2">
<p>如果这个数据页在 LRU 链表中存在的时间短于 1 秒，位置保持不变。1 秒这个时间，是由参数 innodb_old_blocks_time 控制的。其默认值是 1000，单位毫秒</p>
</li>
</ul>
<p>这个策略，就是为了处理类似全表扫描的操作量身定制的，在扫描这个大表的过程中，虽然也用到了 Buffer Pool，但是对 young 区域完全没有影响，从而保证了 Buffer Pool 响应正常业务的查询命中率</p>
<h1>34-到底可不可以使用join？</h1>
<p>🔥 首先，对于我们的查询语句，在上线之前，explain一下是很有必要的，那么对于explain的几种类型需要了解：</p>
<p>1️⃣ <code>const </code>: 根据主键 等值匹配，唯一索引(is null除外) 等值匹配</p>
<p>2️⃣ index : 索引覆盖，无须回表</p>
<p>3️⃣ ref ： 普通索引等值匹配 ，普通索引 is null ，唯一索引 is null</p>
<p>4️⃣ range: 主键索引或者唯一索引范围查询，或者普通索引范围查询 ， 若范围在总范围中占比大，会变为 ALL</p>
<p>其中，各个类型的优劣如下：</p>
<blockquote>
<p><code>const </code>&gt; ref &gt; index &gt; range &gt; all</p>
</blockquote>
<p>t1 和 t2的表结构如下：其中t1中100条记录，t2中1000条记录</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t2` (`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">                   `a`  <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">                   `b`  <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">                   <span class="keyword">primary</span> key (`id`),</span><br><span class="line">                   key `a` (`a`)</span><br><span class="line">) engine <span class="operator">=</span> innodb</span><br></pre></td></tr></tbody></table></figure>
<h2 id="34-1-Index-Nested-Loop-Join">34.1-Index Nested-Loop Join</h2>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a <span class="operator">=</span> t2.a);</span><br></pre></td></tr></tbody></table></figure>
<p>当前语句的执行流程：</p>
<p>1️⃣ 从表 t1 中读入一行数据 R</p>
<p>2️⃣ 从数据行 R 中，取出 a 字段到表 t2 里去查找</p>
<p>3️⃣ 取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分</p>
<p>4️⃣ 重复执行步骤 1 到 3，直到表 t1 的末尾循环结束</p>
<p align="center">
  <img src="/2023/09/30/mysql/38.jpg" width="100%" alt="Your image description">
</p>
<p>如果t1 = N 行，t2 M 行，近似复杂度如下：<br>
$$<br>
O(N)= N + N \times2\times\log2 M<br>
$$<br>
可以发现，N 越小，整个复杂度越低。</p>
<h2 id="34-2-Simple-Nested-Loop-Join">34.2-Simple Nested-Loop Join</h2>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 straight_join t2 <span class="keyword">on</span> (t1.a<span class="operator">=</span>t2.b);</span><br></pre></td></tr></tbody></table></figure>
<p>由于t2的字段b上没有索引，每次去t2匹配的时候，就需要做一个全表扫描。共需要扫描:$100,000 = 100\times1000$</p>
<p>MySQL并没有使用这个Simple Nested-Loop Join 算法， 而是 Block Nested-Loop Join</p>
<h2 id="34-3-Block-Nested-Loop-Join">34.3-Block Nested-Loop Join</h2>
<p>对于 查询，<code>select * from t1 straight_join t2 on (t1.a=t2.b);</code> 流程如下：</p>
<p>1️⃣ 把表 t1 的数据读入线程内存 join_buffer 中，由于我们这个语句中写的是 select *，因此是把整个表 t1 放入了内存；</p>
<p>2️⃣ 扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。</p>
<p>这个过程对 t1和 t2都做了一次全表扫描 ， 总的扫描行数是1100，对于t2的每一行都需要在内存中做判断，共需要 100,000 次比较。但是这个比较是基于内存操作，比Simple Nested-Loop Join 快很多。</p>
<p>其中 join_buffer<sup class="footnote-ref"><a href="#fn20" id="fnref20">[20]</a></sup> 如果放不下驱动表，就需要分块（block）放置，过程如下：</p>
<p>1️⃣ 扫描表 t1，顺序读取数据行放入 join_buffer 中，放完第 88 行 join_buffer 满了，继续第 2 步；</p>
<p>2️⃣ 扫描表 t2，把 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回；</p>
<p>3️⃣ 清空 join_buffer；</p>
<p>4️⃣ 继续扫描表 t1，顺序读取最后的 12 行数据放入 join_buffer 中，继续执行第 2 步。</p>
<p align="center">
  <img src="/2023/09/30/mysql/39.jpg" width="80%" alt="Your image description">
</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>扫描行数 : N+λ * N * M （λ 取值(0,1)）</p>
</li>
<li class="lvl-2">
<p>内存判断 : N * M</p>
</li>
</ul>
<p><strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表</strong>。</p>
<h1>35-join语句怎么优化？</h1>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a)); </span><br><span class="line"><span class="comment">-- t1 插入1000行数据，每行的a = 1001-id，即表t1中的字段a是逆序的</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t1;  <span class="comment">-- 在表t2中插入 100w 数据</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="35-1-Multi-Range-Read-优化">35.1-Multi-Range Read 优化</h2>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> a<span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> a<span class="operator">&lt;=</span><span class="number">100</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>如上查询中，会涉及到回表的过程，回表过程是一行行查询数据，还是批量的查询数据呢？主键索引是一颗B+树，每次只能根据一个主键id 查到一行数据，因此<strong>回表一定是一行行搜索主键索引的</strong>。在上面的例子中，如果随着a的值递增顺序查询的话，id的值就变成随机的了，那么就会出现随机访问磁盘，性能相对较差。</p>
<blockquote>
<p>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</p>
</blockquote>
<p>以上，就是 MRR 优化的设计思路。此时，语句的执行流程变成了这样：</p>
<p>1️⃣ 根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ; (如果read_rnd_buffer 放置满了，就会先执行 2,3步骤)</p>
<p>2️⃣ 将 read_rnd_buffer 中的 id 进行递增排序；</p>
<p>3️⃣ 排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</p>
<p align="center">
  <img src="/2023/09/30/mysql/40.jpg" width="90%" alt="Your image description">
</p>
<p>MRR 能够提升性能的核心在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。</p>
<h2 id="35-2-Batched-Key-Access">35.2-Batched Key Access</h2>
<p>Batched Key Accesss（BKA）算法，其实是对 NLJ(Index Nested Loop Join) 算法的优化，NLJ的逻辑是，从驱动表t1，一行行取出a的值，再到被驱动表t2做join，对于表 t2 来说，每次都是匹配一个值。这时，MRR 的优势就用不上了，而BKA的逻辑是，将表t1的数据取出来一部分，放置到join_buffer中，然后一起传给表t2。</p>
<p align="center">
  <img src="/2023/09/30/mysql/41.jpg" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<p>Post Script : BKA 算法的优化要依赖于 MRR，使用BKA的前提是开启了 MRR</p>
<h1>36-为什么临时表可以重名？</h1>
<h4 id="说说临时表和内存表的区别？">说说临时表和内存表的区别？</h4>
<p>内存表，指的是使用 Memory 引擎的表，建表语法是 <code>create table … engine=memory</code>。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在</p>
<p>临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。当然，临时表也可以使用 Memory 引擎</p>
<h4 id="临时表有哪些特性？">临时表有哪些特性？</h4>
<p align="center">
  <img src="/2023/09/30/mysql/42.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<ol>
<li class="lvl-3">
<p>建表语法是 <code>create temporary table …</code></p>
</li>
<li class="lvl-3">
<p>一个临时表只能被创建它的 session 访问，对其他线程不可见。所以，图中 session A 创建的临时表 t，对于 session B 就是不可见的</p>
</li>
<li class="lvl-3">
<p>临时表可以与普通表同名</p>
</li>
<li class="lvl-3">
<p>session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表</p>
</li>
<li class="lvl-3">
<p>show tables 命令不显示临时表</p>
</li>
</ol>
<p>由于临时表只能被创建它的 session 访问，所以在这个 session 结束的时候，会自动删除临时表。也正是由于这个特性，临时表就特别适合我们文章开头的 join 优化这种场景。为什么呢？原因主要包括以下两个方面：</p>
<ol>
<li class="lvl-3">
<p>不同 session 的临时表是可以重名的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题</p>
</li>
<li class="lvl-3">
<p>不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作</p>
</li>
</ol>
<h1>37-什么时候会使用内部临时表？</h1>
<h1>38-都说<code>InnoDB</code>好，那还要不要使用Memory引擎？</h1>
<p><code>show processlist</code> 命令的作用：可以帮助确定哪些查询可能会导致性能问题，常用语调试MySQL性能或锁问题，其输出列的含义如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Id</strong>：连接的唯一标识符</p>
</li>
<li class="lvl-2">
<p><strong>User</strong>：建立此连接的MySQL用户</p>
</li>
<li class="lvl-2">
<p><strong>Host</strong>：用户连接到MySQL服务器的机器或IP地址</p>
</li>
<li class="lvl-2">
<p><strong>db</strong>：当前连接使用的数据库。可能为空，如果没有选择数据库</p>
</li>
<li class="lvl-2">
<p><strong>Command</strong>：执行的命令，如 Query（查询）, Sleep（休眠）, etc.</p>
</li>
<li class="lvl-2">
<p><strong>Time</strong>：命令已经运行的秒数</p>
</li>
<li class="lvl-2">
<p><strong>State</strong>：连接的当前状态，如<code>Waiting for table lock</code></p>
</li>
<li class="lvl-2">
<p><strong>Info</strong>：具体执行的查询或命令。对于非查询命令，此列可能为空</p>
</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- t1表使用内存表，Memory存储引擎</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>) engine<span class="operator">=</span>Memory;</span><br><span class="line"><span class="comment">-- t2表使用innodb存储引擎</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(id <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>) engine<span class="operator">=</span>innodb;</span><br><span class="line"><span class="comment">-- 向 t1和t2插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>),(<span class="number">9</span>,<span class="number">9</span>),(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>),(<span class="number">9</span>,<span class="number">9</span>),(<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="38-1-内存表的数据组织方式">38.1-内存表的数据组织方式</h2>
<p align="center">
  <img src="/2023/09/30/mysql/53.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<p align="center">
  <img src="/2023/09/30/mysql/54.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<p>🅰️ InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）</p>
<p>🅱️ 而 Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为堆组织表（Heap Organizied Table）</p>
<p>2种引擎比对的差异如下：</p>
<ol>
<li class="lvl-3">
<p>InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的</p>
</li>
<li class="lvl-3">
<p>当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值</p>
</li>
<li class="lvl-3">
<p>数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引</p>
</li>
<li class="lvl-3">
<p>InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的</p>
</li>
<li class="lvl-3">
<p>InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同</p>
</li>
</ol>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 最开始插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">7</span>),(<span class="number">8</span>,<span class="number">8</span>),(<span class="number">9</span>,<span class="number">9</span>),(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"><span class="comment">-- 删除id=5的数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"><span class="comment">-- id=10填充原本id=5的位置，由于内存表中每个数据行被删除以后，空出的这个位置都可以被接下来要插入的数据复用</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="38-2-内存表的哈希索引和B-Tree索引">38.2-内存表的哈希索引和B-Tree索引</h2>
<p>t1 的这个主键索引是哈希索引，执行范围查询时，实际走的是全表扫描，当然我们可以使得内存表支持B-Tree索引</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 在 id 列上创建一个 B-Tree 索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> index a_btree_index <span class="keyword">using</span> btree (id);</span><br></pre></td></tr></tbody></table></figure>
<p align="center">
  <img src="/2023/09/30/mysql/55.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<p>内存表的优势是速度快，速度快的2点：</p>
<p>🅰️  Memory 引擎支持 hash 索引</p>
<p>🅱️  内存表的所有数据都保存在内存，而内存的读写速度总是比磁盘快</p>
<h2 id="38-3-内存表的锁">38.3-内存表的锁</h2>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"># 让返回的数据睡一会</span><br><span class="line"><span class="keyword">select</span> sleep(<span class="number">2</span>) <span class="keyword">as</span> sleep_interval , <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<p>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作</p>
<p align="center">
  <img src="/2023/09/30/mysql/56.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<h2 id="38-4-内存表的持久性">38.4-内存表的持久性</h2>
<p align="center">
  <img src="/2023/09/30/mysql/57.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<p align="center">
  <img src="/2023/09/30/mysql/58.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<p>基于以上的分析，我们得出结论：<strong>内存表并不适合在生产环境上作为普通数据表使用</strong></p>
<h1>39-自增主键为什么不是连续的？</h1>
<p>自增主键是递增的，但是不一定连续。主键的递增特性避免了页分裂</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  <span class="keyword">primary</span> key (`id`),</span><br><span class="line">  <span class="keyword">unique</span> key `c` (`c`)</span><br><span class="line">) engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></tbody></table></figure>
<p>表的结构定义存放在后缀名为<code>.frm</code> 的文件后面，在这个空表 t 里面执行 <code>insert into t values(null, 1, 1);</code> 插入一行数据，再执行 <code>show create table</code> 命令，就可以看到如下图所示的结果</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="comment">-- AUTO_INCREMENT=2，表示下一次插入数据时，如果需要自动生成自增值，会生成 id=2</span></span><br></pre></td></tr></tbody></table></figure>
<p>InnoDB 引擎的自增值，其实是保存在了内存里，并且到了 MySQL 8.0 版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为 MySQL 重启前的值”，具体情况是：</p>
<ol>
<li class="lvl-3">
<p>在 MySQL 5.7 及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 <code>max(id)+1</code> 作为这个表当前的自增值。�举例来说，如果一个表当前数据行里最大的 id 是 10，AUTO_INCREMENT=11。这时候，我们删除 id=10 的行，AUTO_INCREMENT 还是 11。但如果马上重启实例，重启后这个表的 AUTO_INCREMENT 就会变成 10。</p>
</li>
<li class="lvl-3">
<p>也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值</p>
</li>
<li class="lvl-3">
<p>在 MySQL 8.0 版本，将自增值的变更记录在了 redo log 中，重启的时候依靠 redo log 恢复重启之前的值</p>
</li>
</ol>
<h2 id="39-1-自增值修改机制">39.1-自增值修改机制</h2>
<p>在 MySQL 里面，如果字段 id 被定义为 <code>AUTO_INCREMENT</code>，在插入一行数据的时候，自增值的行为如下：</p>
<ol>
<li class="lvl-3">
<p>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 <code>AUTO_INCREMENT</code> 值填到自增字段</p>
</li>
<li class="lvl-3">
<p>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值，可能会更新 <code>auto_increment_increment</code> 的值，假设某次要插入的值是 X，当前的自增值是 Y</p>
<ol>
<li class="lvl-6">如果 X&lt;  Y，那么这个表的自增值不变</li>
<li class="lvl-6">如果 X≥ Y，就需要把当前自增值修改为新的自增值 （从 <code>auto_increment_offset</code> 开始，以 <code>auto_increment_increment </code>为步长(默认设置为1)，持续叠加，直到找到第一个大于 X 的值，作为新的自增值）</li>
</ol>
</li>
</ol>
<p>尝试执行以下代码，进行测试</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"># 第一次执行插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"># 观察 AUTO_INCREMENT 的值</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t;</span><br><span class="line"></span><br><span class="line"># 第二次执行插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"># 观察 AUTO_INCREMENT 的值</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t;</span><br><span class="line"></span><br><span class="line"># 第三次执行插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>);</span><br><span class="line"># 观察 AUTO_INCREMENT 的值</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会观察到 id 不在连续了</span></span><br></pre></td></tr></tbody></table></figure>
<p>当 <code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 都是 1 的时候，新的自增值生成逻辑很简单，就是：</p>
<ol>
<li class="lvl-3">
<p>如果准备插入的值 &gt;= 当前自增值，新的自增值就是“准备插入的值 +1”</p>
</li>
<li class="lvl-3">
<p>否则，自增值不变</p>
</li>
</ol>
<h2 id="39-2-自增值的修改时机">39.2-自增值的修改时机</h2>
<p>目前，假设表 t 里面已经有了 (1,1,1) 这条记录，这时我再执行一条插入数据命令<code>insert into t values(null, 1, 1); </code></p>
<p align="center">
  <img src="/2023/09/30/mysql/51.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<p>事务回滚也会导致逐渐不连续</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>插入的行是(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="自增值为什么不能回退">自增值为什么不能回退?</h3>
<p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请</p>
<ol>
<li class="lvl-3">
<p>假设事务 A 申请到了 id=2， 事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行</p>
</li>
<li class="lvl-3">
<p>事务 B 正确提交了，但事务 A 出现了唯一键冲突</p>
</li>
<li class="lvl-3">
<p>如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id=3 的行，而当前的自增 id 值是 2</p>
</li>
<li class="lvl-3">
<p>接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”</p>
</li>
</ol>
<p>而为了解决这个主键冲突，有两种方法：</p>
<p>🅰️ 每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。</p>
<p>🅱️ 把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降</p>
<p>这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增 id 回退”的前提导致的。因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的</p>
<h2 id="39-3-自增锁的优化">39.3-自增锁的优化</h2>
<p>自增 id 锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请</p>
<p>MySQL 5.1.22 版本引入了新增参数 <code>innodb_autoinc_lock_mode</code>，默认值是 1。</p>
<ol>
<li class="lvl-3">
<p>这个参数的值被设置为 0 时，语句执行结束后才释放锁</p>
</li>
<li class="lvl-3">
<p>这个参数的值被设置为 1 时：普通 <code>insert</code> 语句，自增锁在申请之后就马上释放；类似 <code>insert … select</code> 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放</p>
</li>
<li class="lvl-3">
<p>这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁</p>
</li>
</ol>
<p align="center">
  <img src="/2023/09/30/mysql/52.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<p>如果我们现在的 <code>binlog_format=statement</code>，binlog 会怎么记录呢？由于两个 session 是同时执行插入数据命令的，所以 binlog 里面对表 t2 的更新日志只有两种情况：要么先记 session A 的，要么先记 session B 的。但不论是哪一种，这个 binlog 拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B 这个语句执行出来，生成的结果里面，id 都是连续的。这时，从库和主库就发生了数据不一致</p>
<p>那么如何解决这个问题呢？</p>
<ol>
<li class="lvl-3">
<p>一种思路是，让原库的批量插入数据语句，固定生成连续的 id 值。所以，<strong>自增锁直到语句执行结束才释放</strong>，就是为了达到这个目的</p>
</li>
<li class="lvl-3">
<p>另一种思路是，在 binlog 里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是 <code>innodb_autoinc_lock_mode</code> 设置为 2，同时 <code>binlog_format</code> 设置为 row。</p>
</li>
</ol>
<p>在生产上，尤其是有 <code>insert … select </code> 和 <code>replace … select</code> 和<code> load data</code> 这种批量插入数据的场景，推荐第2种方式，这样做，既能提升并发性，又不会出现数据一致性问题</p>
<h3 id="批量插入语句，自增ID的策略">批量插入语句，自增ID的策略</h3>
<p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略</p>
<ol>
<li class="lvl-3">
<p>语句执行过程中，第一次申请自增 id，会分配 1 个；</p>
</li>
<li class="lvl-3">
<p>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</p>
</li>
<li class="lvl-3">
<p>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</p>
</li>
<li class="lvl-3">
<p>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍</p>
</li>
</ol>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第一次申请了id=1，第二次申请了 id in (2,3)，第三次申请了 id in (4,5,6,7) 但是只用了id=4</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t; </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">5</span>,<span class="number">5</span>);  <span class="comment">-- 实际插入的值为（8,5,5）</span></span><br></pre></td></tr></tbody></table></figure>
<p>总结一下，ID不连续的原因：</p>
<ol>
<li class="lvl-3">
<p>人为的指定了id，跳过了一些ID</p>
</li>
<li class="lvl-3">
<p>唯一键冲突</p>
</li>
<li class="lvl-3">
<p>事务回滚</p>
</li>
<li class="lvl-3">
<p>批量插入数据的时候，批量申请但是没有用完</p>
</li>
</ol>
<h1>40-insert语句的锁为什么这么多？</h1>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t</span><br></pre></td></tr></tbody></table></figure>
<p>数据库设置的隔离级别为RR；<code>binlog_format=statement</code></p>
<h2 id="40-1-insert-…-select-语句">40.1-insert … select 语句</h2>
<p align="center">
  <img src="/2023/09/30/mysql/59.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<p>执行 <code>insert … select</code> 的时候，对目标表也不是锁全表，而是只锁住需要访问的资源</p>
<h2 id="40-2-insert循环写入">40.2-insert循环写入</h2>
<h2 id="40-3-insert-唯一键冲突">40.3-insert 唯一键冲突</h2>
<h1>41-怎么最快地复制一张表？</h1>
<p>如果可以控制对源表的扫描行数和加锁范围很小的话，我们简单地使用 <code>insert … select</code> 语句即可实现，在2个表中拷贝数据。当然，为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表。这时，有两种常用的方法</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一个表 `db1.t`</span></span><br><span class="line"><span class="keyword">create</span> database db1;</span><br><span class="line">use db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(id <span class="type">int</span> <span class="keyword">primary</span> key, a <span class="type">int</span>, b <span class="type">int</span>, index(a))engine<span class="operator">=</span>innodb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 往 `db1.t` 中 插入 1000 行数据</span></span><br><span class="line">delimiter ;;</span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">set</span> i<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">    while(i<span class="operator">&lt;=</span><span class="number">1000</span>)do</span><br><span class="line">      <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i,i);</span><br><span class="line">      <span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">  <span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个和 `db1.t` 相同结构的表 db2.t</span></span><br><span class="line"><span class="keyword">create</span> database db2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 把 `db1.t` 里面 a&gt;900 的数据行导出来，插入到 db2.t 中</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db2.t <span class="keyword">like</span> db1.t</span><br></pre></td></tr></tbody></table></figure>
<h2 id="41-1-mysqldump-方法">41.1-mysqldump 方法</h2>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>h$host <span class="operator">-</span>P$port <span class="operator">-</span>u$<span class="keyword">user</span> <span class="comment">--add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --result-file=/client_tmp/t.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- –skip-extended-insert 生成单条的 insert 语句</span></span><br></pre></td></tr></tbody></table></figure>
<p>通过 <code>mysqldump</code> 命令生成的 t.sql 文件，大概是这样的： <code>insert into t values(901,901,901),(902,902,902),(903,903,903).....</code> 。得到该文件后，，可以通过以下的命令，将 insert语句放到db2中执行</p>
<p><code>mysql -h127.0.0.1 -P13000  -uroot db2 -e "source /client_tmp/t.sql"</code></p>
<p><code>source</code> 并不是一条 SQL 语句，而是一个客户端命令。mysql 客户端执行这个命令的流程是这样的：</p>
<ol>
<li class="lvl-3">
<p>打开文件，默认以分号为结尾读取一条条的 SQL 语句</p>
</li>
<li class="lvl-3">
<p>将 SQL 语句发送到服务端执行</p>
</li>
</ol>
<h2 id="41-2-导出-CSV-文件">41.2-导出 CSV 文件</h2>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> db1.t <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">900</span> <span class="keyword">into</span> outfile <span class="string">'/server_tmp/t.csv'</span>;</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li class="lvl-3">
<p>这条语句会将结果保存在服务端</p>
</li>
<li class="lvl-3">
<p>这条命令不会帮你覆盖文件，因此你需要确保 <code>/server_tmp/t.csv</code>这个文件不存在</p>
</li>
</ol>
<p>得到<code>.csv</code> 导出文件后，你就可以用<code> load data</code> 命令将数据导入到目标表 db2.t 中</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">load data infile <span class="string">'/server_tmp/t.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> db2.t;</span><br></pre></td></tr></tbody></table></figure>
<p>该语句的执行步骤如下：</p>
<ol>
<li class="lvl-3">
<p>打开文件 <code>/server_tmp/t.csv</code>，以制表符 <code>(\t)</code> 作为字段间的分隔符，以换行符<code>（\n）</code>作为记录之间的分隔符，进行数据读取；</p>
</li>
<li class="lvl-3">
<p>启动事务。判断每一行的字段数与表 db2.t 是否相同：</p>
<ol>
<li class="lvl-6">若不相同，则直接报错，事务回滚；</li>
<li class="lvl-6">若相同，则构造成一行，调用 InnoDB 引擎接口，写入到表中。</li>
</ol>
</li>
<li class="lvl-3">
<p>重复步骤 3，直到 /server_tmp/t.csv 整个文件读入完成，提交事务</p>
</li>
</ol>
<p>如果 <code>binlog_format=statement</code>，由于 <code>/server_tmp/t.csv</code> 文件只保存在主库所在的主机上，如果只是把这条语句原文写到 binlog 中，在备库执行的时候，备库的本地机器上并没有这个文件，就会导致主备同步停止。所以，这条语句执行的完整流程，如下</p>
<p align="center">
  <img src="/2023/09/30/mysql/49.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<p>load data 命令有两种用法：</p>
<ol>
<li class="lvl-3">
<p>不加“local”，是读取服务端的文件，这个文件必须在 <code>secure_file_priv</code> 指定的目录或子目录下</p>
</li>
<li class="lvl-3">
<p>加上“local”，读取的是客户端的文件，只要 mysql 客户端有访问这个文件的权限即可。这时候，MySQL 客户端会先把本地文件传给服务端，然后执行上述的 <code>load data</code> 流程</p>
</li>
<li class="lvl-3">
</li>
</ol>
<h2 id="42-3-物理拷贝方法">42.3-物理拷贝方法</h2>
<p><code>dump</code>和导出CSV方式，都是逻辑导数的方式，即：将数据从表 db1.t 中读出来，生成文本，然后再写入目标表 db2.t 中。有没有一种方式：直接把 db1.t 表的.frm 文件和.ibd 文件拷贝到 db2 目录下呢？</p>
<p>一个 InnoDB 表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两个文件的话，因为数据字典中没有 db2.t 这个表，系统是不会识别和接受它们的，所以直接拷贝的方式不可行</p>
<p>MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出 + 导入表空间的方式，实现物理拷贝表的功能，流程如下：现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r</p>
<p align="center">
  <img src="/2023/09/30/mysql/50.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<h1>42-grant之后要跟着flush privileges吗？</h1>
<h2 id="42-1-全局权限">42.1-全局权限</h2>
<h3 id="mysql-如何创建一个用户？">mysql 如何创建一个用户？</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一个用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'ua'</span>@<span class="string">'%'</span> identified <span class="keyword">by</span> <span class="string">'pa'</span>; <span class="comment">-- 创建1个用户为 'ua'@'%' 的用户 ， 密码是 pa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询某个用户</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.user <span class="keyword">where</span> <span class="keyword">User</span> <span class="operator">=</span> <span class="string">'ua'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除一个用户</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> mysql.user <span class="keyword">where</span> <span class="keyword">User</span> <span class="operator">=</span> <span class="string">'ua'</span>; </span><br></pre></td></tr></tbody></table></figure>
<p>在MySQL中，用户名 (user)+ 地址 (host) 才表示一个用户，因此 <code>ua@ip1</code> 和 <code>ua@ip2</code> 代表的是两个不同的用户</p>
<h3 id="如何给MySQL中某个用户赋予最高权限？">如何给MySQL中某个用户赋予最高权限？</h3>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></tbody></table></figure>
<p>该命令执行了2个动作：</p>
<ol>
<li class="lvl-3">
<p>磁盘上，将 <code> mysql.user</code> 表里，用户<code>’ua’@’%'</code>这一行的所有表示权限的字段的值都修改为‘Y’；</p>
</li>
<li class="lvl-3">
<p>内存里，从数组 <code>acl_users</code> 中找到这个用户对应的对象，将 access 值（权限位）修改为二进制的“全 1”</p>
</li>
</ol>
<p>在 grant 命令执行完了之后，如果新的客户端使用 ua用户登录，MySQL 会为新连接维护一个线程对象，然后从 <code>acl_users</code> 数组里查到这个用户的权限，并将权限值拷贝到这个线程对象中。之后在这个连接中所有关于全局权限的判断，都直接使用线程对象内部保存的权限位。</p>
<p><strong>对于一个已经存在的连接，它的全局权限不受 grant 命令的影响</strong></p>
<h3 id="mysql-如何回收权限？">mysql 如何回收权限？</h3>
<p>如果一个用户有所有权限，一般就不应该设置为所有 IP 地址都可以访问，应该是限制性的IP可以访问</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">'ua'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>该命令对应2个动作：</p>
<ol>
<li class="lvl-3">
<p>磁盘上，将 <code>mysql.user</code> 表里，用户<code>’ua’@’%'</code>这一行的所有表示权限的字段的值都修改为“N”</p>
</li>
<li class="lvl-3">
<p>内存里，从数组 <code>acl_users</code> 中找到这个用户对应的对象，将 access 的值修改为 0</p>
</li>
</ol>
<h2 id="42-2-DB权限">42.2-DB权限</h2>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> db1.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></tbody></table></figure>
<p>这条 grant 命令做了如下两个动作：</p>
<ol>
<li class="lvl-3">
<p>磁盘上，往 <code>mysql.db</code> 表中插入了一行记录，所有权限位字段设置为“Y”</p>
</li>
<li class="lvl-3">
<p>内存里，增加一个对象到数组 <code>acl_dbs</code> 中，这个对象的权限位为“全 1”</p>
</li>
</ol>
<p>基于库的权限记录保存在 <code>mysql.db 表</code>中，在内存里则保存在数组 acl_dbs，查询某个用户的库权限方式如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.db <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">'ua'</span></span><br></pre></td></tr></tbody></table></figure>
<p>每次需要判断一个用户对一个数据库读写权限的时候，都需要遍历一次 <code>acl_dbs</code> 数组，根据 user、host 和 db 找到匹配的对象，然后根据对象的权限位来判断（并没有拷贝到连接对象的线程对象中）。<strong>grant 修改 db 权限的时候，是同时对磁盘和内存生效的</strong></p>
<p align="center">
  <img src="/2023/09/30/mysql/43.png" width="100%" alt="Your image description">
  <span style="color:gray"> info about the picture </span>
</p>
<h2 id="42-3-表列权限">42.3-表列权限</h2>
<p>表权限定义存放在表 <code>mysql.tables_priv</code> 中，列权限定义存放在表 <code>mysql.columns_priv</code> 中。这两类权限，组合起来存放在内存的 hash 结构 <code>column_priv_hash</code> 中</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db1.t1(id <span class="type">int</span>, a <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将`db1.t1` 表的所有权限授权给 ua 用户</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> db1.t1 <span class="keyword">to</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> option; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将mydb.mytbl的查询 id列权限，和 (id,a) 的插入权限 授权给 ua 用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>(id), <span class="keyword">INSERT</span> (id,a) <span class="keyword">ON</span> mydb.mytbl <span class="keyword">TO</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></tbody></table></figure>
<p>这两个权限每次 <code>grant</code> 的时候都会修改数据表，也会同步修改内存中的 hash 结构。因此，对这两类权限的操作，也会马上影响到已经存在的连接</p>
<h2 id="42-4-flush-privileges-的作用">42.4- <code>flush privileges</code> 的作用</h2>
<p><code>flush privileges</code> 命令会清空 <code>acl_users</code> 数组，然后从 <code>mysql.user</code> 表中读取数据重新加载，重新构造一个 <code>acl_users</code> 数组。也就是说，以数据表中的数据为准，会将全局权限内存数组重新加载一遍。同样地，对于 db 权限、表权限和列权限，MySQL 也做了这样的处理</p>
<p>那么 <code>flush privileges</code> 的使用场景就是：当数据表中的权限数据跟内存中的权限数据不一致的时候，flush privileges 语句可以用来重建内存数据，达到一致状态</p>
<p align="center">
  <img src="/2023/09/30/mysql/44.png" width="100%" alt="Your image description">
   <br>
   <span style="color:gray"> info about the picture </span>
</p>
<h1>43-要不要使用分区表？</h1>
<p>创建一个分区表</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `t`</span><br><span class="line">(</span><br><span class="line">    `ftime` datetime <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `c`     <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">    key (`ftime`)</span><br><span class="line">) engine <span class="operator">=</span> innodb</span><br><span class="line">  <span class="keyword">default</span> charset <span class="operator">=</span> latin1</span><br><span class="line">    <span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span> (<span class="keyword">year</span>(ftime))</span><br><span class="line">        (<span class="keyword">partition</span> p_2017 <span class="keyword">values</span> less than (<span class="number">2017</span>) engine <span class="operator">=</span> innodb,</span><br><span class="line">        <span class="keyword">partition</span> p_2018 <span class="keyword">values</span> less than (<span class="number">2018</span>) engine <span class="operator">=</span> innodb,</span><br><span class="line">        <span class="keyword">partition</span> p_2019 <span class="keyword">values</span> less than (<span class="number">2019</span>) engine <span class="operator">=</span> innodb,</span><br><span class="line">        <span class="keyword">partition</span> p_others <span class="keyword">values</span> less than maxvalue engine <span class="operator">=</span> innodb</span><br><span class="line">        )</span><br><span class="line">;</span><br></pre></td></tr></tbody></table></figure>
<p>该表的创建会形成以下文件</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>t.frm 即 对于 Server 层来说，这是 1 个表</p>
</li>
<li class="lvl-2">
<p>t#P#p_2017.ibd， t#P#p_2018.ibd，t#P#p_2019.ibd，t#P#p_others.ibd，即 对于引擎层来说，这是 4 个表</p>
</li>
</ul>
<h2 id="43-1-分区表的引擎层行为">43.1-分区表的引擎层行为</h2>
<p>对于InnoDB 来说，这是 4 个表</p>
<p align="center">
  <img src="/2023/09/30/mysql/47.png" width="100%" alt="Your image description">
   <br>
   <span style="color:gray"> info about the picture </span>
</p>
<p>使用分区表的一个重要原因就是单表过大。那么，如果不使用分区表的话，我们就是要使用手动分表的方式，分区表和手工分表，分区表由 server 层来决定使用哪个分区，手工分表是由应用层代码来决定使用哪个分表</p>
<h2 id="43-2-分区策略">43.2-分区策略</h2>
<p>每当第一次访问一个分区表的时候，MySQL 需要把所有的分区都访问一遍。一个典型的报错情况是这样的：如果一个分区表的分区很多，比如超过了 1000 个，而 MySQL 启动的时候，<code>open_files_limit</code> 参数使用的是默认值 1024，那么就会在访问这个表的时候，会发生“打开表文件的个数超过了上限” 的报错</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">Too many <span class="keyword">open</span> files </span><br></pre></td></tr></tbody></table></figure>
<p>MyISAM 分区表使用的分区策略，我们称为通用分区策略（generic partitioning），每次访问分区都由 server 层控制。通用分区策略，是 MySQL 一开始支持分区表的时候就存在的代码，在文件管理、表管理的实现上很粗糙，因此有比较严重的性能问题。从 MySQL 5.7.9 开始，InnoDB 引擎引入了本地分区策略（native partitioning），在InnoDB引擎打开文件超过 <code>innodb_open_files</code> 这个值的时候，就会关掉一些之前打开的文件</p>
<h2 id="43-3-分区表的Server层行为">43.3-分区表的Server层行为</h2>
<p>从server 层看的话，一个分区表就只是一个表</p>
<p align="center">
  <img src="/2023/09/30/mysql/48.png" width="100%" alt="Your image description">
   <br>
   <span style="color:gray"> info about the picture </span>
</p>
<p>虽然 session B 只需要操作 p_2017 这个分区，但是由于 session A 持有整个表 t 的 MDL 锁，就导致了 session B 的 alter 语句被堵住。分区表，在做 DDL 的时候，影响会更大</p>
<p>分区表的一个显而易见的优势是对业务透明，相对于用户分表来说，使用分区表的业务代码更简洁。还有，分区表可以很方便的清理历史数据</p>
<h1>44-答疑文章（三）：说一说这些好问题</h1>
<h1>45-自增id用完怎么办？</h1>
<h2 id="45-1-表定义自增ID">45.1- 表定义自增ID</h2>
<p>表定义的自增值达到上限后的逻辑是：再申请下一个 id 时，得到的值保持不变。因此，当自增主键id 用完时，仍然会得到最后一个ID，再有插入就会报错主键冲突，测试如下：</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t</span><br><span class="line">(</span><br><span class="line">    id <span class="type">int</span> unsigned auto_increment <span class="keyword">primary</span> key</span><br><span class="line">) auto_increment <span class="operator">=</span> <span class="number">4294967295</span>; <span class="comment">-- 2^32 - 1 = 4294967295</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="keyword">null</span>);</span><br><span class="line"># 成功插入一行 <span class="number">4294967295</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t;</span><br><span class="line"><span class="comment">/* CREATE TABLE `t` (</span></span><br><span class="line"><span class="comment">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="comment">  PRIMARY KEY (`id`)</span></span><br><span class="line"><span class="comment">) ENGINE=InnoDB AUTO_INCREMENT=4294967295;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t; <span class="comment">-- 4294967295</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="keyword">null</span>);</span><br><span class="line"># Duplicate entry <span class="string">'4294967295'</span> <span class="keyword">for</span> key <span class="string">'PRIMARY'</span></span><br></pre></td></tr></tbody></table></figure>
<p>$2^{32}-1 = 4294967295 $  不是一个特别大的数，对于一个频繁插入删除数据的表来说，是可能会被用完的。因此如果你的表是否有可能达到这个上限，就应该创建成 8 个字节的 <code>bigint unsigned</code></p>
<h2 id="45-2-InnoDB-系统自增-row-id">45.2- InnoDB 系统自增 row_id</h2>
<p>如果创建的 InnoDB 表没有指定主键，那么 InnoDB 会给你创建一个不可见的，长度为 6 个字节（8个字节的后6个字节）的 <code>row_id</code>。InnoDB 维护了一个全局的 <code>dict_sys.row_id</code> 值，所有无主键的 InnoDB 表，每插入一行数据，都将当前的 <code>dict_sys.row_id</code> 值作为要插入数据的 <code>row_id</code>，然后把 <code>dict_sys.row_id</code> 的值加 1</p>
<p>写入表的 <code>row_id</code> 是从 0 开始到 $2^{48}-1$。达到上限后，下一个值就是 0，然后继续循，<strong>如果突破这个现实，新写入的行就会覆盖原有的行</strong></p>
<h2 id="45-3-Xid">45.3- Xid</h2>
<p>Xid 在 MySQL 内部是怎么生成的呢？</p>
<p>MySQL 内部维护了一个全局变量 <code>global_query_id</code>，每次执行语句的时候将它赋值给 <code>Query_id</code>，然后自身加 1。如果当前语句是某个事务执行的第一条语句，那么 MySQL 还会同时把 <code>Query_id</code> 赋值给这个事务的 Xid</p>
<p><code>global_query_id</code> 是一个纯内存变量，重启之后就清零了。所以，在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，同一个 binlog 文件里，Xid 一定是惟一的</p>
<p>MySQL 重启不会导致同一个 binlog 里面出现两个相同的 Xid，但是如果 <code>global_query_id</code> 达到上限后，就会继续从 0 开始计数。从理论上讲，还是就会出现同一个 binlog 里面出现相同 Xid 的场景，这种情况非常极端，无需考虑</p>
<h2 id="45-4-Innodb-trx-id">45.4- Innodb trx_id</h2>
<h4 id="Xid-在-trx-id-的区别在于什么？">Xid 在  trx_id 的区别在于什么？</h4>
<p>Xid是由server层维护的。 trx_id（transaction id）是InnoDB（引擎层） 另外维护的，InnoDB 内部使用Xid，就是为了能够在 InnoDB 事务和 server 之间做关联</p>
<p>Todo: 待更新</p>
<h2 id="45-5-thread-id">45.5- thread_id</h2>
<p>线程 id 是MySQL 中最常见的一种自增 id，<code>show processlist</code> 里面的第一列，就是 <code>thread_id</code>，系统保存了一个全局变量 <code>thread_id_counter</code>，每新建一个连接，就将 <code>thread_id_counter</code> 赋值给这个新连接的线程变量，并且保证该ID在所有线程数组中是唯一的。当连接关闭时，会调用函数 <code>release_thread_id</code>，从<code>thread_ids</code>移除当前 id号</p>
<p><code>thread_id_counter</code> 定义的大小是 4 个字节，因此达到 $2^{32}-1$ 后，它就会重置为 0，然后继续增加</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx; <span class="comment">-- 查看当前的事务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> processlist;  <span class="comment">-- 查看当前的连接</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>MySQL  的 unique key 约束  ： 允许多个null</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> `unique_key_test`</span><br><span class="line">(</span><br><span class="line">    id <span class="type">bigint</span>,</span><br><span class="line">    id_card <span class="type">varchar</span>(<span class="number">18</span>) ,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    <span class="keyword">primary</span> key (id),</span><br><span class="line">    <span class="keyword">unique</span> key (id_card)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> unique_key_test <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'411524199710094032'</span>,<span class="string">'z3'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> unique_key_test <span class="keyword">values</span> (<span class="number">2</span>,<span class="keyword">null</span>,<span class="string">'l4'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> unique_key_test <span class="keyword">values</span> (<span class="number">3</span>,<span class="keyword">null</span>,<span class="string">'w5'</span>); <span class="comment">-- 插入成功</span></span><br></pre></td></tr></tbody></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>IO成本就是寻址时间和上下文切换所需要的时间，最主要是用户态和内核态的上下文切换。我们知道用户态是无法直接访问磁盘等硬件上的数据的，只能通过操作系统去调内核态的接口，用内核态的线程去访问。 这里的上下文切换指的是同进程的线程上下文切换，所谓上下文就是线程运行需要的环境信息。 1️⃣ 首先，用户态线程需要一些中间计算结果保存CPU寄存器，保存CPU指令的地址到程序计数器（执行顺序保证），还要保存栈的信息等一些线程私有的信息。2️⃣  然后切换到内核态的线程执行，就需要把线程的私有信息从寄存器，程序计数器里读出来，然后执行读磁盘上的数据。读完后返回，又要把线程的信息写进寄存器和程序计数器。 3️⃣ 切换到用户态后，用户态线程又要读之前保存的线程执行的环境信息出来，恢复执行。这个过程主要是消耗时间资源 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>mvcc : <a href="https://cloud.tencent.com/developer/article/1801920">https://cloud.tencent.com/developer/article/1801920</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>changer buffer 使用的是buffer pool 的内存，默认占用50%，可以通过<code>innodb_change_buffer_max_size</code>来指定 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>这是数据库里成本最高的 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a href="https://time.geekbang.org/column/article/70848">https://time.geekbang.org/column/article/70848</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>InnoDB选取N个页，计算平均不同的值，然后乘以总页数 <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>建议设置为磁盘的IOPS <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn8" class="footnote-item"><p>R% 如何计算，参考：<a href="https://time.geekbang.org/column/article/71806">https://time.geekbang.org/column/article/71806</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn9" class="footnote-item"><p>主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值 <a href="#fnref9" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn10" class="footnote-item"><p>sort_buffer 是MySQL用于排序的一个缓冲 <a href="#fnref10" class="footnote-backref">↩︎</a> <a href="#fnref10:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn11" class="footnote-item"><p>utf8mb4是支持emoji的，而utf8不支持。utf8mb4是utf8的超集 <a href="#fnref11" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn12" class="footnote-item"><p>select blocking_pid from sys.schema_table_lock_waits <a href="#fnref12" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn13" class="footnote-item"><p>锁的设计是为了保证数据的一致性。而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性 <a href="#fnref13" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn14" class="footnote-item"><p>select * from information_schema.innodb_trx; 查找处于事务中的id <a href="#fnref14" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn15" class="footnote-item"><p>对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志 <a href="#fnref15" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn16" class="footnote-item"><p>一个正在执行的事务产生的redo log 也是直接写到 redo  log buffer 的，即一个未被提交的事务也有可能持久化到磁盘 <a href="#fnref16" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn17" class="footnote-item"><p>log sequence number，LSN <a href="#fnref17" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn18" class="footnote-item"><p>一次性地用 delete 语句删除太多数据。其实，这就是一个典型的大事务场景,另一种典型的大事务场景，就是大表 DDL <a href="#fnref18" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn19" class="footnote-item"><p>在 MySQL 里面我们说 transaction_id 就是指事务 id，事务 id 是在事务执行过程中分配的，如果这个事务回滚了，事务 id 也会递增，而 gno 是在事务提交的时候才会分配 <a href="#fnref19" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn20" class="footnote-item"><p>join_buffer 是可以通过 join_buffer_size 进行设定的,默认256k) <a href="#fnref20" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
